
measuring negative temperature  degrees.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000d8c  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  00000d8c  00000e00  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .stab         00001df4  00000000  00000000  00000e10  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000644  00000000  00000000  00002c04  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000100  00000000  00000000  00003248  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000bf8  00000000  00000000  00003348  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000367  00000000  00000000  00003f40  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000729  00000000  00000000  000042a7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000284  00000000  00000000  000049d0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000379  00000000  00000000  00004c54  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000a9c  00000000  00000000  00004fcd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ec e8       	ldi	r30, 0x8C	; 140
  68:	fd e0       	ldi	r31, 0x0D	; 13
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ae 36       	cpi	r26, 0x6E	; 110
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	ae e6       	ldi	r26, 0x6E	; 110
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ae 36       	cpi	r26, 0x6E	; 110
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 4f 04 	call	0x89e	; 0x89e <main>
  8a:	0c 94 c4 06 	jmp	0xd88	; 0xd88 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <ADC_INIT>:

void ADC_INIT ()
{
	//SET_BIT(ADMUX,REFS0); //configre vref = AVCC
	 //configre vref = 2.56 (internal vref)
	SET_BIT(ADMUX,REFS0);
  92:	3e 9a       	sbi	0x07, 6	; 7
	SET_BIT(ADMUX,REFS1);
  94:	3f 9a       	sbi	0x07, 7	; 7
	
	SET_BIT(ADCSRA,ADEN); //enable ADC
  96:	37 9a       	sbi	0x06, 7	; 6
	SET_BIT(ADCSRA,ADPS1); //set clk of ADC
  98:	31 9a       	sbi	0x06, 1	; 6
	SET_BIT(ADCSRA,ADPS2);
  9a:	32 9a       	sbi	0x06, 2	; 6
	SET_BIT(ADMUX,MUX4);
  9c:	3c 9a       	sbi	0x07, 4	; 7
}
  9e:	08 95       	ret

000000a0 <ADC_READ>:

unsigned short ADC_READ()
{
	unsigned short read_value;
	SET_BIT(ADCSRA,ADSC);
  a0:	36 9a       	sbi	0x06, 6	; 6
	while(READ_BIT(ADCSRA,ADIF)== 0);
  a2:	34 9b       	sbis	0x06, 4	; 6
  a4:	fe cf       	rjmp	.-4      	; 0xa2 <ADC_READ+0x2>
	SET_BIT(ADCSRA,ADIF);
  a6:	34 9a       	sbi	0x06, 4	; 6
	read_value=ADCL;
  a8:	84 b1       	in	r24, 0x04	; 4
  aa:	90 e0       	ldi	r25, 0x00	; 0
	read_value|=(ADCH<<8);
  ac:	45 b1       	in	r20, 0x05	; 5
  ae:	34 2f       	mov	r19, r20
  b0:	20 e0       	ldi	r18, 0x00	; 0
  b2:	82 2b       	or	r24, r18
  b4:	93 2b       	or	r25, r19
	return read_value;
  b6:	08 95       	ret

000000b8 <DIO_SETPINDIR>:
#include <avr/io.h>
//access DDR register to make the pins input or output
// Function Description:Set the direction of the given pin in the given port (direction 0 = input : 1 = output)
void DIO_SETPINDIR (unsigned char portname,unsigned char pinnumber,unsigned char direction)
{
	switch(portname)
  b8:	84 34       	cpi	r24, 0x44	; 68
  ba:	09 f4       	brne	.+2      	; 0xbe <DIO_SETPINDIR+0x6>
  bc:	79 c0       	rjmp	.+242    	; 0x1b0 <DIO_SETPINDIR+0xf8>
  be:	85 34       	cpi	r24, 0x45	; 69
  c0:	48 f4       	brcc	.+18     	; 0xd4 <DIO_SETPINDIR+0x1c>
  c2:	82 34       	cpi	r24, 0x42	; 66
  c4:	b1 f1       	breq	.+108    	; 0x132 <DIO_SETPINDIR+0x7a>
  c6:	83 34       	cpi	r24, 0x43	; 67
  c8:	08 f0       	brcs	.+2      	; 0xcc <DIO_SETPINDIR+0x14>
  ca:	53 c0       	rjmp	.+166    	; 0x172 <DIO_SETPINDIR+0xba>
  cc:	81 34       	cpi	r24, 0x41	; 65
  ce:	09 f0       	breq	.+2      	; 0xd2 <DIO_SETPINDIR+0x1a>
  d0:	8d c0       	rjmp	.+282    	; 0x1ec <DIO_SETPINDIR+0x134>
  d2:	0f c0       	rjmp	.+30     	; 0xf2 <DIO_SETPINDIR+0x3a>
  d4:	82 36       	cpi	r24, 0x62	; 98
  d6:	69 f1       	breq	.+90     	; 0x132 <DIO_SETPINDIR+0x7a>
  d8:	83 36       	cpi	r24, 0x63	; 99
  da:	20 f4       	brcc	.+8      	; 0xe4 <DIO_SETPINDIR+0x2c>
  dc:	81 36       	cpi	r24, 0x61	; 97
  de:	09 f0       	breq	.+2      	; 0xe2 <DIO_SETPINDIR+0x2a>
  e0:	85 c0       	rjmp	.+266    	; 0x1ec <DIO_SETPINDIR+0x134>
  e2:	07 c0       	rjmp	.+14     	; 0xf2 <DIO_SETPINDIR+0x3a>
  e4:	83 36       	cpi	r24, 0x63	; 99
  e6:	09 f4       	brne	.+2      	; 0xea <DIO_SETPINDIR+0x32>
  e8:	44 c0       	rjmp	.+136    	; 0x172 <DIO_SETPINDIR+0xba>
  ea:	84 36       	cpi	r24, 0x64	; 100
  ec:	09 f0       	breq	.+2      	; 0xf0 <DIO_SETPINDIR+0x38>
  ee:	7e c0       	rjmp	.+252    	; 0x1ec <DIO_SETPINDIR+0x134>
  f0:	5f c0       	rjmp	.+190    	; 0x1b0 <DIO_SETPINDIR+0xf8>
	{
		case'A':
		case'a':
		if(direction==1)
  f2:	41 30       	cpi	r20, 0x01	; 1
  f4:	69 f4       	brne	.+26     	; 0x110 <DIO_SETPINDIR+0x58>
		{
			SET_BIT(DDRA,pinnumber);   //set the pin whose its number given by (pinnumber) in DDR register as output
  f6:	2a b3       	in	r18, 0x1a	; 26
  f8:	81 e0       	ldi	r24, 0x01	; 1
  fa:	90 e0       	ldi	r25, 0x00	; 0
  fc:	ac 01       	movw	r20, r24
  fe:	02 c0       	rjmp	.+4      	; 0x104 <DIO_SETPINDIR+0x4c>
 100:	44 0f       	add	r20, r20
 102:	55 1f       	adc	r21, r21
 104:	6a 95       	dec	r22
 106:	e2 f7       	brpl	.-8      	; 0x100 <DIO_SETPINDIR+0x48>
 108:	ba 01       	movw	r22, r20
 10a:	62 2b       	or	r22, r18
 10c:	6a bb       	out	0x1a, r22	; 26
 10e:	08 95       	ret
		}
		if(direction==0)
 110:	44 23       	and	r20, r20
 112:	09 f0       	breq	.+2      	; 0x116 <DIO_SETPINDIR+0x5e>
 114:	6b c0       	rjmp	.+214    	; 0x1ec <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRA,pinnumber);  //set the pin whose its number given by (pinnumber) in DDR register as input
 116:	2a b3       	in	r18, 0x1a	; 26
 118:	81 e0       	ldi	r24, 0x01	; 1
 11a:	90 e0       	ldi	r25, 0x00	; 0
 11c:	ac 01       	movw	r20, r24
 11e:	02 c0       	rjmp	.+4      	; 0x124 <DIO_SETPINDIR+0x6c>
 120:	44 0f       	add	r20, r20
 122:	55 1f       	adc	r21, r21
 124:	6a 95       	dec	r22
 126:	e2 f7       	brpl	.-8      	; 0x120 <DIO_SETPINDIR+0x68>
 128:	ba 01       	movw	r22, r20
 12a:	60 95       	com	r22
 12c:	62 23       	and	r22, r18
 12e:	6a bb       	out	0x1a, r22	; 26
 130:	08 95       	ret
		}
		break;
		case'B':
		case'b':
		if(direction==1)
 132:	41 30       	cpi	r20, 0x01	; 1
 134:	69 f4       	brne	.+26     	; 0x150 <DIO_SETPINDIR+0x98>
		{
			SET_BIT(DDRB,pinnumber);  
 136:	27 b3       	in	r18, 0x17	; 23
 138:	81 e0       	ldi	r24, 0x01	; 1
 13a:	90 e0       	ldi	r25, 0x00	; 0
 13c:	ac 01       	movw	r20, r24
 13e:	02 c0       	rjmp	.+4      	; 0x144 <DIO_SETPINDIR+0x8c>
 140:	44 0f       	add	r20, r20
 142:	55 1f       	adc	r21, r21
 144:	6a 95       	dec	r22
 146:	e2 f7       	brpl	.-8      	; 0x140 <DIO_SETPINDIR+0x88>
 148:	ba 01       	movw	r22, r20
 14a:	62 2b       	or	r22, r18
 14c:	67 bb       	out	0x17, r22	; 23
 14e:	08 95       	ret
		}
		if(direction==0)
 150:	44 23       	and	r20, r20
 152:	09 f0       	breq	.+2      	; 0x156 <DIO_SETPINDIR+0x9e>
 154:	4b c0       	rjmp	.+150    	; 0x1ec <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRB,pinnumber);
 156:	27 b3       	in	r18, 0x17	; 23
 158:	81 e0       	ldi	r24, 0x01	; 1
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	ac 01       	movw	r20, r24
 15e:	02 c0       	rjmp	.+4      	; 0x164 <DIO_SETPINDIR+0xac>
 160:	44 0f       	add	r20, r20
 162:	55 1f       	adc	r21, r21
 164:	6a 95       	dec	r22
 166:	e2 f7       	brpl	.-8      	; 0x160 <DIO_SETPINDIR+0xa8>
 168:	ba 01       	movw	r22, r20
 16a:	60 95       	com	r22
 16c:	62 23       	and	r22, r18
 16e:	67 bb       	out	0x17, r22	; 23
 170:	08 95       	ret
		}
		break;
		case'C':
		case'c':
		if(direction==1)
 172:	41 30       	cpi	r20, 0x01	; 1
 174:	69 f4       	brne	.+26     	; 0x190 <DIO_SETPINDIR+0xd8>
		{
			SET_BIT(DDRC,pinnumber);   
 176:	24 b3       	in	r18, 0x14	; 20
 178:	81 e0       	ldi	r24, 0x01	; 1
 17a:	90 e0       	ldi	r25, 0x00	; 0
 17c:	ac 01       	movw	r20, r24
 17e:	02 c0       	rjmp	.+4      	; 0x184 <DIO_SETPINDIR+0xcc>
 180:	44 0f       	add	r20, r20
 182:	55 1f       	adc	r21, r21
 184:	6a 95       	dec	r22
 186:	e2 f7       	brpl	.-8      	; 0x180 <DIO_SETPINDIR+0xc8>
 188:	ba 01       	movw	r22, r20
 18a:	62 2b       	or	r22, r18
 18c:	64 bb       	out	0x14, r22	; 20
 18e:	08 95       	ret
		}
		if(direction==0)
 190:	44 23       	and	r20, r20
 192:	61 f5       	brne	.+88     	; 0x1ec <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRC,pinnumber);
 194:	24 b3       	in	r18, 0x14	; 20
 196:	81 e0       	ldi	r24, 0x01	; 1
 198:	90 e0       	ldi	r25, 0x00	; 0
 19a:	ac 01       	movw	r20, r24
 19c:	02 c0       	rjmp	.+4      	; 0x1a2 <DIO_SETPINDIR+0xea>
 19e:	44 0f       	add	r20, r20
 1a0:	55 1f       	adc	r21, r21
 1a2:	6a 95       	dec	r22
 1a4:	e2 f7       	brpl	.-8      	; 0x19e <DIO_SETPINDIR+0xe6>
 1a6:	ba 01       	movw	r22, r20
 1a8:	60 95       	com	r22
 1aa:	62 23       	and	r22, r18
 1ac:	64 bb       	out	0x14, r22	; 20
 1ae:	08 95       	ret
		}
		break;
		case'D':
		case'd':
		if(direction==1)
 1b0:	41 30       	cpi	r20, 0x01	; 1
 1b2:	69 f4       	brne	.+26     	; 0x1ce <DIO_SETPINDIR+0x116>
		{
			SET_BIT(DDRD,pinnumber);   
 1b4:	21 b3       	in	r18, 0x11	; 17
 1b6:	81 e0       	ldi	r24, 0x01	; 1
 1b8:	90 e0       	ldi	r25, 0x00	; 0
 1ba:	ac 01       	movw	r20, r24
 1bc:	02 c0       	rjmp	.+4      	; 0x1c2 <DIO_SETPINDIR+0x10a>
 1be:	44 0f       	add	r20, r20
 1c0:	55 1f       	adc	r21, r21
 1c2:	6a 95       	dec	r22
 1c4:	e2 f7       	brpl	.-8      	; 0x1be <DIO_SETPINDIR+0x106>
 1c6:	ba 01       	movw	r22, r20
 1c8:	62 2b       	or	r22, r18
 1ca:	61 bb       	out	0x11, r22	; 17
 1cc:	08 95       	ret
		}
		if(direction==0)
 1ce:	44 23       	and	r20, r20
 1d0:	69 f4       	brne	.+26     	; 0x1ec <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRD,pinnumber);
 1d2:	21 b3       	in	r18, 0x11	; 17
 1d4:	81 e0       	ldi	r24, 0x01	; 1
 1d6:	90 e0       	ldi	r25, 0x00	; 0
 1d8:	ac 01       	movw	r20, r24
 1da:	02 c0       	rjmp	.+4      	; 0x1e0 <DIO_SETPINDIR+0x128>
 1dc:	44 0f       	add	r20, r20
 1de:	55 1f       	adc	r21, r21
 1e0:	6a 95       	dec	r22
 1e2:	e2 f7       	brpl	.-8      	; 0x1dc <DIO_SETPINDIR+0x124>
 1e4:	ba 01       	movw	r22, r20
 1e6:	60 95       	com	r22
 1e8:	62 23       	and	r22, r18
 1ea:	61 bb       	out	0x11, r22	; 17
 1ec:	08 95       	ret

000001ee <DIO_WRITE>:
}
// access PORT register to write the output value that will be on the output pin 
//Function Description : Set the value of the given pin in the given port (outputvalue 0 = low : 1 = high) 
void DIO_WRITE (unsigned char portname,unsigned char pinnumber, unsigned char outputvalue)
{
	switch(portname)
 1ee:	84 34       	cpi	r24, 0x44	; 68
 1f0:	09 f4       	brne	.+2      	; 0x1f4 <DIO_WRITE+0x6>
 1f2:	71 c0       	rjmp	.+226    	; 0x2d6 <DIO_WRITE+0xe8>
 1f4:	85 34       	cpi	r24, 0x45	; 69
 1f6:	48 f4       	brcc	.+18     	; 0x20a <DIO_WRITE+0x1c>
 1f8:	82 34       	cpi	r24, 0x42	; 66
 1fa:	99 f1       	breq	.+102    	; 0x262 <DIO_WRITE+0x74>
 1fc:	83 34       	cpi	r24, 0x43	; 67
 1fe:	08 f0       	brcs	.+2      	; 0x202 <DIO_WRITE+0x14>
 200:	4d c0       	rjmp	.+154    	; 0x29c <DIO_WRITE+0xae>
 202:	81 34       	cpi	r24, 0x41	; 65
 204:	09 f0       	breq	.+2      	; 0x208 <DIO_WRITE+0x1a>
 206:	83 c0       	rjmp	.+262    	; 0x30e <DIO_WRITE+0x120>
 208:	0f c0       	rjmp	.+30     	; 0x228 <DIO_WRITE+0x3a>
 20a:	82 36       	cpi	r24, 0x62	; 98
 20c:	51 f1       	breq	.+84     	; 0x262 <DIO_WRITE+0x74>
 20e:	83 36       	cpi	r24, 0x63	; 99
 210:	20 f4       	brcc	.+8      	; 0x21a <DIO_WRITE+0x2c>
 212:	81 36       	cpi	r24, 0x61	; 97
 214:	09 f0       	breq	.+2      	; 0x218 <DIO_WRITE+0x2a>
 216:	7b c0       	rjmp	.+246    	; 0x30e <DIO_WRITE+0x120>
 218:	07 c0       	rjmp	.+14     	; 0x228 <DIO_WRITE+0x3a>
 21a:	83 36       	cpi	r24, 0x63	; 99
 21c:	09 f4       	brne	.+2      	; 0x220 <DIO_WRITE+0x32>
 21e:	3e c0       	rjmp	.+124    	; 0x29c <DIO_WRITE+0xae>
 220:	84 36       	cpi	r24, 0x64	; 100
 222:	09 f0       	breq	.+2      	; 0x226 <DIO_WRITE+0x38>
 224:	74 c0       	rjmp	.+232    	; 0x30e <DIO_WRITE+0x120>
 226:	57 c0       	rjmp	.+174    	; 0x2d6 <DIO_WRITE+0xe8>
	{
		case 'A':
		case'a':
		if(outputvalue == 1)
 228:	41 30       	cpi	r20, 0x01	; 1
 22a:	69 f4       	brne	.+26     	; 0x246 <DIO_WRITE+0x58>
		{
			SET_BIT(PORTA,pinnumber);
 22c:	2b b3       	in	r18, 0x1b	; 27
 22e:	81 e0       	ldi	r24, 0x01	; 1
 230:	90 e0       	ldi	r25, 0x00	; 0
 232:	ac 01       	movw	r20, r24
 234:	02 c0       	rjmp	.+4      	; 0x23a <DIO_WRITE+0x4c>
 236:	44 0f       	add	r20, r20
 238:	55 1f       	adc	r21, r21
 23a:	6a 95       	dec	r22
 23c:	e2 f7       	brpl	.-8      	; 0x236 <DIO_WRITE+0x48>
 23e:	ba 01       	movw	r22, r20
 240:	62 2b       	or	r22, r18
 242:	6b bb       	out	0x1b, r22	; 27
 244:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTA,pinnumber);
 246:	2b b3       	in	r18, 0x1b	; 27
 248:	81 e0       	ldi	r24, 0x01	; 1
 24a:	90 e0       	ldi	r25, 0x00	; 0
 24c:	ac 01       	movw	r20, r24
 24e:	02 c0       	rjmp	.+4      	; 0x254 <DIO_WRITE+0x66>
 250:	44 0f       	add	r20, r20
 252:	55 1f       	adc	r21, r21
 254:	6a 95       	dec	r22
 256:	e2 f7       	brpl	.-8      	; 0x250 <DIO_WRITE+0x62>
 258:	ba 01       	movw	r22, r20
 25a:	60 95       	com	r22
 25c:	62 23       	and	r22, r18
 25e:	6b bb       	out	0x1b, r22	; 27
 260:	08 95       	ret
		}
		break;
		case 'B':
		case'b':
		if(outputvalue == 1)
 262:	41 30       	cpi	r20, 0x01	; 1
 264:	69 f4       	brne	.+26     	; 0x280 <DIO_WRITE+0x92>
		{
			SET_BIT(PORTB,pinnumber);
 266:	28 b3       	in	r18, 0x18	; 24
 268:	81 e0       	ldi	r24, 0x01	; 1
 26a:	90 e0       	ldi	r25, 0x00	; 0
 26c:	ac 01       	movw	r20, r24
 26e:	02 c0       	rjmp	.+4      	; 0x274 <DIO_WRITE+0x86>
 270:	44 0f       	add	r20, r20
 272:	55 1f       	adc	r21, r21
 274:	6a 95       	dec	r22
 276:	e2 f7       	brpl	.-8      	; 0x270 <DIO_WRITE+0x82>
 278:	ba 01       	movw	r22, r20
 27a:	62 2b       	or	r22, r18
 27c:	68 bb       	out	0x18, r22	; 24
 27e:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTB,pinnumber);
 280:	28 b3       	in	r18, 0x18	; 24
 282:	81 e0       	ldi	r24, 0x01	; 1
 284:	90 e0       	ldi	r25, 0x00	; 0
 286:	ac 01       	movw	r20, r24
 288:	02 c0       	rjmp	.+4      	; 0x28e <DIO_WRITE+0xa0>
 28a:	44 0f       	add	r20, r20
 28c:	55 1f       	adc	r21, r21
 28e:	6a 95       	dec	r22
 290:	e2 f7       	brpl	.-8      	; 0x28a <DIO_WRITE+0x9c>
 292:	ba 01       	movw	r22, r20
 294:	60 95       	com	r22
 296:	62 23       	and	r22, r18
 298:	68 bb       	out	0x18, r22	; 24
 29a:	08 95       	ret
		}
		break;
		case 'C':
		case'c':
		if(outputvalue == 1)
 29c:	41 30       	cpi	r20, 0x01	; 1
 29e:	69 f4       	brne	.+26     	; 0x2ba <DIO_WRITE+0xcc>
		{
			SET_BIT(PORTC,pinnumber);
 2a0:	25 b3       	in	r18, 0x15	; 21
 2a2:	81 e0       	ldi	r24, 0x01	; 1
 2a4:	90 e0       	ldi	r25, 0x00	; 0
 2a6:	ac 01       	movw	r20, r24
 2a8:	02 c0       	rjmp	.+4      	; 0x2ae <DIO_WRITE+0xc0>
 2aa:	44 0f       	add	r20, r20
 2ac:	55 1f       	adc	r21, r21
 2ae:	6a 95       	dec	r22
 2b0:	e2 f7       	brpl	.-8      	; 0x2aa <DIO_WRITE+0xbc>
 2b2:	ba 01       	movw	r22, r20
 2b4:	62 2b       	or	r22, r18
 2b6:	65 bb       	out	0x15, r22	; 21
 2b8:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTC,pinnumber);
 2ba:	25 b3       	in	r18, 0x15	; 21
 2bc:	81 e0       	ldi	r24, 0x01	; 1
 2be:	90 e0       	ldi	r25, 0x00	; 0
 2c0:	ac 01       	movw	r20, r24
 2c2:	02 c0       	rjmp	.+4      	; 0x2c8 <DIO_WRITE+0xda>
 2c4:	44 0f       	add	r20, r20
 2c6:	55 1f       	adc	r21, r21
 2c8:	6a 95       	dec	r22
 2ca:	e2 f7       	brpl	.-8      	; 0x2c4 <DIO_WRITE+0xd6>
 2cc:	ba 01       	movw	r22, r20
 2ce:	60 95       	com	r22
 2d0:	62 23       	and	r22, r18
 2d2:	65 bb       	out	0x15, r22	; 21
 2d4:	08 95       	ret
		}
		break;
		case 'D':
		case'd':
		if(outputvalue == 1)
 2d6:	41 30       	cpi	r20, 0x01	; 1
 2d8:	69 f4       	brne	.+26     	; 0x2f4 <DIO_WRITE+0x106>
		{
			SET_BIT(PORTD,pinnumber);
 2da:	22 b3       	in	r18, 0x12	; 18
 2dc:	81 e0       	ldi	r24, 0x01	; 1
 2de:	90 e0       	ldi	r25, 0x00	; 0
 2e0:	ac 01       	movw	r20, r24
 2e2:	02 c0       	rjmp	.+4      	; 0x2e8 <DIO_WRITE+0xfa>
 2e4:	44 0f       	add	r20, r20
 2e6:	55 1f       	adc	r21, r21
 2e8:	6a 95       	dec	r22
 2ea:	e2 f7       	brpl	.-8      	; 0x2e4 <DIO_WRITE+0xf6>
 2ec:	ba 01       	movw	r22, r20
 2ee:	62 2b       	or	r22, r18
 2f0:	62 bb       	out	0x12, r22	; 18
 2f2:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTD,pinnumber);
 2f4:	22 b3       	in	r18, 0x12	; 18
 2f6:	81 e0       	ldi	r24, 0x01	; 1
 2f8:	90 e0       	ldi	r25, 0x00	; 0
 2fa:	ac 01       	movw	r20, r24
 2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_WRITE+0x114>
 2fe:	44 0f       	add	r20, r20
 300:	55 1f       	adc	r21, r21
 302:	6a 95       	dec	r22
 304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_WRITE+0x110>
 306:	ba 01       	movw	r22, r20
 308:	60 95       	com	r22
 30a:	62 23       	and	r22, r18
 30c:	62 bb       	out	0x12, r22	; 18
 30e:	08 95       	ret

00000310 <DIO_togglepin>:
}		
// access PORT register to toggle the output value that appear in the output pin
//	Function Description : Reverse the value of the given pin in the given port.
void DIO_togglepin(unsigned char portname,unsigned char pinnumber)
{
			switch(portname)
 310:	84 34       	cpi	r24, 0x44	; 68
 312:	09 f4       	brne	.+2      	; 0x316 <DIO_togglepin+0x6>
 314:	3d c0       	rjmp	.+122    	; 0x390 <DIO_togglepin+0x80>
 316:	85 34       	cpi	r24, 0x45	; 69
 318:	40 f4       	brcc	.+16     	; 0x32a <DIO_togglepin+0x1a>
 31a:	82 34       	cpi	r24, 0x42	; 66
 31c:	f9 f0       	breq	.+62     	; 0x35c <DIO_togglepin+0x4c>
 31e:	83 34       	cpi	r24, 0x43	; 67
 320:	50 f5       	brcc	.+84     	; 0x376 <DIO_togglepin+0x66>
 322:	81 34       	cpi	r24, 0x41	; 65
 324:	09 f0       	breq	.+2      	; 0x328 <DIO_togglepin+0x18>
 326:	40 c0       	rjmp	.+128    	; 0x3a8 <DIO_togglepin+0x98>
 328:	0c c0       	rjmp	.+24     	; 0x342 <DIO_togglepin+0x32>
 32a:	82 36       	cpi	r24, 0x62	; 98
 32c:	b9 f0       	breq	.+46     	; 0x35c <DIO_togglepin+0x4c>
 32e:	83 36       	cpi	r24, 0x63	; 99
 330:	18 f4       	brcc	.+6      	; 0x338 <DIO_togglepin+0x28>
 332:	81 36       	cpi	r24, 0x61	; 97
 334:	c9 f5       	brne	.+114    	; 0x3a8 <DIO_togglepin+0x98>
 336:	05 c0       	rjmp	.+10     	; 0x342 <DIO_togglepin+0x32>
 338:	83 36       	cpi	r24, 0x63	; 99
 33a:	e9 f0       	breq	.+58     	; 0x376 <DIO_togglepin+0x66>
 33c:	84 36       	cpi	r24, 0x64	; 100
 33e:	a1 f5       	brne	.+104    	; 0x3a8 <DIO_togglepin+0x98>
 340:	27 c0       	rjmp	.+78     	; 0x390 <DIO_togglepin+0x80>
			{
				case 'A':
				case 'a':
				TOGGLE_BIT(PORTA,pinnumber);
 342:	2b b3       	in	r18, 0x1b	; 27
 344:	81 e0       	ldi	r24, 0x01	; 1
 346:	90 e0       	ldi	r25, 0x00	; 0
 348:	ac 01       	movw	r20, r24
 34a:	02 c0       	rjmp	.+4      	; 0x350 <DIO_togglepin+0x40>
 34c:	44 0f       	add	r20, r20
 34e:	55 1f       	adc	r21, r21
 350:	6a 95       	dec	r22
 352:	e2 f7       	brpl	.-8      	; 0x34c <DIO_togglepin+0x3c>
 354:	ba 01       	movw	r22, r20
 356:	62 27       	eor	r22, r18
 358:	6b bb       	out	0x1b, r22	; 27
				break;
 35a:	08 95       	ret
				
				case 'B':
				case 'b':
				TOGGLE_BIT(PORTB,pinnumber);
 35c:	28 b3       	in	r18, 0x18	; 24
 35e:	81 e0       	ldi	r24, 0x01	; 1
 360:	90 e0       	ldi	r25, 0x00	; 0
 362:	ac 01       	movw	r20, r24
 364:	02 c0       	rjmp	.+4      	; 0x36a <DIO_togglepin+0x5a>
 366:	44 0f       	add	r20, r20
 368:	55 1f       	adc	r21, r21
 36a:	6a 95       	dec	r22
 36c:	e2 f7       	brpl	.-8      	; 0x366 <DIO_togglepin+0x56>
 36e:	ba 01       	movw	r22, r20
 370:	62 27       	eor	r22, r18
 372:	68 bb       	out	0x18, r22	; 24
				break;
 374:	08 95       	ret
				
				case 'C':
				case 'c':
				TOGGLE_BIT(PORTC,pinnumber);
 376:	25 b3       	in	r18, 0x15	; 21
 378:	81 e0       	ldi	r24, 0x01	; 1
 37a:	90 e0       	ldi	r25, 0x00	; 0
 37c:	ac 01       	movw	r20, r24
 37e:	02 c0       	rjmp	.+4      	; 0x384 <DIO_togglepin+0x74>
 380:	44 0f       	add	r20, r20
 382:	55 1f       	adc	r21, r21
 384:	6a 95       	dec	r22
 386:	e2 f7       	brpl	.-8      	; 0x380 <DIO_togglepin+0x70>
 388:	ba 01       	movw	r22, r20
 38a:	62 27       	eor	r22, r18
 38c:	65 bb       	out	0x15, r22	; 21
				break;
 38e:	08 95       	ret
				
				case 'D':
				case 'd':
				TOGGLE_BIT(PORTD,pinnumber);
 390:	22 b3       	in	r18, 0x12	; 18
 392:	81 e0       	ldi	r24, 0x01	; 1
 394:	90 e0       	ldi	r25, 0x00	; 0
 396:	ac 01       	movw	r20, r24
 398:	02 c0       	rjmp	.+4      	; 0x39e <DIO_togglepin+0x8e>
 39a:	44 0f       	add	r20, r20
 39c:	55 1f       	adc	r21, r21
 39e:	6a 95       	dec	r22
 3a0:	e2 f7       	brpl	.-8      	; 0x39a <DIO_togglepin+0x8a>
 3a2:	ba 01       	movw	r22, r20
 3a4:	62 27       	eor	r22, r18
 3a6:	62 bb       	out	0x12, r22	; 18
 3a8:	08 95       	ret

000003aa <DIO_readpin>:
//Function Description : Returns 1 if the value of the given pin is high and zero if the value is low
//access pin register to know the reading of pin reg in case it is input pin to know the value of the voltage that it received from the input device connected to it
unsigned char DIO_readpin(unsigned char portname,unsigned char bitnumber)
{
	unsigned char reading=0;
	switch(portname)
 3aa:	84 34       	cpi	r24, 0x44	; 68
 3ac:	09 f4       	brne	.+2      	; 0x3b0 <DIO_readpin+0x6>
 3ae:	4e c0       	rjmp	.+156    	; 0x44c <DIO_readpin+0xa2>
 3b0:	85 34       	cpi	r24, 0x45	; 69
 3b2:	40 f4       	brcc	.+16     	; 0x3c4 <DIO_readpin+0x1a>
 3b4:	82 34       	cpi	r24, 0x42	; 66
 3b6:	31 f1       	breq	.+76     	; 0x404 <DIO_readpin+0x5a>
 3b8:	83 34       	cpi	r24, 0x43	; 67
 3ba:	b0 f5       	brcc	.+108    	; 0x428 <DIO_readpin+0x7e>
 3bc:	81 34       	cpi	r24, 0x41	; 65
 3be:	09 f0       	breq	.+2      	; 0x3c2 <DIO_readpin+0x18>
 3c0:	57 c0       	rjmp	.+174    	; 0x470 <DIO_readpin+0xc6>
 3c2:	0e c0       	rjmp	.+28     	; 0x3e0 <DIO_readpin+0x36>
 3c4:	82 36       	cpi	r24, 0x62	; 98
 3c6:	f1 f0       	breq	.+60     	; 0x404 <DIO_readpin+0x5a>
 3c8:	83 36       	cpi	r24, 0x63	; 99
 3ca:	20 f4       	brcc	.+8      	; 0x3d4 <DIO_readpin+0x2a>
 3cc:	81 36       	cpi	r24, 0x61	; 97
 3ce:	09 f0       	breq	.+2      	; 0x3d2 <DIO_readpin+0x28>
 3d0:	4f c0       	rjmp	.+158    	; 0x470 <DIO_readpin+0xc6>
 3d2:	06 c0       	rjmp	.+12     	; 0x3e0 <DIO_readpin+0x36>
 3d4:	83 36       	cpi	r24, 0x63	; 99
 3d6:	41 f1       	breq	.+80     	; 0x428 <DIO_readpin+0x7e>
 3d8:	84 36       	cpi	r24, 0x64	; 100
 3da:	09 f0       	breq	.+2      	; 0x3de <DIO_readpin+0x34>
 3dc:	49 c0       	rjmp	.+146    	; 0x470 <DIO_readpin+0xc6>
 3de:	36 c0       	rjmp	.+108    	; 0x44c <DIO_readpin+0xa2>
	{
		case'A':
		case'a':
		reading= READ_BIT(PINA,bitnumber);
 3e0:	29 b3       	in	r18, 0x19	; 25
 3e2:	81 e0       	ldi	r24, 0x01	; 1
 3e4:	90 e0       	ldi	r25, 0x00	; 0
 3e6:	06 2e       	mov	r0, r22
 3e8:	02 c0       	rjmp	.+4      	; 0x3ee <DIO_readpin+0x44>
 3ea:	88 0f       	add	r24, r24
 3ec:	99 1f       	adc	r25, r25
 3ee:	0a 94       	dec	r0
 3f0:	e2 f7       	brpl	.-8      	; 0x3ea <DIO_readpin+0x40>
 3f2:	30 e0       	ldi	r19, 0x00	; 0
 3f4:	82 23       	and	r24, r18
 3f6:	93 23       	and	r25, r19
 3f8:	02 c0       	rjmp	.+4      	; 0x3fe <DIO_readpin+0x54>
 3fa:	95 95       	asr	r25
 3fc:	87 95       	ror	r24
 3fe:	6a 95       	dec	r22
 400:	e2 f7       	brpl	.-8      	; 0x3fa <DIO_readpin+0x50>
		break;
 402:	08 95       	ret
		
		case'B':
		case'b':
		reading= READ_BIT(PINB,bitnumber);
 404:	26 b3       	in	r18, 0x16	; 22
 406:	81 e0       	ldi	r24, 0x01	; 1
 408:	90 e0       	ldi	r25, 0x00	; 0
 40a:	06 2e       	mov	r0, r22
 40c:	02 c0       	rjmp	.+4      	; 0x412 <DIO_readpin+0x68>
 40e:	88 0f       	add	r24, r24
 410:	99 1f       	adc	r25, r25
 412:	0a 94       	dec	r0
 414:	e2 f7       	brpl	.-8      	; 0x40e <DIO_readpin+0x64>
 416:	30 e0       	ldi	r19, 0x00	; 0
 418:	82 23       	and	r24, r18
 41a:	93 23       	and	r25, r19
 41c:	02 c0       	rjmp	.+4      	; 0x422 <DIO_readpin+0x78>
 41e:	95 95       	asr	r25
 420:	87 95       	ror	r24
 422:	6a 95       	dec	r22
 424:	e2 f7       	brpl	.-8      	; 0x41e <DIO_readpin+0x74>
		break;
 426:	08 95       	ret
		
		case'C':
		case'c':
		reading= READ_BIT(PINC,bitnumber);
 428:	23 b3       	in	r18, 0x13	; 19
 42a:	81 e0       	ldi	r24, 0x01	; 1
 42c:	90 e0       	ldi	r25, 0x00	; 0
 42e:	06 2e       	mov	r0, r22
 430:	02 c0       	rjmp	.+4      	; 0x436 <DIO_readpin+0x8c>
 432:	88 0f       	add	r24, r24
 434:	99 1f       	adc	r25, r25
 436:	0a 94       	dec	r0
 438:	e2 f7       	brpl	.-8      	; 0x432 <DIO_readpin+0x88>
 43a:	30 e0       	ldi	r19, 0x00	; 0
 43c:	82 23       	and	r24, r18
 43e:	93 23       	and	r25, r19
 440:	02 c0       	rjmp	.+4      	; 0x446 <DIO_readpin+0x9c>
 442:	95 95       	asr	r25
 444:	87 95       	ror	r24
 446:	6a 95       	dec	r22
 448:	e2 f7       	brpl	.-8      	; 0x442 <DIO_readpin+0x98>
		break;
 44a:	08 95       	ret
		
		case'D':
		case'd':
		reading= READ_BIT(PIND,bitnumber);
 44c:	20 b3       	in	r18, 0x10	; 16
 44e:	81 e0       	ldi	r24, 0x01	; 1
 450:	90 e0       	ldi	r25, 0x00	; 0
 452:	06 2e       	mov	r0, r22
 454:	02 c0       	rjmp	.+4      	; 0x45a <DIO_readpin+0xb0>
 456:	88 0f       	add	r24, r24
 458:	99 1f       	adc	r25, r25
 45a:	0a 94       	dec	r0
 45c:	e2 f7       	brpl	.-8      	; 0x456 <DIO_readpin+0xac>
 45e:	30 e0       	ldi	r19, 0x00	; 0
 460:	82 23       	and	r24, r18
 462:	93 23       	and	r25, r19
 464:	02 c0       	rjmp	.+4      	; 0x46a <DIO_readpin+0xc0>
 466:	95 95       	asr	r25
 468:	87 95       	ror	r24
 46a:	6a 95       	dec	r22
 46c:	e2 f7       	brpl	.-8      	; 0x466 <DIO_readpin+0xbc>
		break;	
 46e:	08 95       	ret
}
//Function Description : Returns 1 if the value of the given pin is high and zero if the value is low
//access pin register to know the reading of pin reg in case it is input pin to know the value of the voltage that it received from the input device connected to it
unsigned char DIO_readpin(unsigned char portname,unsigned char bitnumber)
{
	unsigned char reading=0;
 470:	80 e0       	ldi	r24, 0x00	; 0
		case'd':
		reading= READ_BIT(PIND,bitnumber);
		break;	
	}
	return reading;	
}
 472:	08 95       	ret

00000474 <DIO_set_port_direction>:
//	Function Description : set the direction of whole port .
//to set the direction of the whole port (all pins of the port will be input or output )
void DIO_set_port_direction(unsigned char portname,unsigned char direction)
{
	switch(portname)
 474:	84 34       	cpi	r24, 0x44	; 68
 476:	d9 f0       	breq	.+54     	; 0x4ae <DIO_set_port_direction+0x3a>
 478:	85 34       	cpi	r24, 0x45	; 69
 47a:	38 f4       	brcc	.+14     	; 0x48a <DIO_set_port_direction+0x16>
 47c:	82 34       	cpi	r24, 0x42	; 66
 47e:	99 f0       	breq	.+38     	; 0x4a6 <DIO_set_port_direction+0x32>
 480:	83 34       	cpi	r24, 0x43	; 67
 482:	98 f4       	brcc	.+38     	; 0x4aa <DIO_set_port_direction+0x36>
 484:	81 34       	cpi	r24, 0x41	; 65
 486:	a1 f4       	brne	.+40     	; 0x4b0 <DIO_set_port_direction+0x3c>
 488:	0c c0       	rjmp	.+24     	; 0x4a2 <DIO_set_port_direction+0x2e>
 48a:	82 36       	cpi	r24, 0x62	; 98
 48c:	61 f0       	breq	.+24     	; 0x4a6 <DIO_set_port_direction+0x32>
 48e:	83 36       	cpi	r24, 0x63	; 99
 490:	18 f4       	brcc	.+6      	; 0x498 <DIO_set_port_direction+0x24>
 492:	81 36       	cpi	r24, 0x61	; 97
 494:	69 f4       	brne	.+26     	; 0x4b0 <DIO_set_port_direction+0x3c>
 496:	05 c0       	rjmp	.+10     	; 0x4a2 <DIO_set_port_direction+0x2e>
 498:	83 36       	cpi	r24, 0x63	; 99
 49a:	39 f0       	breq	.+14     	; 0x4aa <DIO_set_port_direction+0x36>
 49c:	84 36       	cpi	r24, 0x64	; 100
 49e:	41 f4       	brne	.+16     	; 0x4b0 <DIO_set_port_direction+0x3c>
 4a0:	06 c0       	rjmp	.+12     	; 0x4ae <DIO_set_port_direction+0x3a>
	{
		case'A':
		case'a':
		DDRA=direction;
 4a2:	6a bb       	out	0x1a, r22	; 26
		break;
 4a4:	08 95       	ret
		case'B':
		case'b':
		DDRB=direction;
 4a6:	67 bb       	out	0x17, r22	; 23
		break;
 4a8:	08 95       	ret
		case'C':
		case'c':
		DDRC=direction;
 4aa:	64 bb       	out	0x14, r22	; 20
		break;
 4ac:	08 95       	ret
		case'D':
		case'd':
		DDRD=direction;
 4ae:	61 bb       	out	0x11, r22	; 17
 4b0:	08 95       	ret

000004b2 <DIO_write_port>:
	}
}
//	Function Description : Write the value to all port pins.
void DIO_write_port(unsigned char portname,unsigned char portvalue)
{
	switch(portname)
 4b2:	84 34       	cpi	r24, 0x44	; 68
 4b4:	d9 f0       	breq	.+54     	; 0x4ec <DIO_write_port+0x3a>
 4b6:	85 34       	cpi	r24, 0x45	; 69
 4b8:	38 f4       	brcc	.+14     	; 0x4c8 <DIO_write_port+0x16>
 4ba:	82 34       	cpi	r24, 0x42	; 66
 4bc:	99 f0       	breq	.+38     	; 0x4e4 <DIO_write_port+0x32>
 4be:	83 34       	cpi	r24, 0x43	; 67
 4c0:	98 f4       	brcc	.+38     	; 0x4e8 <DIO_write_port+0x36>
 4c2:	81 34       	cpi	r24, 0x41	; 65
 4c4:	a1 f4       	brne	.+40     	; 0x4ee <DIO_write_port+0x3c>
 4c6:	0c c0       	rjmp	.+24     	; 0x4e0 <DIO_write_port+0x2e>
 4c8:	82 36       	cpi	r24, 0x62	; 98
 4ca:	61 f0       	breq	.+24     	; 0x4e4 <DIO_write_port+0x32>
 4cc:	83 36       	cpi	r24, 0x63	; 99
 4ce:	18 f4       	brcc	.+6      	; 0x4d6 <DIO_write_port+0x24>
 4d0:	81 36       	cpi	r24, 0x61	; 97
 4d2:	69 f4       	brne	.+26     	; 0x4ee <DIO_write_port+0x3c>
 4d4:	05 c0       	rjmp	.+10     	; 0x4e0 <DIO_write_port+0x2e>
 4d6:	83 36       	cpi	r24, 0x63	; 99
 4d8:	39 f0       	breq	.+14     	; 0x4e8 <DIO_write_port+0x36>
 4da:	84 36       	cpi	r24, 0x64	; 100
 4dc:	41 f4       	brne	.+16     	; 0x4ee <DIO_write_port+0x3c>
 4de:	06 c0       	rjmp	.+12     	; 0x4ec <DIO_write_port+0x3a>
	{
		case'A':
		case'a':
		PORTA=portvalue;
 4e0:	6b bb       	out	0x1b, r22	; 27
		break;
 4e2:	08 95       	ret
		case'B':
		case'b':
		PORTB=portvalue;
 4e4:	68 bb       	out	0x18, r22	; 24
		break;
 4e6:	08 95       	ret
		case'C':
		case'c':
		PORTC=portvalue;
 4e8:	65 bb       	out	0x15, r22	; 21
		break;
 4ea:	08 95       	ret
		case'D':
		case'd':
		PORTD=portvalue;
 4ec:	62 bb       	out	0x12, r22	; 18
 4ee:	08 95       	ret

000004f0 <DIO_read_port>:
}
//	Function Description : read the value of the port .
unsigned char DIO_read_port(unsigned char portname)
{
	unsigned char reading_port=0;
	switch(portname)
 4f0:	84 34       	cpi	r24, 0x44	; 68
 4f2:	d9 f0       	breq	.+54     	; 0x52a <DIO_read_port+0x3a>
 4f4:	85 34       	cpi	r24, 0x45	; 69
 4f6:	38 f4       	brcc	.+14     	; 0x506 <DIO_read_port+0x16>
 4f8:	82 34       	cpi	r24, 0x42	; 66
 4fa:	99 f0       	breq	.+38     	; 0x522 <DIO_read_port+0x32>
 4fc:	83 34       	cpi	r24, 0x43	; 67
 4fe:	98 f4       	brcc	.+38     	; 0x526 <DIO_read_port+0x36>
 500:	81 34       	cpi	r24, 0x41	; 65
 502:	a9 f4       	brne	.+42     	; 0x52e <DIO_read_port+0x3e>
 504:	0c c0       	rjmp	.+24     	; 0x51e <DIO_read_port+0x2e>
 506:	82 36       	cpi	r24, 0x62	; 98
 508:	61 f0       	breq	.+24     	; 0x522 <DIO_read_port+0x32>
 50a:	83 36       	cpi	r24, 0x63	; 99
 50c:	18 f4       	brcc	.+6      	; 0x514 <DIO_read_port+0x24>
 50e:	81 36       	cpi	r24, 0x61	; 97
 510:	71 f4       	brne	.+28     	; 0x52e <DIO_read_port+0x3e>
 512:	05 c0       	rjmp	.+10     	; 0x51e <DIO_read_port+0x2e>
 514:	83 36       	cpi	r24, 0x63	; 99
 516:	39 f0       	breq	.+14     	; 0x526 <DIO_read_port+0x36>
 518:	84 36       	cpi	r24, 0x64	; 100
 51a:	49 f4       	brne	.+18     	; 0x52e <DIO_read_port+0x3e>
 51c:	06 c0       	rjmp	.+12     	; 0x52a <DIO_read_port+0x3a>
	{
		case'A':
		case'a':
		reading_port=PINA;
 51e:	89 b3       	in	r24, 0x19	; 25
		break;
 520:	08 95       	ret
		case'B':
		case'b':
		reading_port=PINB;
 522:	86 b3       	in	r24, 0x16	; 22
		break;
 524:	08 95       	ret
		case'C':
		case'c':
		reading_port=PINC;
 526:	83 b3       	in	r24, 0x13	; 19
		break;
 528:	08 95       	ret
		case'D':
		case'd':
		reading_port=PIND;
 52a:	80 b3       	in	r24, 0x10	; 16
		break;
 52c:	08 95       	ret
	}	
}
//	Function Description : read the value of the port .
unsigned char DIO_read_port(unsigned char portname)
{
	unsigned char reading_port=0;
 52e:	80 e0       	ldi	r24, 0x00	; 0
		reading_port=PIND;
		break;
		
	}
	return reading_port;
}
 530:	08 95       	ret

00000532 <DIO_toggle_port>:
//	Function Description : toggle the value of the port that stored in PORT reg if the led connected to output pin will exit to it logic 0 instead of logic 1 .
void DIO_toggle_port(unsigned char portname)
{
	switch(portname)
 532:	84 34       	cpi	r24, 0x44	; 68
 534:	09 f1       	breq	.+66     	; 0x578 <DIO_toggle_port+0x46>
 536:	85 34       	cpi	r24, 0x45	; 69
 538:	38 f4       	brcc	.+14     	; 0x548 <DIO_toggle_port+0x16>
 53a:	82 34       	cpi	r24, 0x42	; 66
 53c:	a9 f0       	breq	.+42     	; 0x568 <DIO_toggle_port+0x36>
 53e:	83 34       	cpi	r24, 0x43	; 67
 540:	b8 f4       	brcc	.+46     	; 0x570 <DIO_toggle_port+0x3e>
 542:	81 34       	cpi	r24, 0x41	; 65
 544:	e1 f4       	brne	.+56     	; 0x57e <DIO_toggle_port+0x4c>
 546:	0c c0       	rjmp	.+24     	; 0x560 <DIO_toggle_port+0x2e>
 548:	82 36       	cpi	r24, 0x62	; 98
 54a:	71 f0       	breq	.+28     	; 0x568 <DIO_toggle_port+0x36>
 54c:	83 36       	cpi	r24, 0x63	; 99
 54e:	18 f4       	brcc	.+6      	; 0x556 <DIO_toggle_port+0x24>
 550:	81 36       	cpi	r24, 0x61	; 97
 552:	a9 f4       	brne	.+42     	; 0x57e <DIO_toggle_port+0x4c>
 554:	05 c0       	rjmp	.+10     	; 0x560 <DIO_toggle_port+0x2e>
 556:	83 36       	cpi	r24, 0x63	; 99
 558:	59 f0       	breq	.+22     	; 0x570 <DIO_toggle_port+0x3e>
 55a:	84 36       	cpi	r24, 0x64	; 100
 55c:	81 f4       	brne	.+32     	; 0x57e <DIO_toggle_port+0x4c>
 55e:	0c c0       	rjmp	.+24     	; 0x578 <DIO_toggle_port+0x46>
	{
		case'A':
		case'a':
		PORTA= ~PORTA;   //PORTA^=0xff;
 560:	8b b3       	in	r24, 0x1b	; 27
 562:	80 95       	com	r24
 564:	8b bb       	out	0x1b, r24	; 27
		break;
 566:	08 95       	ret
		case'B':
		case'b':
		PORTB =~PORTB;   
 568:	88 b3       	in	r24, 0x18	; 24
 56a:	80 95       	com	r24
 56c:	88 bb       	out	0x18, r24	; 24
		break;
 56e:	08 95       	ret
		case'C':
		case'c':
		PORTC= ~PORTC;   
 570:	85 b3       	in	r24, 0x15	; 21
 572:	80 95       	com	r24
 574:	85 bb       	out	0x15, r24	; 21
		break;
 576:	08 95       	ret
		case'D':
		case'd':
		PORTD= ~PORTD;   
 578:	82 b3       	in	r24, 0x12	; 18
 57a:	80 95       	com	r24
 57c:	82 bb       	out	0x12, r24	; 18
 57e:	08 95       	ret

00000580 <DIO_CONNECT_PULLUP>:
		break;	
	}
}
void DIO_CONNECT_PULLUP(unsigned char portname,unsigned char pinnumber,unsigned char connect_pullup)
{
		DIO_WRITE(portname,pinnumber,connect_pullup);
 580:	0e 94 f7 00 	call	0x1ee	; 0x1ee <DIO_WRITE>
}
 584:	08 95       	ret

00000586 <DIO_WRITE_LOW_NIBBLE>:

void DIO_WRITE_LOW_NIBBLE(unsigned char portname,unsigned char value)
{
 586:	cf 92       	push	r12
 588:	df 92       	push	r13
 58a:	ff 92       	push	r15
 58c:	0f 93       	push	r16
 58e:	1f 93       	push	r17
 590:	cf 93       	push	r28
 592:	df 93       	push	r29
 594:	f8 2e       	mov	r15, r24
 596:	c0 e0       	ldi	r28, 0x00	; 0
 598:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_WRITE(portname,i,READ_BIT(value,i));
 59a:	01 e0       	ldi	r16, 0x01	; 1
 59c:	10 e0       	ldi	r17, 0x00	; 0
 59e:	c6 2e       	mov	r12, r22
 5a0:	dd 24       	eor	r13, r13
 5a2:	c8 01       	movw	r24, r16
 5a4:	0c 2e       	mov	r0, r28
 5a6:	02 c0       	rjmp	.+4      	; 0x5ac <DIO_WRITE_LOW_NIBBLE+0x26>
 5a8:	88 0f       	add	r24, r24
 5aa:	99 1f       	adc	r25, r25
 5ac:	0a 94       	dec	r0
 5ae:	e2 f7       	brpl	.-8      	; 0x5a8 <DIO_WRITE_LOW_NIBBLE+0x22>
 5b0:	8c 21       	and	r24, r12
 5b2:	9d 21       	and	r25, r13
 5b4:	9c 01       	movw	r18, r24
 5b6:	0c 2e       	mov	r0, r28
 5b8:	02 c0       	rjmp	.+4      	; 0x5be <DIO_WRITE_LOW_NIBBLE+0x38>
 5ba:	35 95       	asr	r19
 5bc:	27 95       	ror	r18
 5be:	0a 94       	dec	r0
 5c0:	e2 f7       	brpl	.-8      	; 0x5ba <DIO_WRITE_LOW_NIBBLE+0x34>
 5c2:	a9 01       	movw	r20, r18
 5c4:	8f 2d       	mov	r24, r15
 5c6:	6c 2f       	mov	r22, r28
 5c8:	0e 94 f7 00 	call	0x1ee	; 0x1ee <DIO_WRITE>
 5cc:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_WRITE_LOW_NIBBLE(unsigned char portname,unsigned char value)
{
	unsigned char i;
	for(i=0;i<=3;i++)
 5ce:	c4 30       	cpi	r28, 0x04	; 4
 5d0:	d1 05       	cpc	r29, r1
 5d2:	39 f7       	brne	.-50     	; 0x5a2 <DIO_WRITE_LOW_NIBBLE+0x1c>
	{
		DIO_WRITE(portname,i,READ_BIT(value,i));
	}
}
 5d4:	df 91       	pop	r29
 5d6:	cf 91       	pop	r28
 5d8:	1f 91       	pop	r17
 5da:	0f 91       	pop	r16
 5dc:	ff 90       	pop	r15
 5de:	df 90       	pop	r13
 5e0:	cf 90       	pop	r12
 5e2:	08 95       	ret

000005e4 <DIO_WRITE_HIGH_NIBBLE>:

void DIO_WRITE_HIGH_NIBBLE(unsigned char portname,unsigned char value)
{
 5e4:	cf 92       	push	r12
 5e6:	df 92       	push	r13
 5e8:	ff 92       	push	r15
 5ea:	0f 93       	push	r16
 5ec:	1f 93       	push	r17
 5ee:	cf 93       	push	r28
 5f0:	df 93       	push	r29
 5f2:	f8 2e       	mov	r15, r24
 5f4:	c0 e0       	ldi	r28, 0x00	; 0
 5f6:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=4;i<=7;i++)
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
 5f8:	01 e0       	ldi	r16, 0x01	; 1
 5fa:	10 e0       	ldi	r17, 0x00	; 0
 5fc:	c6 2e       	mov	r12, r22
 5fe:	dd 24       	eor	r13, r13
	{
		DIO_WRITE(portname,i,READ_BIT(value,i));
	}
}

void DIO_WRITE_HIGH_NIBBLE(unsigned char portname,unsigned char value)
 600:	6c 2f       	mov	r22, r28
 602:	6c 5f       	subi	r22, 0xFC	; 252
{
	unsigned char i;
	for(i=4;i<=7;i++)
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
 604:	c8 01       	movw	r24, r16
 606:	0c 2e       	mov	r0, r28
 608:	02 c0       	rjmp	.+4      	; 0x60e <DIO_WRITE_HIGH_NIBBLE+0x2a>
 60a:	88 0f       	add	r24, r24
 60c:	99 1f       	adc	r25, r25
 60e:	0a 94       	dec	r0
 610:	e2 f7       	brpl	.-8      	; 0x60a <DIO_WRITE_HIGH_NIBBLE+0x26>
 612:	8c 21       	and	r24, r12
 614:	9d 21       	and	r25, r13
 616:	9c 01       	movw	r18, r24
 618:	0c 2e       	mov	r0, r28
 61a:	02 c0       	rjmp	.+4      	; 0x620 <DIO_WRITE_HIGH_NIBBLE+0x3c>
 61c:	35 95       	asr	r19
 61e:	27 95       	ror	r18
 620:	0a 94       	dec	r0
 622:	e2 f7       	brpl	.-8      	; 0x61c <DIO_WRITE_HIGH_NIBBLE+0x38>
 624:	a9 01       	movw	r20, r18
 626:	8f 2d       	mov	r24, r15
 628:	0e 94 f7 00 	call	0x1ee	; 0x1ee <DIO_WRITE>
 62c:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_WRITE_HIGH_NIBBLE(unsigned char portname,unsigned char value)
{
	unsigned char i;
	for(i=4;i<=7;i++)
 62e:	c4 30       	cpi	r28, 0x04	; 4
 630:	d1 05       	cpc	r29, r1
 632:	31 f7       	brne	.-52     	; 0x600 <DIO_WRITE_HIGH_NIBBLE+0x1c>
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
	}
}
 634:	df 91       	pop	r29
 636:	cf 91       	pop	r28
 638:	1f 91       	pop	r17
 63a:	0f 91       	pop	r16
 63c:	ff 90       	pop	r15
 63e:	df 90       	pop	r13
 640:	cf 90       	pop	r12
 642:	08 95       	ret

00000644 <DIO_WRITE_NIBBLE>:

void DIO_WRITE_NIBBLE(unsigned char portname,unsigned char startpin,unsigned char value)
{
 644:	cf 92       	push	r12
 646:	df 92       	push	r13
 648:	ef 92       	push	r14
 64a:	ff 92       	push	r15
 64c:	0f 93       	push	r16
 64e:	1f 93       	push	r17
 650:	cf 93       	push	r28
 652:	df 93       	push	r29
 654:	08 2f       	mov	r16, r24
 656:	16 2f       	mov	r17, r22
 658:	c0 e0       	ldi	r28, 0x00	; 0
 65a:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
 65c:	ee 24       	eor	r14, r14
 65e:	ff 24       	eor	r15, r15
 660:	e3 94       	inc	r14
 662:	c4 2e       	mov	r12, r20
 664:	dd 24       	eor	r13, r13
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
	}
}

void DIO_WRITE_NIBBLE(unsigned char portname,unsigned char startpin,unsigned char value)
 666:	6c 2f       	mov	r22, r28
 668:	61 0f       	add	r22, r17
{
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
 66a:	c7 01       	movw	r24, r14
 66c:	0c 2e       	mov	r0, r28
 66e:	02 c0       	rjmp	.+4      	; 0x674 <DIO_WRITE_NIBBLE+0x30>
 670:	88 0f       	add	r24, r24
 672:	99 1f       	adc	r25, r25
 674:	0a 94       	dec	r0
 676:	e2 f7       	brpl	.-8      	; 0x670 <DIO_WRITE_NIBBLE+0x2c>
 678:	8c 21       	and	r24, r12
 67a:	9d 21       	and	r25, r13
 67c:	9c 01       	movw	r18, r24
 67e:	0c 2e       	mov	r0, r28
 680:	02 c0       	rjmp	.+4      	; 0x686 <DIO_WRITE_NIBBLE+0x42>
 682:	35 95       	asr	r19
 684:	27 95       	ror	r18
 686:	0a 94       	dec	r0
 688:	e2 f7       	brpl	.-8      	; 0x682 <DIO_WRITE_NIBBLE+0x3e>
 68a:	a9 01       	movw	r20, r18
 68c:	80 2f       	mov	r24, r16
 68e:	0e 94 f7 00 	call	0x1ee	; 0x1ee <DIO_WRITE>
 692:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_WRITE_NIBBLE(unsigned char portname,unsigned char startpin,unsigned char value)
{
	unsigned char i;
	for(i=0;i<=3;i++)
 694:	c4 30       	cpi	r28, 0x04	; 4
 696:	d1 05       	cpc	r29, r1
 698:	31 f7       	brne	.-52     	; 0x666 <DIO_WRITE_NIBBLE+0x22>
	{
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
		startpin++;
	}
}
 69a:	df 91       	pop	r29
 69c:	cf 91       	pop	r28
 69e:	1f 91       	pop	r17
 6a0:	0f 91       	pop	r16
 6a2:	ff 90       	pop	r15
 6a4:	ef 90       	pop	r14
 6a6:	df 90       	pop	r13
 6a8:	cf 90       	pop	r12
 6aa:	08 95       	ret

000006ac <DIO_SET_DIR_NIPPLE>:

void DIO_SET_DIR_NIPPLE(unsigned char portname,unsigned char startpin,unsigned char direction)
{
 6ac:	cf 92       	push	r12
 6ae:	df 92       	push	r13
 6b0:	ef 92       	push	r14
 6b2:	ff 92       	push	r15
 6b4:	0f 93       	push	r16
 6b6:	1f 93       	push	r17
 6b8:	cf 93       	push	r28
 6ba:	df 93       	push	r29
 6bc:	08 2f       	mov	r16, r24
 6be:	16 2f       	mov	r17, r22
 6c0:	c0 e0       	ldi	r28, 0x00	; 0
 6c2:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_SETPINDIR(portname,startpin,READ_BIT(direction,i));
 6c4:	ee 24       	eor	r14, r14
 6c6:	ff 24       	eor	r15, r15
 6c8:	e3 94       	inc	r14
 6ca:	c4 2e       	mov	r12, r20
 6cc:	dd 24       	eor	r13, r13
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
		startpin++;
	}
}

void DIO_SET_DIR_NIPPLE(unsigned char portname,unsigned char startpin,unsigned char direction)
 6ce:	6c 2f       	mov	r22, r28
 6d0:	61 0f       	add	r22, r17
{
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_SETPINDIR(portname,startpin,READ_BIT(direction,i));
 6d2:	c7 01       	movw	r24, r14
 6d4:	0c 2e       	mov	r0, r28
 6d6:	02 c0       	rjmp	.+4      	; 0x6dc <DIO_SET_DIR_NIPPLE+0x30>
 6d8:	88 0f       	add	r24, r24
 6da:	99 1f       	adc	r25, r25
 6dc:	0a 94       	dec	r0
 6de:	e2 f7       	brpl	.-8      	; 0x6d8 <DIO_SET_DIR_NIPPLE+0x2c>
 6e0:	8c 21       	and	r24, r12
 6e2:	9d 21       	and	r25, r13
 6e4:	9c 01       	movw	r18, r24
 6e6:	0c 2e       	mov	r0, r28
 6e8:	02 c0       	rjmp	.+4      	; 0x6ee <DIO_SET_DIR_NIPPLE+0x42>
 6ea:	35 95       	asr	r19
 6ec:	27 95       	ror	r18
 6ee:	0a 94       	dec	r0
 6f0:	e2 f7       	brpl	.-8      	; 0x6ea <DIO_SET_DIR_NIPPLE+0x3e>
 6f2:	a9 01       	movw	r20, r18
 6f4:	80 2f       	mov	r24, r16
 6f6:	0e 94 5c 00 	call	0xb8	; 0xb8 <DIO_SETPINDIR>
 6fa:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_SET_DIR_NIPPLE(unsigned char portname,unsigned char startpin,unsigned char direction)
{
	unsigned char i;
	for(i=0;i<=3;i++)
 6fc:	c4 30       	cpi	r28, 0x04	; 4
 6fe:	d1 05       	cpc	r29, r1
 700:	31 f7       	brne	.-52     	; 0x6ce <DIO_SET_DIR_NIPPLE+0x22>
	{
		DIO_SETPINDIR(portname,startpin,READ_BIT(direction,i));
		startpin++;
	}	
}
 702:	df 91       	pop	r29
 704:	cf 91       	pop	r28
 706:	1f 91       	pop	r17
 708:	0f 91       	pop	r16
 70a:	ff 90       	pop	r15
 70c:	ef 90       	pop	r14
 70e:	df 90       	pop	r13
 710:	cf 90       	pop	r12
 712:	08 95       	ret

00000714 <enable>:
		_delay_ms(1);
	}
}	
void enable()
{
	DIO_WRITE(port_control,EN,1);
 714:	84 e4       	ldi	r24, 0x44	; 68
 716:	62 e0       	ldi	r22, 0x02	; 2
 718:	41 e0       	ldi	r20, 0x01	; 1
 71a:	0e 94 f7 00 	call	0x1ee	; 0x1ee <DIO_WRITE>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 71e:	8f e9       	ldi	r24, 0x9F	; 159
 720:	9f e0       	ldi	r25, 0x0F	; 15
 722:	01 97       	sbiw	r24, 0x01	; 1
 724:	f1 f7       	brne	.-4      	; 0x722 <enable+0xe>
 726:	00 c0       	rjmp	.+0      	; 0x728 <enable+0x14>
 728:	00 00       	nop
	_delay_ms(2);
	DIO_WRITE(port_control,EN,0);
 72a:	84 e4       	ldi	r24, 0x44	; 68
 72c:	62 e0       	ldi	r22, 0x02	; 2
 72e:	40 e0       	ldi	r20, 0x00	; 0
 730:	0e 94 f7 00 	call	0x1ee	; 0x1ee <DIO_WRITE>
 734:	8f e9       	ldi	r24, 0x9F	; 159
 736:	9f e0       	ldi	r25, 0x0F	; 15
 738:	01 97       	sbiw	r24, 0x01	; 1
 73a:	f1 f7       	brne	.-4      	; 0x738 <enable+0x24>
 73c:	00 c0       	rjmp	.+0      	; 0x73e <enable+0x2a>
 73e:	00 00       	nop
	_delay_ms(2);
 740:	08 95       	ret

00000742 <LCD_SEND_CMD>:
		
	#endif
}

void LCD_SEND_CMD (unsigned char cmd)
{
 742:	cf 93       	push	r28
 744:	c8 2f       	mov	r28, r24
	DIO_WRITE(port_control,RS,0);
	enable();
	_delay_ms(1);   // time that the lcd execute the cmd ,all cmds take 1ms expect clear screen and return home so i made them in separated functions
	#else 
	#if defined HIGH_NIPPLE
	DIO_WRITE(port_control,RS,0);
 746:	84 e4       	ldi	r24, 0x44	; 68
 748:	60 e0       	ldi	r22, 0x00	; 0
 74a:	40 e0       	ldi	r20, 0x00	; 0
 74c:	0e 94 f7 00 	call	0x1ee	; 0x1ee <DIO_WRITE>
	DIO_WRITE_HIGH_NIBBLE(port_data,cmd>>4);
 750:	6c 2f       	mov	r22, r28
 752:	62 95       	swap	r22
 754:	6f 70       	andi	r22, 0x0F	; 15
 756:	84 e4       	ldi	r24, 0x44	; 68
 758:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <DIO_WRITE_HIGH_NIBBLE>
	enable();
 75c:	0e 94 8a 03 	call	0x714	; 0x714 <enable>
	DIO_WRITE_HIGH_NIBBLE(port_data,cmd);
 760:	84 e4       	ldi	r24, 0x44	; 68
 762:	6c 2f       	mov	r22, r28
 764:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <DIO_WRITE_HIGH_NIBBLE>
	enable();
 768:	0e 94 8a 03 	call	0x714	; 0x714 <enable>
	enable();
	_delay_ms(1);  //write this and if the cmd is clear screen or return home write after it delay 10 ms or do not write it in the function and after calling this function in main make a delay
	#endif
	#endif

}
 76c:	cf 91       	pop	r28
 76e:	08 95       	ret

00000770 <lCD_MOVE_CURSOR>:
}

void lCD_MOVE_CURSOR (unsigned char row,unsigned char column)
{
	char cmd;
	if(row<1 || row>2 || column<1 || column>16)  // any invalid case
 770:	98 2f       	mov	r25, r24
 772:	91 50       	subi	r25, 0x01	; 1
 774:	92 30       	cpi	r25, 0x02	; 2
 776:	60 f4       	brcc	.+24     	; 0x790 <lCD_MOVE_CURSOR+0x20>
 778:	66 23       	and	r22, r22
 77a:	61 f0       	breq	.+24     	; 0x794 <lCD_MOVE_CURSOR+0x24>
 77c:	61 31       	cpi	r22, 0x11	; 17
 77e:	60 f4       	brcc	.+24     	; 0x798 <lCD_MOVE_CURSOR+0x28>
	{
		cmd=0X80;
	}
	else if(row == 1)
 780:	81 30       	cpi	r24, 0x01	; 1
 782:	19 f4       	brne	.+6      	; 0x78a <lCD_MOVE_CURSOR+0x1a>
	{
		cmd=0X80+column-1;
 784:	86 2f       	mov	r24, r22
 786:	81 58       	subi	r24, 0x81	; 129
 788:	08 c0       	rjmp	.+16     	; 0x79a <lCD_MOVE_CURSOR+0x2a>
	}
	else
	{
		cmd=0XC0+column-1;
 78a:	86 2f       	mov	r24, r22
 78c:	81 54       	subi	r24, 0x41	; 65
 78e:	05 c0       	rjmp	.+10     	; 0x79a <lCD_MOVE_CURSOR+0x2a>
void lCD_MOVE_CURSOR (unsigned char row,unsigned char column)
{
	char cmd;
	if(row<1 || row>2 || column<1 || column>16)  // any invalid case
	{
		cmd=0X80;
 790:	80 e8       	ldi	r24, 0x80	; 128
 792:	03 c0       	rjmp	.+6      	; 0x79a <lCD_MOVE_CURSOR+0x2a>
 794:	80 e8       	ldi	r24, 0x80	; 128
 796:	01 c0       	rjmp	.+2      	; 0x79a <lCD_MOVE_CURSOR+0x2a>
 798:	80 e8       	ldi	r24, 0x80	; 128
	}
	else
	{
		cmd=0XC0+column-1;
	}
	LCD_SEND_CMD(cmd);
 79a:	0e 94 a1 03 	call	0x742	; 0x742 <LCD_SEND_CMD>
}
 79e:	08 95       	ret

000007a0 <LCD_Return_home>:
	_delay_ms(10);
}

void LCD_Return_home()
{
	LCD_SEND_CMD(Return_Home);
 7a0:	82 e0       	ldi	r24, 0x02	; 2
 7a2:	0e 94 a1 03 	call	0x742	; 0x742 <LCD_SEND_CMD>
 7a6:	8f e1       	ldi	r24, 0x1F	; 31
 7a8:	9e e4       	ldi	r25, 0x4E	; 78
 7aa:	01 97       	sbiw	r24, 0x01	; 1
 7ac:	f1 f7       	brne	.-4      	; 0x7aa <LCD_Return_home+0xa>
 7ae:	00 c0       	rjmp	.+0      	; 0x7b0 <LCD_Return_home+0x10>
 7b0:	00 00       	nop
	_delay_ms(10);
}
 7b2:	08 95       	ret

000007b4 <LCD_CLEAR_SCREEN>:

}

void LCD_CLEAR_SCREEN()
{
	LCD_SEND_CMD(clear_screen);
 7b4:	81 e0       	ldi	r24, 0x01	; 1
 7b6:	0e 94 a1 03 	call	0x742	; 0x742 <LCD_SEND_CMD>
 7ba:	8f e1       	ldi	r24, 0x1F	; 31
 7bc:	9e e4       	ldi	r25, 0x4E	; 78
 7be:	01 97       	sbiw	r24, 0x01	; 1
 7c0:	f1 f7       	brne	.-4      	; 0x7be <LCD_CLEAR_SCREEN+0xa>
 7c2:	00 c0       	rjmp	.+0      	; 0x7c4 <LCD_CLEAR_SCREEN+0x10>
 7c4:	00 00       	nop
	_delay_ms(10);
}
 7c6:	08 95       	ret

000007c8 <LCD_INIT>:
 7c8:	8f ef       	ldi	r24, 0xFF	; 255
 7ca:	91 ee       	ldi	r25, 0xE1	; 225
 7cc:	a4 e0       	ldi	r26, 0x04	; 4
 7ce:	81 50       	subi	r24, 0x01	; 1
 7d0:	90 40       	sbci	r25, 0x00	; 0
 7d2:	a0 40       	sbci	r26, 0x00	; 0
 7d4:	e1 f7       	brne	.-8      	; 0x7ce <LCD_INIT+0x6>
 7d6:	00 c0       	rjmp	.+0      	; 0x7d8 <LCD_INIT+0x10>
 7d8:	00 00       	nop
	LCD_SEND_CMD(Display_on_Cursor_on);  //display on/off control
	LCD_CLEAR_SCREEN();
	LCD_SEND_CMD(Entry_Mode);
	#else
	#if defined HIGH_NIPPLE
	DIO_SETPINDIR(port_data,4,1);
 7da:	84 e4       	ldi	r24, 0x44	; 68
 7dc:	64 e0       	ldi	r22, 0x04	; 4
 7de:	41 e0       	ldi	r20, 0x01	; 1
 7e0:	0e 94 5c 00 	call	0xb8	; 0xb8 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_data,5,1);
 7e4:	84 e4       	ldi	r24, 0x44	; 68
 7e6:	65 e0       	ldi	r22, 0x05	; 5
 7e8:	41 e0       	ldi	r20, 0x01	; 1
 7ea:	0e 94 5c 00 	call	0xb8	; 0xb8 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_data,6,1);
 7ee:	84 e4       	ldi	r24, 0x44	; 68
 7f0:	66 e0       	ldi	r22, 0x06	; 6
 7f2:	41 e0       	ldi	r20, 0x01	; 1
 7f4:	0e 94 5c 00 	call	0xb8	; 0xb8 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_data,7,1);
 7f8:	84 e4       	ldi	r24, 0x44	; 68
 7fa:	67 e0       	ldi	r22, 0x07	; 7
 7fc:	41 e0       	ldi	r20, 0x01	; 1
 7fe:	0e 94 5c 00 	call	0xb8	; 0xb8 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_data,2,1);
	DIO_SETPINDIR(port_data,3,1);
	#else
	DIO_SET_DIR_NIPPLE(port_data,start_pin,0xFF);   //write 0 for low nipple ,write  4 for high nipple 
	#endif
	DIO_SETPINDIR(port_control,RS,1);
 802:	84 e4       	ldi	r24, 0x44	; 68
 804:	60 e0       	ldi	r22, 0x00	; 0
 806:	41 e0       	ldi	r20, 0x01	; 1
 808:	0e 94 5c 00 	call	0xb8	; 0xb8 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_control,EN,1);
 80c:	84 e4       	ldi	r24, 0x44	; 68
 80e:	62 e0       	ldi	r22, 0x02	; 2
 810:	41 e0       	ldi	r20, 0x01	; 1
 812:	0e 94 5c 00 	call	0xb8	; 0xb8 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_control,R_W,1);
 816:	84 e4       	ldi	r24, 0x44	; 68
 818:	61 e0       	ldi	r22, 0x01	; 1
 81a:	41 e0       	ldi	r20, 0x01	; 1
 81c:	0e 94 5c 00 	call	0xb8	; 0xb8 <DIO_SETPINDIR>
	DIO_WRITE(port_control,R_W,0);
 820:	84 e4       	ldi	r24, 0x44	; 68
 822:	61 e0       	ldi	r22, 0x01	; 1
 824:	40 e0       	ldi	r20, 0x00	; 0
 826:	0e 94 f7 00 	call	0x1ee	; 0x1ee <DIO_WRITE>
	LCD_Return_home();
 82a:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <LCD_Return_home>
	LCD_SEND_CMD(four_bit);
 82e:	88 e2       	ldi	r24, 0x28	; 40
 830:	0e 94 a1 03 	call	0x742	; 0x742 <LCD_SEND_CMD>
	LCD_SEND_CMD(Display_on_Cursor_off);
 834:	8c e0       	ldi	r24, 0x0C	; 12
 836:	0e 94 a1 03 	call	0x742	; 0x742 <LCD_SEND_CMD>
	LCD_CLEAR_SCREEN();
 83a:	0e 94 da 03 	call	0x7b4	; 0x7b4 <LCD_CLEAR_SCREEN>
	LCD_SEND_CMD(Entry_Mode);
 83e:	86 e0       	ldi	r24, 0x06	; 6
 840:	0e 94 a1 03 	call	0x742	; 0x742 <LCD_SEND_CMD>
	#endif	
}
 844:	08 95       	ret

00000846 <LCD_SEND_CHAR>:

void LCD_SEND_CHAR (unsigned char data)
{
 846:	cf 93       	push	r28
 848:	c8 2f       	mov	r28, r24
	DIO_write_port(port_data,data);
	DIO_WRITE(port_control,RS,1);
	enable();
	#else 
	#ifdef HIGH_NIPPLE
	DIO_WRITE(port_control,RS,1);
 84a:	84 e4       	ldi	r24, 0x44	; 68
 84c:	60 e0       	ldi	r22, 0x00	; 0
 84e:	41 e0       	ldi	r20, 0x01	; 1
 850:	0e 94 f7 00 	call	0x1ee	; 0x1ee <DIO_WRITE>
	DIO_WRITE_HIGH_NIBBLE(port_data,data>>4);
 854:	6c 2f       	mov	r22, r28
 856:	62 95       	swap	r22
 858:	6f 70       	andi	r22, 0x0F	; 15
 85a:	84 e4       	ldi	r24, 0x44	; 68
 85c:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <DIO_WRITE_HIGH_NIBBLE>
	enable();
 860:	0e 94 8a 03 	call	0x714	; 0x714 <enable>
	DIO_WRITE_HIGH_NIBBLE(port_data,data);
 864:	84 e4       	ldi	r24, 0x44	; 68
 866:	6c 2f       	mov	r22, r28
 868:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <DIO_WRITE_HIGH_NIBBLE>
	enable();
 86c:	0e 94 8a 03 	call	0x714	; 0x714 <enable>
	DIO_WRITE_NIBBLE(port_data,start_pin,data);
	enable();
	#endif
		
	#endif
}
 870:	cf 91       	pop	r28
 872:	08 95       	ret

00000874 <LCD_SEND_STRING>:
	}
	LCD_SEND_CMD(cmd);
}

void LCD_SEND_STRING (const char* ptr)
{
 874:	cf 93       	push	r28
 876:	df 93       	push	r29
 878:	ec 01       	movw	r28, r24
	while((*ptr) != '\0')
 87a:	88 81       	ld	r24, Y
 87c:	88 23       	and	r24, r24
 87e:	61 f0       	breq	.+24     	; 0x898 <LCD_SEND_STRING+0x24>
		cmd=0XC0+column-1;
	}
	LCD_SEND_CMD(cmd);
}

void LCD_SEND_STRING (const char* ptr)
 880:	21 96       	adiw	r28, 0x01	; 1
{
	while((*ptr) != '\0')
	{
		LCD_SEND_CHAR(*ptr);
 882:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
 886:	8f ec       	ldi	r24, 0xCF	; 207
 888:	97 e0       	ldi	r25, 0x07	; 7
 88a:	01 97       	sbiw	r24, 0x01	; 1
 88c:	f1 f7       	brne	.-4      	; 0x88a <LCD_SEND_STRING+0x16>
 88e:	00 c0       	rjmp	.+0      	; 0x890 <LCD_SEND_STRING+0x1c>
 890:	00 00       	nop
	LCD_SEND_CMD(cmd);
}

void LCD_SEND_STRING (const char* ptr)
{
	while((*ptr) != '\0')
 892:	89 91       	ld	r24, Y+
 894:	88 23       	and	r24, r24
 896:	a9 f7       	brne	.-22     	; 0x882 <LCD_SEND_STRING+0xe>
	{
		LCD_SEND_CHAR(*ptr);
		ptr++;
		_delay_ms(1);
	}
}	
 898:	df 91       	pop	r29
 89a:	cf 91       	pop	r28
 89c:	08 95       	ret

0000089e <main>:
#include "LCD.h"
#include "ADC.h"
int main(void)
{
	unsigned short temperature,voltage;
	LCD_INIT();
 89e:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <LCD_INIT>
	ADC_INIT();
 8a2:	0e 94 49 00 	call	0x92	; 0x92 <ADC_INIT>
	LCD_SEND_STRING("Temperature=");
 8a6:	80 e6       	ldi	r24, 0x60	; 96
 8a8:	90 e0       	ldi	r25, 0x00	; 0
 8aa:	0e 94 3a 04 	call	0x874	; 0x874 <LCD_SEND_STRING>
    while(1)
    {
		voltage=2.5*ADC_READ();
		if((voltage-1000.0) >= 0)    //voltage - offset added
		{
			temperature=(voltage-1000)/10;
 8ae:	0f 2e       	mov	r0, r31
 8b0:	fa e0       	ldi	r31, 0x0A	; 10
 8b2:	ef 2e       	mov	r14, r31
 8b4:	ff 24       	eor	r15, r15
 8b6:	f0 2d       	mov	r31, r0
				LCD_SEND_CHAR((temperature/10)+48);
				LCD_SEND_CHAR((temperature%10)+48);
			}
			else
			{
				LCD_SEND_CHAR((temperature/100)+48);
 8b8:	0f 2e       	mov	r0, r31
 8ba:	f4 e6       	ldi	r31, 0x64	; 100
 8bc:	af 2e       	mov	r10, r31
 8be:	bb 24       	eor	r11, r11
 8c0:	f0 2d       	mov	r31, r0
			LCD_SEND_CHAR('C');
			LCD_SEND_CHAR(0X20);	
		}			
		else
		{
			temperature=(1000-voltage)/10;
 8c2:	0f 2e       	mov	r0, r31
 8c4:	f8 ee       	ldi	r31, 0xE8	; 232
 8c6:	cf 2e       	mov	r12, r31
 8c8:	f3 e0       	ldi	r31, 0x03	; 3
 8ca:	df 2e       	mov	r13, r31
 8cc:	f0 2d       	mov	r31, r0
	LCD_INIT();
	ADC_INIT();
	LCD_SEND_STRING("Temperature=");
    while(1)
    {
		voltage=2.5*ADC_READ();
 8ce:	0e 94 50 00 	call	0xa0	; 0xa0 <ADC_READ>
 8d2:	bc 01       	movw	r22, r24
 8d4:	80 e0       	ldi	r24, 0x00	; 0
 8d6:	90 e0       	ldi	r25, 0x00	; 0
 8d8:	0e 94 97 05 	call	0xb2e	; 0xb2e <__floatunsisf>
 8dc:	20 e0       	ldi	r18, 0x00	; 0
 8de:	30 e0       	ldi	r19, 0x00	; 0
 8e0:	40 e2       	ldi	r20, 0x20	; 32
 8e2:	50 e4       	ldi	r21, 0x40	; 64
 8e4:	0e 94 29 06 	call	0xc52	; 0xc52 <__mulsf3>
 8e8:	0e 94 6b 05 	call	0xad6	; 0xad6 <__fixunssfsi>
 8ec:	dc 01       	movw	r26, r24
 8ee:	cb 01       	movw	r24, r22
 8f0:	ec 01       	movw	r28, r24
		if((voltage-1000.0) >= 0)    //voltage - offset added
 8f2:	bc 01       	movw	r22, r24
 8f4:	80 e0       	ldi	r24, 0x00	; 0
 8f6:	90 e0       	ldi	r25, 0x00	; 0
 8f8:	0e 94 97 05 	call	0xb2e	; 0xb2e <__floatunsisf>
 8fc:	20 e0       	ldi	r18, 0x00	; 0
 8fe:	30 e0       	ldi	r19, 0x00	; 0
 900:	4a e7       	ldi	r20, 0x7A	; 122
 902:	54 e4       	ldi	r21, 0x44	; 68
 904:	0e 94 06 05 	call	0xa0c	; 0xa0c <__subsf3>
 908:	20 e0       	ldi	r18, 0x00	; 0
 90a:	30 e0       	ldi	r19, 0x00	; 0
 90c:	a9 01       	movw	r20, r18
 90e:	0e 94 25 06 	call	0xc4a	; 0xc4a <__gesf2>
 912:	88 23       	and	r24, r24
 914:	0c f4       	brge	.+2      	; 0x918 <main+0x7a>
 916:	48 c0       	rjmp	.+144    	; 0x9a8 <main+0x10a>
		{
			temperature=(voltage-1000)/10;
 918:	ce 01       	movw	r24, r28
 91a:	88 5e       	subi	r24, 0xE8	; 232
 91c:	93 40       	sbci	r25, 0x03	; 3
 91e:	b7 01       	movw	r22, r14
 920:	0e 94 b0 06 	call	0xd60	; 0xd60 <__udivmodhi4>
 924:	c6 2f       	mov	r28, r22
 926:	06 2f       	mov	r16, r22
 928:	17 2f       	mov	r17, r23
			lCD_MOVE_CURSOR(1,13);
 92a:	81 e0       	ldi	r24, 0x01	; 1
 92c:	6d e0       	ldi	r22, 0x0D	; 13
 92e:	0e 94 b8 03 	call	0x770	; 0x770 <lCD_MOVE_CURSOR>
			if(temperature < 10)
 932:	0a 30       	cpi	r16, 0x0A	; 10
 934:	11 05       	cpc	r17, r1
 936:	28 f4       	brcc	.+10     	; 0x942 <main+0xa4>
			{
				LCD_SEND_CHAR(temperature+48);
 938:	8c 2f       	mov	r24, r28
 93a:	80 5d       	subi	r24, 0xD0	; 208
 93c:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
 940:	29 c0       	rjmp	.+82     	; 0x994 <main+0xf6>
			}
			else if(temperature < 100 )
 942:	04 36       	cpi	r16, 0x64	; 100
 944:	11 05       	cpc	r17, r1
 946:	70 f4       	brcc	.+28     	; 0x964 <main+0xc6>
			{
				LCD_SEND_CHAR((temperature/10)+48);
 948:	c8 01       	movw	r24, r16
 94a:	b7 01       	movw	r22, r14
 94c:	0e 94 b0 06 	call	0xd60	; 0xd60 <__udivmodhi4>
 950:	c8 2f       	mov	r28, r24
 952:	86 2f       	mov	r24, r22
 954:	80 5d       	subi	r24, 0xD0	; 208
 956:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
				LCD_SEND_CHAR((temperature%10)+48);
 95a:	8c 2f       	mov	r24, r28
 95c:	80 5d       	subi	r24, 0xD0	; 208
 95e:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
 962:	18 c0       	rjmp	.+48     	; 0x994 <main+0xf6>
			}
			else
			{
				LCD_SEND_CHAR((temperature/100)+48);
 964:	c8 01       	movw	r24, r16
 966:	b5 01       	movw	r22, r10
 968:	0e 94 b0 06 	call	0xd60	; 0xd60 <__udivmodhi4>
 96c:	86 2f       	mov	r24, r22
 96e:	80 5d       	subi	r24, 0xD0	; 208
 970:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
				LCD_SEND_CHAR(((temperature/10)%10)+48);
 974:	c8 01       	movw	r24, r16
 976:	b7 01       	movw	r22, r14
 978:	0e 94 b0 06 	call	0xd60	; 0xd60 <__udivmodhi4>
 97c:	c8 2f       	mov	r28, r24
 97e:	cb 01       	movw	r24, r22
 980:	b7 01       	movw	r22, r14
 982:	0e 94 b0 06 	call	0xd60	; 0xd60 <__udivmodhi4>
 986:	80 5d       	subi	r24, 0xD0	; 208
 988:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
				LCD_SEND_CHAR((temperature%10)+48);
 98c:	8c 2f       	mov	r24, r28
 98e:	80 5d       	subi	r24, 0xD0	; 208
 990:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
			}
			LCD_SEND_CHAR(0XDF);   // to write a degree on LCD
 994:	8f ed       	ldi	r24, 0xDF	; 223
 996:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
			LCD_SEND_CHAR('C');
 99a:	83 e4       	ldi	r24, 0x43	; 67
 99c:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
			LCD_SEND_CHAR(0X20);	
 9a0:	80 e2       	ldi	r24, 0x20	; 32
 9a2:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
 9a6:	93 cf       	rjmp	.-218    	; 0x8ce <main+0x30>
		}			
		else
		{
			temperature=(1000-voltage)/10;
 9a8:	c6 01       	movw	r24, r12
 9aa:	8c 1b       	sub	r24, r28
 9ac:	9d 0b       	sbc	r25, r29
 9ae:	b7 01       	movw	r22, r14
 9b0:	0e 94 b0 06 	call	0xd60	; 0xd60 <__udivmodhi4>
 9b4:	16 2f       	mov	r17, r22
 9b6:	c6 2f       	mov	r28, r22
 9b8:	d7 2f       	mov	r29, r23
			lCD_MOVE_CURSOR(1,13);
 9ba:	81 e0       	ldi	r24, 0x01	; 1
 9bc:	6d e0       	ldi	r22, 0x0D	; 13
 9be:	0e 94 b8 03 	call	0x770	; 0x770 <lCD_MOVE_CURSOR>
			LCD_SEND_CHAR('-');
 9c2:	8d e2       	ldi	r24, 0x2D	; 45
 9c4:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
			if(temperature < 10)
 9c8:	ca 30       	cpi	r28, 0x0A	; 10
 9ca:	d1 05       	cpc	r29, r1
 9cc:	28 f4       	brcc	.+10     	; 0x9d8 <main+0x13a>
			{
				LCD_SEND_CHAR(temperature+48);
 9ce:	81 2f       	mov	r24, r17
 9d0:	80 5d       	subi	r24, 0xD0	; 208
 9d2:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
 9d6:	10 c0       	rjmp	.+32     	; 0x9f8 <main+0x15a>
			}
			else if(temperature < 100 )
 9d8:	c4 36       	cpi	r28, 0x64	; 100
 9da:	d1 05       	cpc	r29, r1
 9dc:	68 f4       	brcc	.+26     	; 0x9f8 <main+0x15a>
			{
				LCD_SEND_CHAR((temperature/10)+48);
 9de:	ce 01       	movw	r24, r28
 9e0:	b7 01       	movw	r22, r14
 9e2:	0e 94 b0 06 	call	0xd60	; 0xd60 <__udivmodhi4>
 9e6:	c8 2f       	mov	r28, r24
 9e8:	86 2f       	mov	r24, r22
 9ea:	80 5d       	subi	r24, 0xD0	; 208
 9ec:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
				LCD_SEND_CHAR((temperature%10)+48);
 9f0:	8c 2f       	mov	r24, r28
 9f2:	80 5d       	subi	r24, 0xD0	; 208
 9f4:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
			}
			LCD_SEND_CHAR(0XDF);   // to write a degree on LCD
 9f8:	8f ed       	ldi	r24, 0xDF	; 223
 9fa:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
			LCD_SEND_CHAR('C');
 9fe:	83 e4       	ldi	r24, 0x43	; 67
 a00:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
			LCD_SEND_CHAR(0X20);	
 a04:	80 e2       	ldi	r24, 0x20	; 32
 a06:	0e 94 23 04 	call	0x846	; 0x846 <LCD_SEND_CHAR>
 a0a:	61 cf       	rjmp	.-318    	; 0x8ce <main+0x30>

00000a0c <__subsf3>:
 a0c:	50 58       	subi	r21, 0x80	; 128

00000a0e <__addsf3>:
 a0e:	bb 27       	eor	r27, r27
 a10:	aa 27       	eor	r26, r26
 a12:	0e d0       	rcall	.+28     	; 0xa30 <__addsf3x>
 a14:	e0 c0       	rjmp	.+448    	; 0xbd6 <__fp_round>
 a16:	d1 d0       	rcall	.+418    	; 0xbba <__fp_pscA>
 a18:	30 f0       	brcs	.+12     	; 0xa26 <__addsf3+0x18>
 a1a:	d6 d0       	rcall	.+428    	; 0xbc8 <__fp_pscB>
 a1c:	20 f0       	brcs	.+8      	; 0xa26 <__addsf3+0x18>
 a1e:	31 f4       	brne	.+12     	; 0xa2c <__addsf3+0x1e>
 a20:	9f 3f       	cpi	r25, 0xFF	; 255
 a22:	11 f4       	brne	.+4      	; 0xa28 <__addsf3+0x1a>
 a24:	1e f4       	brtc	.+6      	; 0xa2c <__addsf3+0x1e>
 a26:	c6 c0       	rjmp	.+396    	; 0xbb4 <__fp_nan>
 a28:	0e f4       	brtc	.+2      	; 0xa2c <__addsf3+0x1e>
 a2a:	e0 95       	com	r30
 a2c:	e7 fb       	bst	r30, 7
 a2e:	bc c0       	rjmp	.+376    	; 0xba8 <__fp_inf>

00000a30 <__addsf3x>:
 a30:	e9 2f       	mov	r30, r25
 a32:	e2 d0       	rcall	.+452    	; 0xbf8 <__fp_split3>
 a34:	80 f3       	brcs	.-32     	; 0xa16 <__addsf3+0x8>
 a36:	ba 17       	cp	r27, r26
 a38:	62 07       	cpc	r22, r18
 a3a:	73 07       	cpc	r23, r19
 a3c:	84 07       	cpc	r24, r20
 a3e:	95 07       	cpc	r25, r21
 a40:	18 f0       	brcs	.+6      	; 0xa48 <__addsf3x+0x18>
 a42:	71 f4       	brne	.+28     	; 0xa60 <__addsf3x+0x30>
 a44:	9e f5       	brtc	.+102    	; 0xaac <__addsf3x+0x7c>
 a46:	fa c0       	rjmp	.+500    	; 0xc3c <__fp_zero>
 a48:	0e f4       	brtc	.+2      	; 0xa4c <__addsf3x+0x1c>
 a4a:	e0 95       	com	r30
 a4c:	0b 2e       	mov	r0, r27
 a4e:	ba 2f       	mov	r27, r26
 a50:	a0 2d       	mov	r26, r0
 a52:	0b 01       	movw	r0, r22
 a54:	b9 01       	movw	r22, r18
 a56:	90 01       	movw	r18, r0
 a58:	0c 01       	movw	r0, r24
 a5a:	ca 01       	movw	r24, r20
 a5c:	a0 01       	movw	r20, r0
 a5e:	11 24       	eor	r1, r1
 a60:	ff 27       	eor	r31, r31
 a62:	59 1b       	sub	r21, r25
 a64:	99 f0       	breq	.+38     	; 0xa8c <__addsf3x+0x5c>
 a66:	59 3f       	cpi	r21, 0xF9	; 249
 a68:	50 f4       	brcc	.+20     	; 0xa7e <__addsf3x+0x4e>
 a6a:	50 3e       	cpi	r21, 0xE0	; 224
 a6c:	68 f1       	brcs	.+90     	; 0xac8 <__addsf3x+0x98>
 a6e:	1a 16       	cp	r1, r26
 a70:	f0 40       	sbci	r31, 0x00	; 0
 a72:	a2 2f       	mov	r26, r18
 a74:	23 2f       	mov	r18, r19
 a76:	34 2f       	mov	r19, r20
 a78:	44 27       	eor	r20, r20
 a7a:	58 5f       	subi	r21, 0xF8	; 248
 a7c:	f3 cf       	rjmp	.-26     	; 0xa64 <__addsf3x+0x34>
 a7e:	46 95       	lsr	r20
 a80:	37 95       	ror	r19
 a82:	27 95       	ror	r18
 a84:	a7 95       	ror	r26
 a86:	f0 40       	sbci	r31, 0x00	; 0
 a88:	53 95       	inc	r21
 a8a:	c9 f7       	brne	.-14     	; 0xa7e <__addsf3x+0x4e>
 a8c:	7e f4       	brtc	.+30     	; 0xaac <__addsf3x+0x7c>
 a8e:	1f 16       	cp	r1, r31
 a90:	ba 0b       	sbc	r27, r26
 a92:	62 0b       	sbc	r22, r18
 a94:	73 0b       	sbc	r23, r19
 a96:	84 0b       	sbc	r24, r20
 a98:	ba f0       	brmi	.+46     	; 0xac8 <__addsf3x+0x98>
 a9a:	91 50       	subi	r25, 0x01	; 1
 a9c:	a1 f0       	breq	.+40     	; 0xac6 <__addsf3x+0x96>
 a9e:	ff 0f       	add	r31, r31
 aa0:	bb 1f       	adc	r27, r27
 aa2:	66 1f       	adc	r22, r22
 aa4:	77 1f       	adc	r23, r23
 aa6:	88 1f       	adc	r24, r24
 aa8:	c2 f7       	brpl	.-16     	; 0xa9a <__addsf3x+0x6a>
 aaa:	0e c0       	rjmp	.+28     	; 0xac8 <__addsf3x+0x98>
 aac:	ba 0f       	add	r27, r26
 aae:	62 1f       	adc	r22, r18
 ab0:	73 1f       	adc	r23, r19
 ab2:	84 1f       	adc	r24, r20
 ab4:	48 f4       	brcc	.+18     	; 0xac8 <__addsf3x+0x98>
 ab6:	87 95       	ror	r24
 ab8:	77 95       	ror	r23
 aba:	67 95       	ror	r22
 abc:	b7 95       	ror	r27
 abe:	f7 95       	ror	r31
 ac0:	9e 3f       	cpi	r25, 0xFE	; 254
 ac2:	08 f0       	brcs	.+2      	; 0xac6 <__addsf3x+0x96>
 ac4:	b3 cf       	rjmp	.-154    	; 0xa2c <__addsf3+0x1e>
 ac6:	93 95       	inc	r25
 ac8:	88 0f       	add	r24, r24
 aca:	08 f0       	brcs	.+2      	; 0xace <__addsf3x+0x9e>
 acc:	99 27       	eor	r25, r25
 ace:	ee 0f       	add	r30, r30
 ad0:	97 95       	ror	r25
 ad2:	87 95       	ror	r24
 ad4:	08 95       	ret

00000ad6 <__fixunssfsi>:
 ad6:	98 d0       	rcall	.+304    	; 0xc08 <__fp_splitA>
 ad8:	88 f0       	brcs	.+34     	; 0xafc <__fixunssfsi+0x26>
 ada:	9f 57       	subi	r25, 0x7F	; 127
 adc:	90 f0       	brcs	.+36     	; 0xb02 <__fixunssfsi+0x2c>
 ade:	b9 2f       	mov	r27, r25
 ae0:	99 27       	eor	r25, r25
 ae2:	b7 51       	subi	r27, 0x17	; 23
 ae4:	a0 f0       	brcs	.+40     	; 0xb0e <__fixunssfsi+0x38>
 ae6:	d1 f0       	breq	.+52     	; 0xb1c <__fixunssfsi+0x46>
 ae8:	66 0f       	add	r22, r22
 aea:	77 1f       	adc	r23, r23
 aec:	88 1f       	adc	r24, r24
 aee:	99 1f       	adc	r25, r25
 af0:	1a f0       	brmi	.+6      	; 0xaf8 <__fixunssfsi+0x22>
 af2:	ba 95       	dec	r27
 af4:	c9 f7       	brne	.-14     	; 0xae8 <__fixunssfsi+0x12>
 af6:	12 c0       	rjmp	.+36     	; 0xb1c <__fixunssfsi+0x46>
 af8:	b1 30       	cpi	r27, 0x01	; 1
 afa:	81 f0       	breq	.+32     	; 0xb1c <__fixunssfsi+0x46>
 afc:	9f d0       	rcall	.+318    	; 0xc3c <__fp_zero>
 afe:	b1 e0       	ldi	r27, 0x01	; 1
 b00:	08 95       	ret
 b02:	9c c0       	rjmp	.+312    	; 0xc3c <__fp_zero>
 b04:	67 2f       	mov	r22, r23
 b06:	78 2f       	mov	r23, r24
 b08:	88 27       	eor	r24, r24
 b0a:	b8 5f       	subi	r27, 0xF8	; 248
 b0c:	39 f0       	breq	.+14     	; 0xb1c <__fixunssfsi+0x46>
 b0e:	b9 3f       	cpi	r27, 0xF9	; 249
 b10:	cc f3       	brlt	.-14     	; 0xb04 <__fixunssfsi+0x2e>
 b12:	86 95       	lsr	r24
 b14:	77 95       	ror	r23
 b16:	67 95       	ror	r22
 b18:	b3 95       	inc	r27
 b1a:	d9 f7       	brne	.-10     	; 0xb12 <__fixunssfsi+0x3c>
 b1c:	3e f4       	brtc	.+14     	; 0xb2c <__fixunssfsi+0x56>
 b1e:	90 95       	com	r25
 b20:	80 95       	com	r24
 b22:	70 95       	com	r23
 b24:	61 95       	neg	r22
 b26:	7f 4f       	sbci	r23, 0xFF	; 255
 b28:	8f 4f       	sbci	r24, 0xFF	; 255
 b2a:	9f 4f       	sbci	r25, 0xFF	; 255
 b2c:	08 95       	ret

00000b2e <__floatunsisf>:
 b2e:	e8 94       	clt
 b30:	09 c0       	rjmp	.+18     	; 0xb44 <__floatsisf+0x12>

00000b32 <__floatsisf>:
 b32:	97 fb       	bst	r25, 7
 b34:	3e f4       	brtc	.+14     	; 0xb44 <__floatsisf+0x12>
 b36:	90 95       	com	r25
 b38:	80 95       	com	r24
 b3a:	70 95       	com	r23
 b3c:	61 95       	neg	r22
 b3e:	7f 4f       	sbci	r23, 0xFF	; 255
 b40:	8f 4f       	sbci	r24, 0xFF	; 255
 b42:	9f 4f       	sbci	r25, 0xFF	; 255
 b44:	99 23       	and	r25, r25
 b46:	a9 f0       	breq	.+42     	; 0xb72 <__floatsisf+0x40>
 b48:	f9 2f       	mov	r31, r25
 b4a:	96 e9       	ldi	r25, 0x96	; 150
 b4c:	bb 27       	eor	r27, r27
 b4e:	93 95       	inc	r25
 b50:	f6 95       	lsr	r31
 b52:	87 95       	ror	r24
 b54:	77 95       	ror	r23
 b56:	67 95       	ror	r22
 b58:	b7 95       	ror	r27
 b5a:	f1 11       	cpse	r31, r1
 b5c:	f8 cf       	rjmp	.-16     	; 0xb4e <__floatsisf+0x1c>
 b5e:	fa f4       	brpl	.+62     	; 0xb9e <__floatsisf+0x6c>
 b60:	bb 0f       	add	r27, r27
 b62:	11 f4       	brne	.+4      	; 0xb68 <__floatsisf+0x36>
 b64:	60 ff       	sbrs	r22, 0
 b66:	1b c0       	rjmp	.+54     	; 0xb9e <__floatsisf+0x6c>
 b68:	6f 5f       	subi	r22, 0xFF	; 255
 b6a:	7f 4f       	sbci	r23, 0xFF	; 255
 b6c:	8f 4f       	sbci	r24, 0xFF	; 255
 b6e:	9f 4f       	sbci	r25, 0xFF	; 255
 b70:	16 c0       	rjmp	.+44     	; 0xb9e <__floatsisf+0x6c>
 b72:	88 23       	and	r24, r24
 b74:	11 f0       	breq	.+4      	; 0xb7a <__floatsisf+0x48>
 b76:	96 e9       	ldi	r25, 0x96	; 150
 b78:	11 c0       	rjmp	.+34     	; 0xb9c <__floatsisf+0x6a>
 b7a:	77 23       	and	r23, r23
 b7c:	21 f0       	breq	.+8      	; 0xb86 <__floatsisf+0x54>
 b7e:	9e e8       	ldi	r25, 0x8E	; 142
 b80:	87 2f       	mov	r24, r23
 b82:	76 2f       	mov	r23, r22
 b84:	05 c0       	rjmp	.+10     	; 0xb90 <__floatsisf+0x5e>
 b86:	66 23       	and	r22, r22
 b88:	71 f0       	breq	.+28     	; 0xba6 <__floatsisf+0x74>
 b8a:	96 e8       	ldi	r25, 0x86	; 134
 b8c:	86 2f       	mov	r24, r22
 b8e:	70 e0       	ldi	r23, 0x00	; 0
 b90:	60 e0       	ldi	r22, 0x00	; 0
 b92:	2a f0       	brmi	.+10     	; 0xb9e <__floatsisf+0x6c>
 b94:	9a 95       	dec	r25
 b96:	66 0f       	add	r22, r22
 b98:	77 1f       	adc	r23, r23
 b9a:	88 1f       	adc	r24, r24
 b9c:	da f7       	brpl	.-10     	; 0xb94 <__floatsisf+0x62>
 b9e:	88 0f       	add	r24, r24
 ba0:	96 95       	lsr	r25
 ba2:	87 95       	ror	r24
 ba4:	97 f9       	bld	r25, 7
 ba6:	08 95       	ret

00000ba8 <__fp_inf>:
 ba8:	97 f9       	bld	r25, 7
 baa:	9f 67       	ori	r25, 0x7F	; 127
 bac:	80 e8       	ldi	r24, 0x80	; 128
 bae:	70 e0       	ldi	r23, 0x00	; 0
 bb0:	60 e0       	ldi	r22, 0x00	; 0
 bb2:	08 95       	ret

00000bb4 <__fp_nan>:
 bb4:	9f ef       	ldi	r25, 0xFF	; 255
 bb6:	80 ec       	ldi	r24, 0xC0	; 192
 bb8:	08 95       	ret

00000bba <__fp_pscA>:
 bba:	00 24       	eor	r0, r0
 bbc:	0a 94       	dec	r0
 bbe:	16 16       	cp	r1, r22
 bc0:	17 06       	cpc	r1, r23
 bc2:	18 06       	cpc	r1, r24
 bc4:	09 06       	cpc	r0, r25
 bc6:	08 95       	ret

00000bc8 <__fp_pscB>:
 bc8:	00 24       	eor	r0, r0
 bca:	0a 94       	dec	r0
 bcc:	12 16       	cp	r1, r18
 bce:	13 06       	cpc	r1, r19
 bd0:	14 06       	cpc	r1, r20
 bd2:	05 06       	cpc	r0, r21
 bd4:	08 95       	ret

00000bd6 <__fp_round>:
 bd6:	09 2e       	mov	r0, r25
 bd8:	03 94       	inc	r0
 bda:	00 0c       	add	r0, r0
 bdc:	11 f4       	brne	.+4      	; 0xbe2 <__fp_round+0xc>
 bde:	88 23       	and	r24, r24
 be0:	52 f0       	brmi	.+20     	; 0xbf6 <__fp_round+0x20>
 be2:	bb 0f       	add	r27, r27
 be4:	40 f4       	brcc	.+16     	; 0xbf6 <__fp_round+0x20>
 be6:	bf 2b       	or	r27, r31
 be8:	11 f4       	brne	.+4      	; 0xbee <__fp_round+0x18>
 bea:	60 ff       	sbrs	r22, 0
 bec:	04 c0       	rjmp	.+8      	; 0xbf6 <__fp_round+0x20>
 bee:	6f 5f       	subi	r22, 0xFF	; 255
 bf0:	7f 4f       	sbci	r23, 0xFF	; 255
 bf2:	8f 4f       	sbci	r24, 0xFF	; 255
 bf4:	9f 4f       	sbci	r25, 0xFF	; 255
 bf6:	08 95       	ret

00000bf8 <__fp_split3>:
 bf8:	57 fd       	sbrc	r21, 7
 bfa:	90 58       	subi	r25, 0x80	; 128
 bfc:	44 0f       	add	r20, r20
 bfe:	55 1f       	adc	r21, r21
 c00:	59 f0       	breq	.+22     	; 0xc18 <__fp_splitA+0x10>
 c02:	5f 3f       	cpi	r21, 0xFF	; 255
 c04:	71 f0       	breq	.+28     	; 0xc22 <__fp_splitA+0x1a>
 c06:	47 95       	ror	r20

00000c08 <__fp_splitA>:
 c08:	88 0f       	add	r24, r24
 c0a:	97 fb       	bst	r25, 7
 c0c:	99 1f       	adc	r25, r25
 c0e:	61 f0       	breq	.+24     	; 0xc28 <__fp_splitA+0x20>
 c10:	9f 3f       	cpi	r25, 0xFF	; 255
 c12:	79 f0       	breq	.+30     	; 0xc32 <__fp_splitA+0x2a>
 c14:	87 95       	ror	r24
 c16:	08 95       	ret
 c18:	12 16       	cp	r1, r18
 c1a:	13 06       	cpc	r1, r19
 c1c:	14 06       	cpc	r1, r20
 c1e:	55 1f       	adc	r21, r21
 c20:	f2 cf       	rjmp	.-28     	; 0xc06 <__fp_split3+0xe>
 c22:	46 95       	lsr	r20
 c24:	f1 df       	rcall	.-30     	; 0xc08 <__fp_splitA>
 c26:	08 c0       	rjmp	.+16     	; 0xc38 <__fp_splitA+0x30>
 c28:	16 16       	cp	r1, r22
 c2a:	17 06       	cpc	r1, r23
 c2c:	18 06       	cpc	r1, r24
 c2e:	99 1f       	adc	r25, r25
 c30:	f1 cf       	rjmp	.-30     	; 0xc14 <__fp_splitA+0xc>
 c32:	86 95       	lsr	r24
 c34:	71 05       	cpc	r23, r1
 c36:	61 05       	cpc	r22, r1
 c38:	08 94       	sec
 c3a:	08 95       	ret

00000c3c <__fp_zero>:
 c3c:	e8 94       	clt

00000c3e <__fp_szero>:
 c3e:	bb 27       	eor	r27, r27
 c40:	66 27       	eor	r22, r22
 c42:	77 27       	eor	r23, r23
 c44:	cb 01       	movw	r24, r22
 c46:	97 f9       	bld	r25, 7
 c48:	08 95       	ret

00000c4a <__gesf2>:
 c4a:	66 d0       	rcall	.+204    	; 0xd18 <__fp_cmp>
 c4c:	08 f4       	brcc	.+2      	; 0xc50 <__gesf2+0x6>
 c4e:	8f ef       	ldi	r24, 0xFF	; 255
 c50:	08 95       	ret

00000c52 <__mulsf3>:
 c52:	0b d0       	rcall	.+22     	; 0xc6a <__mulsf3x>
 c54:	c0 cf       	rjmp	.-128    	; 0xbd6 <__fp_round>
 c56:	b1 df       	rcall	.-158    	; 0xbba <__fp_pscA>
 c58:	28 f0       	brcs	.+10     	; 0xc64 <__mulsf3+0x12>
 c5a:	b6 df       	rcall	.-148    	; 0xbc8 <__fp_pscB>
 c5c:	18 f0       	brcs	.+6      	; 0xc64 <__mulsf3+0x12>
 c5e:	95 23       	and	r25, r21
 c60:	09 f0       	breq	.+2      	; 0xc64 <__mulsf3+0x12>
 c62:	a2 cf       	rjmp	.-188    	; 0xba8 <__fp_inf>
 c64:	a7 cf       	rjmp	.-178    	; 0xbb4 <__fp_nan>
 c66:	11 24       	eor	r1, r1
 c68:	ea cf       	rjmp	.-44     	; 0xc3e <__fp_szero>

00000c6a <__mulsf3x>:
 c6a:	c6 df       	rcall	.-116    	; 0xbf8 <__fp_split3>
 c6c:	a0 f3       	brcs	.-24     	; 0xc56 <__mulsf3+0x4>

00000c6e <__mulsf3_pse>:
 c6e:	95 9f       	mul	r25, r21
 c70:	d1 f3       	breq	.-12     	; 0xc66 <__mulsf3+0x14>
 c72:	95 0f       	add	r25, r21
 c74:	50 e0       	ldi	r21, 0x00	; 0
 c76:	55 1f       	adc	r21, r21
 c78:	62 9f       	mul	r22, r18
 c7a:	f0 01       	movw	r30, r0
 c7c:	72 9f       	mul	r23, r18
 c7e:	bb 27       	eor	r27, r27
 c80:	f0 0d       	add	r31, r0
 c82:	b1 1d       	adc	r27, r1
 c84:	63 9f       	mul	r22, r19
 c86:	aa 27       	eor	r26, r26
 c88:	f0 0d       	add	r31, r0
 c8a:	b1 1d       	adc	r27, r1
 c8c:	aa 1f       	adc	r26, r26
 c8e:	64 9f       	mul	r22, r20
 c90:	66 27       	eor	r22, r22
 c92:	b0 0d       	add	r27, r0
 c94:	a1 1d       	adc	r26, r1
 c96:	66 1f       	adc	r22, r22
 c98:	82 9f       	mul	r24, r18
 c9a:	22 27       	eor	r18, r18
 c9c:	b0 0d       	add	r27, r0
 c9e:	a1 1d       	adc	r26, r1
 ca0:	62 1f       	adc	r22, r18
 ca2:	73 9f       	mul	r23, r19
 ca4:	b0 0d       	add	r27, r0
 ca6:	a1 1d       	adc	r26, r1
 ca8:	62 1f       	adc	r22, r18
 caa:	83 9f       	mul	r24, r19
 cac:	a0 0d       	add	r26, r0
 cae:	61 1d       	adc	r22, r1
 cb0:	22 1f       	adc	r18, r18
 cb2:	74 9f       	mul	r23, r20
 cb4:	33 27       	eor	r19, r19
 cb6:	a0 0d       	add	r26, r0
 cb8:	61 1d       	adc	r22, r1
 cba:	23 1f       	adc	r18, r19
 cbc:	84 9f       	mul	r24, r20
 cbe:	60 0d       	add	r22, r0
 cc0:	21 1d       	adc	r18, r1
 cc2:	82 2f       	mov	r24, r18
 cc4:	76 2f       	mov	r23, r22
 cc6:	6a 2f       	mov	r22, r26
 cc8:	11 24       	eor	r1, r1
 cca:	9f 57       	subi	r25, 0x7F	; 127
 ccc:	50 40       	sbci	r21, 0x00	; 0
 cce:	8a f0       	brmi	.+34     	; 0xcf2 <__mulsf3_pse+0x84>
 cd0:	e1 f0       	breq	.+56     	; 0xd0a <__mulsf3_pse+0x9c>
 cd2:	88 23       	and	r24, r24
 cd4:	4a f0       	brmi	.+18     	; 0xce8 <__mulsf3_pse+0x7a>
 cd6:	ee 0f       	add	r30, r30
 cd8:	ff 1f       	adc	r31, r31
 cda:	bb 1f       	adc	r27, r27
 cdc:	66 1f       	adc	r22, r22
 cde:	77 1f       	adc	r23, r23
 ce0:	88 1f       	adc	r24, r24
 ce2:	91 50       	subi	r25, 0x01	; 1
 ce4:	50 40       	sbci	r21, 0x00	; 0
 ce6:	a9 f7       	brne	.-22     	; 0xcd2 <__mulsf3_pse+0x64>
 ce8:	9e 3f       	cpi	r25, 0xFE	; 254
 cea:	51 05       	cpc	r21, r1
 cec:	70 f0       	brcs	.+28     	; 0xd0a <__mulsf3_pse+0x9c>
 cee:	5c cf       	rjmp	.-328    	; 0xba8 <__fp_inf>
 cf0:	a6 cf       	rjmp	.-180    	; 0xc3e <__fp_szero>
 cf2:	5f 3f       	cpi	r21, 0xFF	; 255
 cf4:	ec f3       	brlt	.-6      	; 0xcf0 <__mulsf3_pse+0x82>
 cf6:	98 3e       	cpi	r25, 0xE8	; 232
 cf8:	dc f3       	brlt	.-10     	; 0xcf0 <__mulsf3_pse+0x82>
 cfa:	86 95       	lsr	r24
 cfc:	77 95       	ror	r23
 cfe:	67 95       	ror	r22
 d00:	b7 95       	ror	r27
 d02:	f7 95       	ror	r31
 d04:	e7 95       	ror	r30
 d06:	9f 5f       	subi	r25, 0xFF	; 255
 d08:	c1 f7       	brne	.-16     	; 0xcfa <__mulsf3_pse+0x8c>
 d0a:	fe 2b       	or	r31, r30
 d0c:	88 0f       	add	r24, r24
 d0e:	91 1d       	adc	r25, r1
 d10:	96 95       	lsr	r25
 d12:	87 95       	ror	r24
 d14:	97 f9       	bld	r25, 7
 d16:	08 95       	ret

00000d18 <__fp_cmp>:
 d18:	99 0f       	add	r25, r25
 d1a:	00 08       	sbc	r0, r0
 d1c:	55 0f       	add	r21, r21
 d1e:	aa 0b       	sbc	r26, r26
 d20:	e0 e8       	ldi	r30, 0x80	; 128
 d22:	fe ef       	ldi	r31, 0xFE	; 254
 d24:	16 16       	cp	r1, r22
 d26:	17 06       	cpc	r1, r23
 d28:	e8 07       	cpc	r30, r24
 d2a:	f9 07       	cpc	r31, r25
 d2c:	c0 f0       	brcs	.+48     	; 0xd5e <__fp_cmp+0x46>
 d2e:	12 16       	cp	r1, r18
 d30:	13 06       	cpc	r1, r19
 d32:	e4 07       	cpc	r30, r20
 d34:	f5 07       	cpc	r31, r21
 d36:	98 f0       	brcs	.+38     	; 0xd5e <__fp_cmp+0x46>
 d38:	62 1b       	sub	r22, r18
 d3a:	73 0b       	sbc	r23, r19
 d3c:	84 0b       	sbc	r24, r20
 d3e:	95 0b       	sbc	r25, r21
 d40:	39 f4       	brne	.+14     	; 0xd50 <__fp_cmp+0x38>
 d42:	0a 26       	eor	r0, r26
 d44:	61 f0       	breq	.+24     	; 0xd5e <__fp_cmp+0x46>
 d46:	23 2b       	or	r18, r19
 d48:	24 2b       	or	r18, r20
 d4a:	25 2b       	or	r18, r21
 d4c:	21 f4       	brne	.+8      	; 0xd56 <__fp_cmp+0x3e>
 d4e:	08 95       	ret
 d50:	0a 26       	eor	r0, r26
 d52:	09 f4       	brne	.+2      	; 0xd56 <__fp_cmp+0x3e>
 d54:	a1 40       	sbci	r26, 0x01	; 1
 d56:	a6 95       	lsr	r26
 d58:	8f ef       	ldi	r24, 0xFF	; 255
 d5a:	81 1d       	adc	r24, r1
 d5c:	81 1d       	adc	r24, r1
 d5e:	08 95       	ret

00000d60 <__udivmodhi4>:
 d60:	aa 1b       	sub	r26, r26
 d62:	bb 1b       	sub	r27, r27
 d64:	51 e1       	ldi	r21, 0x11	; 17
 d66:	07 c0       	rjmp	.+14     	; 0xd76 <__udivmodhi4_ep>

00000d68 <__udivmodhi4_loop>:
 d68:	aa 1f       	adc	r26, r26
 d6a:	bb 1f       	adc	r27, r27
 d6c:	a6 17       	cp	r26, r22
 d6e:	b7 07       	cpc	r27, r23
 d70:	10 f0       	brcs	.+4      	; 0xd76 <__udivmodhi4_ep>
 d72:	a6 1b       	sub	r26, r22
 d74:	b7 0b       	sbc	r27, r23

00000d76 <__udivmodhi4_ep>:
 d76:	88 1f       	adc	r24, r24
 d78:	99 1f       	adc	r25, r25
 d7a:	5a 95       	dec	r21
 d7c:	a9 f7       	brne	.-22     	; 0xd68 <__udivmodhi4_loop>
 d7e:	80 95       	com	r24
 d80:	90 95       	com	r25
 d82:	bc 01       	movw	r22, r24
 d84:	cd 01       	movw	r24, r26
 d86:	08 95       	ret

00000d88 <_exit>:
 d88:	f8 94       	cli

00000d8a <__stop_program>:
 d8a:	ff cf       	rjmp	.-2      	; 0xd8a <__stop_program>
