
safe project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f92  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000011e  00800060  00000f92  00001026  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  0080017e  0080017e  00001144  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00001144  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00001810  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00001898  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000014ff  00000000  00000000  000019d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000005a6  00000000  00000000  00002ed7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000097c  00000000  00000000  0000347d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000428  00000000  00000000  00003dfc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000455  00000000  00000000  00004224  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001357  00000000  00000000  00004679  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	11 e0       	ldi	r17, 0x01	; 1
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 e9       	ldi	r30, 0x92	; 146
  68:	ff e0       	ldi	r31, 0x0F	; 15
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ae 37       	cpi	r26, 0x7E	; 126
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	11 e0       	ldi	r17, 0x01	; 1
  78:	ae e7       	ldi	r26, 0x7E	; 126
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a6 38       	cpi	r26, 0x86	; 134
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 0d 05 	call	0xa1a	; 0xa1a <main>
  8a:	0c 94 c7 07 	jmp	0xf8e	; 0xf8e <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <buzzer_INIT>:

#include "DIO.h"
//make the buzzer in this port output pin
void buzzer_INIT(unsigned char portname,unsigned char pinnumber)
{
	DIO_SETPINDIR(portname,pinnumber,1);
  92:	41 e0       	ldi	r20, 0x01	; 1
  94:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
}
  98:	08 95       	ret

0000009a <buzzer_ON>:
//write on this on logic high
void buzzer_ON(unsigned char portname,unsigned char pinnumber)
{
	DIO_WRITE(portname,pinnumber,1);
  9a:	41 e0       	ldi	r20, 0x01	; 1
  9c:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
}
  a0:	08 95       	ret

000000a2 <buzzer_OFF>:
//write on this on logic low
void buzzer_OFF(unsigned char portname,unsigned char pinnumber)
{
	DIO_WRITE(portname,pinnumber,0);
  a2:	40 e0       	ldi	r20, 0x00	; 0
  a4:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
}
  a8:	08 95       	ret

000000aa <buzzer_TOGGLE>:
//TOGGLE the output of the buzzer
void buzzer_TOGGLE(unsigned char portname,unsigned char pinnumber)
{
	DIO_togglepin(portname,pinnumber);
  aa:	0e 94 8d 01 	call	0x31a	; 0x31a <DIO_togglepin>
}
  ae:	08 95       	ret

000000b0 <buzzer_READ_STATUS>:
unsigned char buzzer_READ_STATUS(unsigned char portname,unsigned char pinnumber)
{
	return DIO_readpin(portname,pinnumber);
  b0:	0e 94 da 01 	call	0x3b4	; 0x3b4 <DIO_readpin>
}
  b4:	08 95       	ret

000000b6 <buzzer_set_port_direction>:
void buzzer_set_port_direction(unsigned char portname,unsigned char direction)
{
	DIO_set_port_direction(portname,direction);
  b6:	0e 94 3f 02 	call	0x47e	; 0x47e <DIO_set_port_direction>
}
  ba:	08 95       	ret

000000bc <buzzer_toggle_port>:
void buzzer_toggle_port(unsigned char portname)
{
	DIO_toggle_port(portname);
  bc:	0e 94 9e 02 	call	0x53c	; 0x53c <DIO_toggle_port>
  c0:	08 95       	ret

000000c2 <DIO_SETPINDIR>:
#include <avr/io.h>
//access DDR register to make the pins input or output
// Function Description:Set the direction of the given pin in the given port (direction 0 = input : 1 = output)
void DIO_SETPINDIR (unsigned char portname,unsigned char pinnumber,unsigned char direction)
{
	switch(portname)
  c2:	84 34       	cpi	r24, 0x44	; 68
  c4:	09 f4       	brne	.+2      	; 0xc8 <DIO_SETPINDIR+0x6>
  c6:	79 c0       	rjmp	.+242    	; 0x1ba <DIO_SETPINDIR+0xf8>
  c8:	85 34       	cpi	r24, 0x45	; 69
  ca:	48 f4       	brcc	.+18     	; 0xde <DIO_SETPINDIR+0x1c>
  cc:	82 34       	cpi	r24, 0x42	; 66
  ce:	b1 f1       	breq	.+108    	; 0x13c <DIO_SETPINDIR+0x7a>
  d0:	83 34       	cpi	r24, 0x43	; 67
  d2:	08 f0       	brcs	.+2      	; 0xd6 <DIO_SETPINDIR+0x14>
  d4:	53 c0       	rjmp	.+166    	; 0x17c <DIO_SETPINDIR+0xba>
  d6:	81 34       	cpi	r24, 0x41	; 65
  d8:	09 f0       	breq	.+2      	; 0xdc <DIO_SETPINDIR+0x1a>
  da:	8d c0       	rjmp	.+282    	; 0x1f6 <DIO_SETPINDIR+0x134>
  dc:	0f c0       	rjmp	.+30     	; 0xfc <DIO_SETPINDIR+0x3a>
  de:	82 36       	cpi	r24, 0x62	; 98
  e0:	69 f1       	breq	.+90     	; 0x13c <DIO_SETPINDIR+0x7a>
  e2:	83 36       	cpi	r24, 0x63	; 99
  e4:	20 f4       	brcc	.+8      	; 0xee <DIO_SETPINDIR+0x2c>
  e6:	81 36       	cpi	r24, 0x61	; 97
  e8:	09 f0       	breq	.+2      	; 0xec <DIO_SETPINDIR+0x2a>
  ea:	85 c0       	rjmp	.+266    	; 0x1f6 <DIO_SETPINDIR+0x134>
  ec:	07 c0       	rjmp	.+14     	; 0xfc <DIO_SETPINDIR+0x3a>
  ee:	83 36       	cpi	r24, 0x63	; 99
  f0:	09 f4       	brne	.+2      	; 0xf4 <DIO_SETPINDIR+0x32>
  f2:	44 c0       	rjmp	.+136    	; 0x17c <DIO_SETPINDIR+0xba>
  f4:	84 36       	cpi	r24, 0x64	; 100
  f6:	09 f0       	breq	.+2      	; 0xfa <DIO_SETPINDIR+0x38>
  f8:	7e c0       	rjmp	.+252    	; 0x1f6 <DIO_SETPINDIR+0x134>
  fa:	5f c0       	rjmp	.+190    	; 0x1ba <DIO_SETPINDIR+0xf8>
	{
		case'A':
		case'a':
		if(direction==1)
  fc:	41 30       	cpi	r20, 0x01	; 1
  fe:	69 f4       	brne	.+26     	; 0x11a <DIO_SETPINDIR+0x58>
		{
			SET_BIT(DDRA,pinnumber);   //set the pin whose its number given by (pinnumber) in DDR register as output
 100:	2a b3       	in	r18, 0x1a	; 26
 102:	81 e0       	ldi	r24, 0x01	; 1
 104:	90 e0       	ldi	r25, 0x00	; 0
 106:	ac 01       	movw	r20, r24
 108:	02 c0       	rjmp	.+4      	; 0x10e <DIO_SETPINDIR+0x4c>
 10a:	44 0f       	add	r20, r20
 10c:	55 1f       	adc	r21, r21
 10e:	6a 95       	dec	r22
 110:	e2 f7       	brpl	.-8      	; 0x10a <DIO_SETPINDIR+0x48>
 112:	ba 01       	movw	r22, r20
 114:	62 2b       	or	r22, r18
 116:	6a bb       	out	0x1a, r22	; 26
 118:	08 95       	ret
		}
		if(direction==0)
 11a:	44 23       	and	r20, r20
 11c:	09 f0       	breq	.+2      	; 0x120 <DIO_SETPINDIR+0x5e>
 11e:	6b c0       	rjmp	.+214    	; 0x1f6 <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRA,pinnumber);  //set the pin whose its number given by (pinnumber) in DDR register as input
 120:	2a b3       	in	r18, 0x1a	; 26
 122:	81 e0       	ldi	r24, 0x01	; 1
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	ac 01       	movw	r20, r24
 128:	02 c0       	rjmp	.+4      	; 0x12e <DIO_SETPINDIR+0x6c>
 12a:	44 0f       	add	r20, r20
 12c:	55 1f       	adc	r21, r21
 12e:	6a 95       	dec	r22
 130:	e2 f7       	brpl	.-8      	; 0x12a <DIO_SETPINDIR+0x68>
 132:	ba 01       	movw	r22, r20
 134:	60 95       	com	r22
 136:	62 23       	and	r22, r18
 138:	6a bb       	out	0x1a, r22	; 26
 13a:	08 95       	ret
		}
		break;
		case'B':
		case'b':
		if(direction==1)
 13c:	41 30       	cpi	r20, 0x01	; 1
 13e:	69 f4       	brne	.+26     	; 0x15a <DIO_SETPINDIR+0x98>
		{
			SET_BIT(DDRB,pinnumber);  
 140:	27 b3       	in	r18, 0x17	; 23
 142:	81 e0       	ldi	r24, 0x01	; 1
 144:	90 e0       	ldi	r25, 0x00	; 0
 146:	ac 01       	movw	r20, r24
 148:	02 c0       	rjmp	.+4      	; 0x14e <DIO_SETPINDIR+0x8c>
 14a:	44 0f       	add	r20, r20
 14c:	55 1f       	adc	r21, r21
 14e:	6a 95       	dec	r22
 150:	e2 f7       	brpl	.-8      	; 0x14a <DIO_SETPINDIR+0x88>
 152:	ba 01       	movw	r22, r20
 154:	62 2b       	or	r22, r18
 156:	67 bb       	out	0x17, r22	; 23
 158:	08 95       	ret
		}
		if(direction==0)
 15a:	44 23       	and	r20, r20
 15c:	09 f0       	breq	.+2      	; 0x160 <DIO_SETPINDIR+0x9e>
 15e:	4b c0       	rjmp	.+150    	; 0x1f6 <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRB,pinnumber);
 160:	27 b3       	in	r18, 0x17	; 23
 162:	81 e0       	ldi	r24, 0x01	; 1
 164:	90 e0       	ldi	r25, 0x00	; 0
 166:	ac 01       	movw	r20, r24
 168:	02 c0       	rjmp	.+4      	; 0x16e <DIO_SETPINDIR+0xac>
 16a:	44 0f       	add	r20, r20
 16c:	55 1f       	adc	r21, r21
 16e:	6a 95       	dec	r22
 170:	e2 f7       	brpl	.-8      	; 0x16a <DIO_SETPINDIR+0xa8>
 172:	ba 01       	movw	r22, r20
 174:	60 95       	com	r22
 176:	62 23       	and	r22, r18
 178:	67 bb       	out	0x17, r22	; 23
 17a:	08 95       	ret
		}
		break;
		case'C':
		case'c':
		if(direction==1)
 17c:	41 30       	cpi	r20, 0x01	; 1
 17e:	69 f4       	brne	.+26     	; 0x19a <DIO_SETPINDIR+0xd8>
		{
			SET_BIT(DDRC,pinnumber);   
 180:	24 b3       	in	r18, 0x14	; 20
 182:	81 e0       	ldi	r24, 0x01	; 1
 184:	90 e0       	ldi	r25, 0x00	; 0
 186:	ac 01       	movw	r20, r24
 188:	02 c0       	rjmp	.+4      	; 0x18e <DIO_SETPINDIR+0xcc>
 18a:	44 0f       	add	r20, r20
 18c:	55 1f       	adc	r21, r21
 18e:	6a 95       	dec	r22
 190:	e2 f7       	brpl	.-8      	; 0x18a <DIO_SETPINDIR+0xc8>
 192:	ba 01       	movw	r22, r20
 194:	62 2b       	or	r22, r18
 196:	64 bb       	out	0x14, r22	; 20
 198:	08 95       	ret
		}
		if(direction==0)
 19a:	44 23       	and	r20, r20
 19c:	61 f5       	brne	.+88     	; 0x1f6 <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRC,pinnumber);
 19e:	24 b3       	in	r18, 0x14	; 20
 1a0:	81 e0       	ldi	r24, 0x01	; 1
 1a2:	90 e0       	ldi	r25, 0x00	; 0
 1a4:	ac 01       	movw	r20, r24
 1a6:	02 c0       	rjmp	.+4      	; 0x1ac <DIO_SETPINDIR+0xea>
 1a8:	44 0f       	add	r20, r20
 1aa:	55 1f       	adc	r21, r21
 1ac:	6a 95       	dec	r22
 1ae:	e2 f7       	brpl	.-8      	; 0x1a8 <DIO_SETPINDIR+0xe6>
 1b0:	ba 01       	movw	r22, r20
 1b2:	60 95       	com	r22
 1b4:	62 23       	and	r22, r18
 1b6:	64 bb       	out	0x14, r22	; 20
 1b8:	08 95       	ret
		}
		break;
		case'D':
		case'd':
		if(direction==1)
 1ba:	41 30       	cpi	r20, 0x01	; 1
 1bc:	69 f4       	brne	.+26     	; 0x1d8 <DIO_SETPINDIR+0x116>
		{
			SET_BIT(DDRD,pinnumber);   
 1be:	21 b3       	in	r18, 0x11	; 17
 1c0:	81 e0       	ldi	r24, 0x01	; 1
 1c2:	90 e0       	ldi	r25, 0x00	; 0
 1c4:	ac 01       	movw	r20, r24
 1c6:	02 c0       	rjmp	.+4      	; 0x1cc <DIO_SETPINDIR+0x10a>
 1c8:	44 0f       	add	r20, r20
 1ca:	55 1f       	adc	r21, r21
 1cc:	6a 95       	dec	r22
 1ce:	e2 f7       	brpl	.-8      	; 0x1c8 <DIO_SETPINDIR+0x106>
 1d0:	ba 01       	movw	r22, r20
 1d2:	62 2b       	or	r22, r18
 1d4:	61 bb       	out	0x11, r22	; 17
 1d6:	08 95       	ret
		}
		if(direction==0)
 1d8:	44 23       	and	r20, r20
 1da:	69 f4       	brne	.+26     	; 0x1f6 <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRD,pinnumber);
 1dc:	21 b3       	in	r18, 0x11	; 17
 1de:	81 e0       	ldi	r24, 0x01	; 1
 1e0:	90 e0       	ldi	r25, 0x00	; 0
 1e2:	ac 01       	movw	r20, r24
 1e4:	02 c0       	rjmp	.+4      	; 0x1ea <DIO_SETPINDIR+0x128>
 1e6:	44 0f       	add	r20, r20
 1e8:	55 1f       	adc	r21, r21
 1ea:	6a 95       	dec	r22
 1ec:	e2 f7       	brpl	.-8      	; 0x1e6 <DIO_SETPINDIR+0x124>
 1ee:	ba 01       	movw	r22, r20
 1f0:	60 95       	com	r22
 1f2:	62 23       	and	r22, r18
 1f4:	61 bb       	out	0x11, r22	; 17
 1f6:	08 95       	ret

000001f8 <DIO_WRITE>:
}
// access PORT register to write the output value that will be on the output pin 
//Function Description : Set the value of the given pin in the given port (outputvalue 0 = low : 1 = high) 
void DIO_WRITE (unsigned char portname,unsigned char pinnumber, unsigned char outputvalue)
{
	switch(portname)
 1f8:	84 34       	cpi	r24, 0x44	; 68
 1fa:	09 f4       	brne	.+2      	; 0x1fe <DIO_WRITE+0x6>
 1fc:	71 c0       	rjmp	.+226    	; 0x2e0 <DIO_WRITE+0xe8>
 1fe:	85 34       	cpi	r24, 0x45	; 69
 200:	48 f4       	brcc	.+18     	; 0x214 <DIO_WRITE+0x1c>
 202:	82 34       	cpi	r24, 0x42	; 66
 204:	99 f1       	breq	.+102    	; 0x26c <DIO_WRITE+0x74>
 206:	83 34       	cpi	r24, 0x43	; 67
 208:	08 f0       	brcs	.+2      	; 0x20c <DIO_WRITE+0x14>
 20a:	4d c0       	rjmp	.+154    	; 0x2a6 <DIO_WRITE+0xae>
 20c:	81 34       	cpi	r24, 0x41	; 65
 20e:	09 f0       	breq	.+2      	; 0x212 <DIO_WRITE+0x1a>
 210:	83 c0       	rjmp	.+262    	; 0x318 <DIO_WRITE+0x120>
 212:	0f c0       	rjmp	.+30     	; 0x232 <DIO_WRITE+0x3a>
 214:	82 36       	cpi	r24, 0x62	; 98
 216:	51 f1       	breq	.+84     	; 0x26c <DIO_WRITE+0x74>
 218:	83 36       	cpi	r24, 0x63	; 99
 21a:	20 f4       	brcc	.+8      	; 0x224 <DIO_WRITE+0x2c>
 21c:	81 36       	cpi	r24, 0x61	; 97
 21e:	09 f0       	breq	.+2      	; 0x222 <DIO_WRITE+0x2a>
 220:	7b c0       	rjmp	.+246    	; 0x318 <DIO_WRITE+0x120>
 222:	07 c0       	rjmp	.+14     	; 0x232 <DIO_WRITE+0x3a>
 224:	83 36       	cpi	r24, 0x63	; 99
 226:	09 f4       	brne	.+2      	; 0x22a <DIO_WRITE+0x32>
 228:	3e c0       	rjmp	.+124    	; 0x2a6 <DIO_WRITE+0xae>
 22a:	84 36       	cpi	r24, 0x64	; 100
 22c:	09 f0       	breq	.+2      	; 0x230 <DIO_WRITE+0x38>
 22e:	74 c0       	rjmp	.+232    	; 0x318 <DIO_WRITE+0x120>
 230:	57 c0       	rjmp	.+174    	; 0x2e0 <DIO_WRITE+0xe8>
	{
		case 'A':
		case'a':
		if(outputvalue == 1)
 232:	41 30       	cpi	r20, 0x01	; 1
 234:	69 f4       	brne	.+26     	; 0x250 <DIO_WRITE+0x58>
		{
			SET_BIT(PORTA,pinnumber);
 236:	2b b3       	in	r18, 0x1b	; 27
 238:	81 e0       	ldi	r24, 0x01	; 1
 23a:	90 e0       	ldi	r25, 0x00	; 0
 23c:	ac 01       	movw	r20, r24
 23e:	02 c0       	rjmp	.+4      	; 0x244 <DIO_WRITE+0x4c>
 240:	44 0f       	add	r20, r20
 242:	55 1f       	adc	r21, r21
 244:	6a 95       	dec	r22
 246:	e2 f7       	brpl	.-8      	; 0x240 <DIO_WRITE+0x48>
 248:	ba 01       	movw	r22, r20
 24a:	62 2b       	or	r22, r18
 24c:	6b bb       	out	0x1b, r22	; 27
 24e:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTA,pinnumber);
 250:	2b b3       	in	r18, 0x1b	; 27
 252:	81 e0       	ldi	r24, 0x01	; 1
 254:	90 e0       	ldi	r25, 0x00	; 0
 256:	ac 01       	movw	r20, r24
 258:	02 c0       	rjmp	.+4      	; 0x25e <DIO_WRITE+0x66>
 25a:	44 0f       	add	r20, r20
 25c:	55 1f       	adc	r21, r21
 25e:	6a 95       	dec	r22
 260:	e2 f7       	brpl	.-8      	; 0x25a <DIO_WRITE+0x62>
 262:	ba 01       	movw	r22, r20
 264:	60 95       	com	r22
 266:	62 23       	and	r22, r18
 268:	6b bb       	out	0x1b, r22	; 27
 26a:	08 95       	ret
		}
		break;
		case 'B':
		case'b':
		if(outputvalue == 1)
 26c:	41 30       	cpi	r20, 0x01	; 1
 26e:	69 f4       	brne	.+26     	; 0x28a <DIO_WRITE+0x92>
		{
			SET_BIT(PORTB,pinnumber);
 270:	28 b3       	in	r18, 0x18	; 24
 272:	81 e0       	ldi	r24, 0x01	; 1
 274:	90 e0       	ldi	r25, 0x00	; 0
 276:	ac 01       	movw	r20, r24
 278:	02 c0       	rjmp	.+4      	; 0x27e <DIO_WRITE+0x86>
 27a:	44 0f       	add	r20, r20
 27c:	55 1f       	adc	r21, r21
 27e:	6a 95       	dec	r22
 280:	e2 f7       	brpl	.-8      	; 0x27a <DIO_WRITE+0x82>
 282:	ba 01       	movw	r22, r20
 284:	62 2b       	or	r22, r18
 286:	68 bb       	out	0x18, r22	; 24
 288:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTB,pinnumber);
 28a:	28 b3       	in	r18, 0x18	; 24
 28c:	81 e0       	ldi	r24, 0x01	; 1
 28e:	90 e0       	ldi	r25, 0x00	; 0
 290:	ac 01       	movw	r20, r24
 292:	02 c0       	rjmp	.+4      	; 0x298 <DIO_WRITE+0xa0>
 294:	44 0f       	add	r20, r20
 296:	55 1f       	adc	r21, r21
 298:	6a 95       	dec	r22
 29a:	e2 f7       	brpl	.-8      	; 0x294 <DIO_WRITE+0x9c>
 29c:	ba 01       	movw	r22, r20
 29e:	60 95       	com	r22
 2a0:	62 23       	and	r22, r18
 2a2:	68 bb       	out	0x18, r22	; 24
 2a4:	08 95       	ret
		}
		break;
		case 'C':
		case'c':
		if(outputvalue == 1)
 2a6:	41 30       	cpi	r20, 0x01	; 1
 2a8:	69 f4       	brne	.+26     	; 0x2c4 <DIO_WRITE+0xcc>
		{
			SET_BIT(PORTC,pinnumber);
 2aa:	25 b3       	in	r18, 0x15	; 21
 2ac:	81 e0       	ldi	r24, 0x01	; 1
 2ae:	90 e0       	ldi	r25, 0x00	; 0
 2b0:	ac 01       	movw	r20, r24
 2b2:	02 c0       	rjmp	.+4      	; 0x2b8 <DIO_WRITE+0xc0>
 2b4:	44 0f       	add	r20, r20
 2b6:	55 1f       	adc	r21, r21
 2b8:	6a 95       	dec	r22
 2ba:	e2 f7       	brpl	.-8      	; 0x2b4 <DIO_WRITE+0xbc>
 2bc:	ba 01       	movw	r22, r20
 2be:	62 2b       	or	r22, r18
 2c0:	65 bb       	out	0x15, r22	; 21
 2c2:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTC,pinnumber);
 2c4:	25 b3       	in	r18, 0x15	; 21
 2c6:	81 e0       	ldi	r24, 0x01	; 1
 2c8:	90 e0       	ldi	r25, 0x00	; 0
 2ca:	ac 01       	movw	r20, r24
 2cc:	02 c0       	rjmp	.+4      	; 0x2d2 <DIO_WRITE+0xda>
 2ce:	44 0f       	add	r20, r20
 2d0:	55 1f       	adc	r21, r21
 2d2:	6a 95       	dec	r22
 2d4:	e2 f7       	brpl	.-8      	; 0x2ce <DIO_WRITE+0xd6>
 2d6:	ba 01       	movw	r22, r20
 2d8:	60 95       	com	r22
 2da:	62 23       	and	r22, r18
 2dc:	65 bb       	out	0x15, r22	; 21
 2de:	08 95       	ret
		}
		break;
		case 'D':
		case'd':
		if(outputvalue == 1)
 2e0:	41 30       	cpi	r20, 0x01	; 1
 2e2:	69 f4       	brne	.+26     	; 0x2fe <DIO_WRITE+0x106>
		{
			SET_BIT(PORTD,pinnumber);
 2e4:	22 b3       	in	r18, 0x12	; 18
 2e6:	81 e0       	ldi	r24, 0x01	; 1
 2e8:	90 e0       	ldi	r25, 0x00	; 0
 2ea:	ac 01       	movw	r20, r24
 2ec:	02 c0       	rjmp	.+4      	; 0x2f2 <DIO_WRITE+0xfa>
 2ee:	44 0f       	add	r20, r20
 2f0:	55 1f       	adc	r21, r21
 2f2:	6a 95       	dec	r22
 2f4:	e2 f7       	brpl	.-8      	; 0x2ee <DIO_WRITE+0xf6>
 2f6:	ba 01       	movw	r22, r20
 2f8:	62 2b       	or	r22, r18
 2fa:	62 bb       	out	0x12, r22	; 18
 2fc:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTD,pinnumber);
 2fe:	22 b3       	in	r18, 0x12	; 18
 300:	81 e0       	ldi	r24, 0x01	; 1
 302:	90 e0       	ldi	r25, 0x00	; 0
 304:	ac 01       	movw	r20, r24
 306:	02 c0       	rjmp	.+4      	; 0x30c <DIO_WRITE+0x114>
 308:	44 0f       	add	r20, r20
 30a:	55 1f       	adc	r21, r21
 30c:	6a 95       	dec	r22
 30e:	e2 f7       	brpl	.-8      	; 0x308 <DIO_WRITE+0x110>
 310:	ba 01       	movw	r22, r20
 312:	60 95       	com	r22
 314:	62 23       	and	r22, r18
 316:	62 bb       	out	0x12, r22	; 18
 318:	08 95       	ret

0000031a <DIO_togglepin>:
}		
// access PORT register to toggle the output value that appear in the output pin
//	Function Description : Reverse the value of the given pin in the given port.
void DIO_togglepin(unsigned char portname,unsigned char pinnumber)
{
			switch(portname)
 31a:	84 34       	cpi	r24, 0x44	; 68
 31c:	09 f4       	brne	.+2      	; 0x320 <DIO_togglepin+0x6>
 31e:	3d c0       	rjmp	.+122    	; 0x39a <DIO_togglepin+0x80>
 320:	85 34       	cpi	r24, 0x45	; 69
 322:	40 f4       	brcc	.+16     	; 0x334 <DIO_togglepin+0x1a>
 324:	82 34       	cpi	r24, 0x42	; 66
 326:	f9 f0       	breq	.+62     	; 0x366 <DIO_togglepin+0x4c>
 328:	83 34       	cpi	r24, 0x43	; 67
 32a:	50 f5       	brcc	.+84     	; 0x380 <DIO_togglepin+0x66>
 32c:	81 34       	cpi	r24, 0x41	; 65
 32e:	09 f0       	breq	.+2      	; 0x332 <DIO_togglepin+0x18>
 330:	40 c0       	rjmp	.+128    	; 0x3b2 <DIO_togglepin+0x98>
 332:	0c c0       	rjmp	.+24     	; 0x34c <DIO_togglepin+0x32>
 334:	82 36       	cpi	r24, 0x62	; 98
 336:	b9 f0       	breq	.+46     	; 0x366 <DIO_togglepin+0x4c>
 338:	83 36       	cpi	r24, 0x63	; 99
 33a:	18 f4       	brcc	.+6      	; 0x342 <DIO_togglepin+0x28>
 33c:	81 36       	cpi	r24, 0x61	; 97
 33e:	c9 f5       	brne	.+114    	; 0x3b2 <DIO_togglepin+0x98>
 340:	05 c0       	rjmp	.+10     	; 0x34c <DIO_togglepin+0x32>
 342:	83 36       	cpi	r24, 0x63	; 99
 344:	e9 f0       	breq	.+58     	; 0x380 <DIO_togglepin+0x66>
 346:	84 36       	cpi	r24, 0x64	; 100
 348:	a1 f5       	brne	.+104    	; 0x3b2 <DIO_togglepin+0x98>
 34a:	27 c0       	rjmp	.+78     	; 0x39a <DIO_togglepin+0x80>
			{
				case 'A':
				case 'a':
				TOGGLE_BIT(PORTA,pinnumber);
 34c:	2b b3       	in	r18, 0x1b	; 27
 34e:	81 e0       	ldi	r24, 0x01	; 1
 350:	90 e0       	ldi	r25, 0x00	; 0
 352:	ac 01       	movw	r20, r24
 354:	02 c0       	rjmp	.+4      	; 0x35a <DIO_togglepin+0x40>
 356:	44 0f       	add	r20, r20
 358:	55 1f       	adc	r21, r21
 35a:	6a 95       	dec	r22
 35c:	e2 f7       	brpl	.-8      	; 0x356 <DIO_togglepin+0x3c>
 35e:	ba 01       	movw	r22, r20
 360:	62 27       	eor	r22, r18
 362:	6b bb       	out	0x1b, r22	; 27
				break;
 364:	08 95       	ret
				
				case 'B':
				case 'b':
				TOGGLE_BIT(PORTB,pinnumber);
 366:	28 b3       	in	r18, 0x18	; 24
 368:	81 e0       	ldi	r24, 0x01	; 1
 36a:	90 e0       	ldi	r25, 0x00	; 0
 36c:	ac 01       	movw	r20, r24
 36e:	02 c0       	rjmp	.+4      	; 0x374 <DIO_togglepin+0x5a>
 370:	44 0f       	add	r20, r20
 372:	55 1f       	adc	r21, r21
 374:	6a 95       	dec	r22
 376:	e2 f7       	brpl	.-8      	; 0x370 <DIO_togglepin+0x56>
 378:	ba 01       	movw	r22, r20
 37a:	62 27       	eor	r22, r18
 37c:	68 bb       	out	0x18, r22	; 24
				break;
 37e:	08 95       	ret
				
				case 'C':
				case 'c':
				TOGGLE_BIT(PORTC,pinnumber);
 380:	25 b3       	in	r18, 0x15	; 21
 382:	81 e0       	ldi	r24, 0x01	; 1
 384:	90 e0       	ldi	r25, 0x00	; 0
 386:	ac 01       	movw	r20, r24
 388:	02 c0       	rjmp	.+4      	; 0x38e <DIO_togglepin+0x74>
 38a:	44 0f       	add	r20, r20
 38c:	55 1f       	adc	r21, r21
 38e:	6a 95       	dec	r22
 390:	e2 f7       	brpl	.-8      	; 0x38a <DIO_togglepin+0x70>
 392:	ba 01       	movw	r22, r20
 394:	62 27       	eor	r22, r18
 396:	65 bb       	out	0x15, r22	; 21
				break;
 398:	08 95       	ret
				
				case 'D':
				case 'd':
				TOGGLE_BIT(PORTD,pinnumber);
 39a:	22 b3       	in	r18, 0x12	; 18
 39c:	81 e0       	ldi	r24, 0x01	; 1
 39e:	90 e0       	ldi	r25, 0x00	; 0
 3a0:	ac 01       	movw	r20, r24
 3a2:	02 c0       	rjmp	.+4      	; 0x3a8 <DIO_togglepin+0x8e>
 3a4:	44 0f       	add	r20, r20
 3a6:	55 1f       	adc	r21, r21
 3a8:	6a 95       	dec	r22
 3aa:	e2 f7       	brpl	.-8      	; 0x3a4 <DIO_togglepin+0x8a>
 3ac:	ba 01       	movw	r22, r20
 3ae:	62 27       	eor	r22, r18
 3b0:	62 bb       	out	0x12, r22	; 18
 3b2:	08 95       	ret

000003b4 <DIO_readpin>:
//Function Description : Returns 1 if the value of the given pin is high and zero if the value is low
//access pin register to know the reading of pin reg in case it is input pin to know the value of the voltage that it received from the input device connected to it
unsigned char DIO_readpin(unsigned char portname,unsigned char bitnumber)
{
	unsigned char reading=0;
	switch(portname)
 3b4:	84 34       	cpi	r24, 0x44	; 68
 3b6:	09 f4       	brne	.+2      	; 0x3ba <DIO_readpin+0x6>
 3b8:	4e c0       	rjmp	.+156    	; 0x456 <DIO_readpin+0xa2>
 3ba:	85 34       	cpi	r24, 0x45	; 69
 3bc:	40 f4       	brcc	.+16     	; 0x3ce <DIO_readpin+0x1a>
 3be:	82 34       	cpi	r24, 0x42	; 66
 3c0:	31 f1       	breq	.+76     	; 0x40e <DIO_readpin+0x5a>
 3c2:	83 34       	cpi	r24, 0x43	; 67
 3c4:	b0 f5       	brcc	.+108    	; 0x432 <DIO_readpin+0x7e>
 3c6:	81 34       	cpi	r24, 0x41	; 65
 3c8:	09 f0       	breq	.+2      	; 0x3cc <DIO_readpin+0x18>
 3ca:	57 c0       	rjmp	.+174    	; 0x47a <DIO_readpin+0xc6>
 3cc:	0e c0       	rjmp	.+28     	; 0x3ea <DIO_readpin+0x36>
 3ce:	82 36       	cpi	r24, 0x62	; 98
 3d0:	f1 f0       	breq	.+60     	; 0x40e <DIO_readpin+0x5a>
 3d2:	83 36       	cpi	r24, 0x63	; 99
 3d4:	20 f4       	brcc	.+8      	; 0x3de <DIO_readpin+0x2a>
 3d6:	81 36       	cpi	r24, 0x61	; 97
 3d8:	09 f0       	breq	.+2      	; 0x3dc <DIO_readpin+0x28>
 3da:	4f c0       	rjmp	.+158    	; 0x47a <DIO_readpin+0xc6>
 3dc:	06 c0       	rjmp	.+12     	; 0x3ea <DIO_readpin+0x36>
 3de:	83 36       	cpi	r24, 0x63	; 99
 3e0:	41 f1       	breq	.+80     	; 0x432 <DIO_readpin+0x7e>
 3e2:	84 36       	cpi	r24, 0x64	; 100
 3e4:	09 f0       	breq	.+2      	; 0x3e8 <DIO_readpin+0x34>
 3e6:	49 c0       	rjmp	.+146    	; 0x47a <DIO_readpin+0xc6>
 3e8:	36 c0       	rjmp	.+108    	; 0x456 <DIO_readpin+0xa2>
	{
		case'A':
		case'a':
		reading= READ_BIT(PINA,bitnumber);
 3ea:	29 b3       	in	r18, 0x19	; 25
 3ec:	81 e0       	ldi	r24, 0x01	; 1
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	06 2e       	mov	r0, r22
 3f2:	02 c0       	rjmp	.+4      	; 0x3f8 <DIO_readpin+0x44>
 3f4:	88 0f       	add	r24, r24
 3f6:	99 1f       	adc	r25, r25
 3f8:	0a 94       	dec	r0
 3fa:	e2 f7       	brpl	.-8      	; 0x3f4 <DIO_readpin+0x40>
 3fc:	30 e0       	ldi	r19, 0x00	; 0
 3fe:	82 23       	and	r24, r18
 400:	93 23       	and	r25, r19
 402:	02 c0       	rjmp	.+4      	; 0x408 <DIO_readpin+0x54>
 404:	95 95       	asr	r25
 406:	87 95       	ror	r24
 408:	6a 95       	dec	r22
 40a:	e2 f7       	brpl	.-8      	; 0x404 <DIO_readpin+0x50>
		break;
 40c:	08 95       	ret
		
		case'B':
		case'b':
		reading= READ_BIT(PINB,bitnumber);
 40e:	26 b3       	in	r18, 0x16	; 22
 410:	81 e0       	ldi	r24, 0x01	; 1
 412:	90 e0       	ldi	r25, 0x00	; 0
 414:	06 2e       	mov	r0, r22
 416:	02 c0       	rjmp	.+4      	; 0x41c <DIO_readpin+0x68>
 418:	88 0f       	add	r24, r24
 41a:	99 1f       	adc	r25, r25
 41c:	0a 94       	dec	r0
 41e:	e2 f7       	brpl	.-8      	; 0x418 <DIO_readpin+0x64>
 420:	30 e0       	ldi	r19, 0x00	; 0
 422:	82 23       	and	r24, r18
 424:	93 23       	and	r25, r19
 426:	02 c0       	rjmp	.+4      	; 0x42c <DIO_readpin+0x78>
 428:	95 95       	asr	r25
 42a:	87 95       	ror	r24
 42c:	6a 95       	dec	r22
 42e:	e2 f7       	brpl	.-8      	; 0x428 <DIO_readpin+0x74>
		break;
 430:	08 95       	ret
		
		case'C':
		case'c':
		reading= READ_BIT(PINC,bitnumber);
 432:	23 b3       	in	r18, 0x13	; 19
 434:	81 e0       	ldi	r24, 0x01	; 1
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	06 2e       	mov	r0, r22
 43a:	02 c0       	rjmp	.+4      	; 0x440 <DIO_readpin+0x8c>
 43c:	88 0f       	add	r24, r24
 43e:	99 1f       	adc	r25, r25
 440:	0a 94       	dec	r0
 442:	e2 f7       	brpl	.-8      	; 0x43c <DIO_readpin+0x88>
 444:	30 e0       	ldi	r19, 0x00	; 0
 446:	82 23       	and	r24, r18
 448:	93 23       	and	r25, r19
 44a:	02 c0       	rjmp	.+4      	; 0x450 <DIO_readpin+0x9c>
 44c:	95 95       	asr	r25
 44e:	87 95       	ror	r24
 450:	6a 95       	dec	r22
 452:	e2 f7       	brpl	.-8      	; 0x44c <DIO_readpin+0x98>
		break;
 454:	08 95       	ret
		
		case'D':
		case'd':
		reading= READ_BIT(PIND,bitnumber);
 456:	20 b3       	in	r18, 0x10	; 16
 458:	81 e0       	ldi	r24, 0x01	; 1
 45a:	90 e0       	ldi	r25, 0x00	; 0
 45c:	06 2e       	mov	r0, r22
 45e:	02 c0       	rjmp	.+4      	; 0x464 <DIO_readpin+0xb0>
 460:	88 0f       	add	r24, r24
 462:	99 1f       	adc	r25, r25
 464:	0a 94       	dec	r0
 466:	e2 f7       	brpl	.-8      	; 0x460 <DIO_readpin+0xac>
 468:	30 e0       	ldi	r19, 0x00	; 0
 46a:	82 23       	and	r24, r18
 46c:	93 23       	and	r25, r19
 46e:	02 c0       	rjmp	.+4      	; 0x474 <DIO_readpin+0xc0>
 470:	95 95       	asr	r25
 472:	87 95       	ror	r24
 474:	6a 95       	dec	r22
 476:	e2 f7       	brpl	.-8      	; 0x470 <DIO_readpin+0xbc>
		break;	
 478:	08 95       	ret
}
//Function Description : Returns 1 if the value of the given pin is high and zero if the value is low
//access pin register to know the reading of pin reg in case it is input pin to know the value of the voltage that it received from the input device connected to it
unsigned char DIO_readpin(unsigned char portname,unsigned char bitnumber)
{
	unsigned char reading=0;
 47a:	80 e0       	ldi	r24, 0x00	; 0
		case'd':
		reading= READ_BIT(PIND,bitnumber);
		break;	
	}
	return reading;	
}
 47c:	08 95       	ret

0000047e <DIO_set_port_direction>:
//	Function Description : set the direction of whole port .
//to set the direction of the whole port (all pins of the port will be input or output )
void DIO_set_port_direction(unsigned char portname,unsigned char direction)
{
	switch(portname)
 47e:	84 34       	cpi	r24, 0x44	; 68
 480:	d9 f0       	breq	.+54     	; 0x4b8 <DIO_set_port_direction+0x3a>
 482:	85 34       	cpi	r24, 0x45	; 69
 484:	38 f4       	brcc	.+14     	; 0x494 <DIO_set_port_direction+0x16>
 486:	82 34       	cpi	r24, 0x42	; 66
 488:	99 f0       	breq	.+38     	; 0x4b0 <DIO_set_port_direction+0x32>
 48a:	83 34       	cpi	r24, 0x43	; 67
 48c:	98 f4       	brcc	.+38     	; 0x4b4 <DIO_set_port_direction+0x36>
 48e:	81 34       	cpi	r24, 0x41	; 65
 490:	a1 f4       	brne	.+40     	; 0x4ba <DIO_set_port_direction+0x3c>
 492:	0c c0       	rjmp	.+24     	; 0x4ac <DIO_set_port_direction+0x2e>
 494:	82 36       	cpi	r24, 0x62	; 98
 496:	61 f0       	breq	.+24     	; 0x4b0 <DIO_set_port_direction+0x32>
 498:	83 36       	cpi	r24, 0x63	; 99
 49a:	18 f4       	brcc	.+6      	; 0x4a2 <DIO_set_port_direction+0x24>
 49c:	81 36       	cpi	r24, 0x61	; 97
 49e:	69 f4       	brne	.+26     	; 0x4ba <DIO_set_port_direction+0x3c>
 4a0:	05 c0       	rjmp	.+10     	; 0x4ac <DIO_set_port_direction+0x2e>
 4a2:	83 36       	cpi	r24, 0x63	; 99
 4a4:	39 f0       	breq	.+14     	; 0x4b4 <DIO_set_port_direction+0x36>
 4a6:	84 36       	cpi	r24, 0x64	; 100
 4a8:	41 f4       	brne	.+16     	; 0x4ba <DIO_set_port_direction+0x3c>
 4aa:	06 c0       	rjmp	.+12     	; 0x4b8 <DIO_set_port_direction+0x3a>
	{
		case'A':
		case'a':
		DDRA=direction;
 4ac:	6a bb       	out	0x1a, r22	; 26
		break;
 4ae:	08 95       	ret
		case'B':
		case'b':
		DDRB=direction;
 4b0:	67 bb       	out	0x17, r22	; 23
		break;
 4b2:	08 95       	ret
		case'C':
		case'c':
		DDRC=direction;
 4b4:	64 bb       	out	0x14, r22	; 20
		break;
 4b6:	08 95       	ret
		case'D':
		case'd':
		DDRD=direction;
 4b8:	61 bb       	out	0x11, r22	; 17
 4ba:	08 95       	ret

000004bc <DIO_write_port>:
	}
}
//	Function Description : Write the value to all port pins.
void DIO_write_port(unsigned char portname,unsigned char portvalue)
{
	switch(portname)
 4bc:	84 34       	cpi	r24, 0x44	; 68
 4be:	d9 f0       	breq	.+54     	; 0x4f6 <DIO_write_port+0x3a>
 4c0:	85 34       	cpi	r24, 0x45	; 69
 4c2:	38 f4       	brcc	.+14     	; 0x4d2 <DIO_write_port+0x16>
 4c4:	82 34       	cpi	r24, 0x42	; 66
 4c6:	99 f0       	breq	.+38     	; 0x4ee <DIO_write_port+0x32>
 4c8:	83 34       	cpi	r24, 0x43	; 67
 4ca:	98 f4       	brcc	.+38     	; 0x4f2 <DIO_write_port+0x36>
 4cc:	81 34       	cpi	r24, 0x41	; 65
 4ce:	a1 f4       	brne	.+40     	; 0x4f8 <DIO_write_port+0x3c>
 4d0:	0c c0       	rjmp	.+24     	; 0x4ea <DIO_write_port+0x2e>
 4d2:	82 36       	cpi	r24, 0x62	; 98
 4d4:	61 f0       	breq	.+24     	; 0x4ee <DIO_write_port+0x32>
 4d6:	83 36       	cpi	r24, 0x63	; 99
 4d8:	18 f4       	brcc	.+6      	; 0x4e0 <DIO_write_port+0x24>
 4da:	81 36       	cpi	r24, 0x61	; 97
 4dc:	69 f4       	brne	.+26     	; 0x4f8 <DIO_write_port+0x3c>
 4de:	05 c0       	rjmp	.+10     	; 0x4ea <DIO_write_port+0x2e>
 4e0:	83 36       	cpi	r24, 0x63	; 99
 4e2:	39 f0       	breq	.+14     	; 0x4f2 <DIO_write_port+0x36>
 4e4:	84 36       	cpi	r24, 0x64	; 100
 4e6:	41 f4       	brne	.+16     	; 0x4f8 <DIO_write_port+0x3c>
 4e8:	06 c0       	rjmp	.+12     	; 0x4f6 <DIO_write_port+0x3a>
	{
		case'A':
		case'a':
		PORTA=portvalue;
 4ea:	6b bb       	out	0x1b, r22	; 27
		break;
 4ec:	08 95       	ret
		case'B':
		case'b':
		PORTB=portvalue;
 4ee:	68 bb       	out	0x18, r22	; 24
		break;
 4f0:	08 95       	ret
		case'C':
		case'c':
		PORTC=portvalue;
 4f2:	65 bb       	out	0x15, r22	; 21
		break;
 4f4:	08 95       	ret
		case'D':
		case'd':
		PORTD=portvalue;
 4f6:	62 bb       	out	0x12, r22	; 18
 4f8:	08 95       	ret

000004fa <DIO_read_port>:
}
//	Function Description : read the value of the port .
unsigned char DIO_read_port(unsigned char portname)
{
	unsigned char reading_port=0;
	switch(portname)
 4fa:	84 34       	cpi	r24, 0x44	; 68
 4fc:	d9 f0       	breq	.+54     	; 0x534 <DIO_read_port+0x3a>
 4fe:	85 34       	cpi	r24, 0x45	; 69
 500:	38 f4       	brcc	.+14     	; 0x510 <DIO_read_port+0x16>
 502:	82 34       	cpi	r24, 0x42	; 66
 504:	99 f0       	breq	.+38     	; 0x52c <DIO_read_port+0x32>
 506:	83 34       	cpi	r24, 0x43	; 67
 508:	98 f4       	brcc	.+38     	; 0x530 <DIO_read_port+0x36>
 50a:	81 34       	cpi	r24, 0x41	; 65
 50c:	a9 f4       	brne	.+42     	; 0x538 <DIO_read_port+0x3e>
 50e:	0c c0       	rjmp	.+24     	; 0x528 <DIO_read_port+0x2e>
 510:	82 36       	cpi	r24, 0x62	; 98
 512:	61 f0       	breq	.+24     	; 0x52c <DIO_read_port+0x32>
 514:	83 36       	cpi	r24, 0x63	; 99
 516:	18 f4       	brcc	.+6      	; 0x51e <DIO_read_port+0x24>
 518:	81 36       	cpi	r24, 0x61	; 97
 51a:	71 f4       	brne	.+28     	; 0x538 <DIO_read_port+0x3e>
 51c:	05 c0       	rjmp	.+10     	; 0x528 <DIO_read_port+0x2e>
 51e:	83 36       	cpi	r24, 0x63	; 99
 520:	39 f0       	breq	.+14     	; 0x530 <DIO_read_port+0x36>
 522:	84 36       	cpi	r24, 0x64	; 100
 524:	49 f4       	brne	.+18     	; 0x538 <DIO_read_port+0x3e>
 526:	06 c0       	rjmp	.+12     	; 0x534 <DIO_read_port+0x3a>
	{
		case'A':
		case'a':
		reading_port=PINA;
 528:	89 b3       	in	r24, 0x19	; 25
		break;
 52a:	08 95       	ret
		case'B':
		case'b':
		reading_port=PINB;
 52c:	86 b3       	in	r24, 0x16	; 22
		break;
 52e:	08 95       	ret
		case'C':
		case'c':
		reading_port=PINC;
 530:	83 b3       	in	r24, 0x13	; 19
		break;
 532:	08 95       	ret
		case'D':
		case'd':
		reading_port=PIND;
 534:	80 b3       	in	r24, 0x10	; 16
		break;
 536:	08 95       	ret
	}	
}
//	Function Description : read the value of the port .
unsigned char DIO_read_port(unsigned char portname)
{
	unsigned char reading_port=0;
 538:	80 e0       	ldi	r24, 0x00	; 0
		reading_port=PIND;
		break;
		
	}
	return reading_port;
}
 53a:	08 95       	ret

0000053c <DIO_toggle_port>:
//	Function Description : toggle the value of the port that stored in PORT reg if the led connected to output pin will exit to it logic 0 instead of logic 1 .
void DIO_toggle_port(unsigned char portname)
{
	switch(portname)
 53c:	84 34       	cpi	r24, 0x44	; 68
 53e:	09 f1       	breq	.+66     	; 0x582 <DIO_toggle_port+0x46>
 540:	85 34       	cpi	r24, 0x45	; 69
 542:	38 f4       	brcc	.+14     	; 0x552 <DIO_toggle_port+0x16>
 544:	82 34       	cpi	r24, 0x42	; 66
 546:	a9 f0       	breq	.+42     	; 0x572 <DIO_toggle_port+0x36>
 548:	83 34       	cpi	r24, 0x43	; 67
 54a:	b8 f4       	brcc	.+46     	; 0x57a <DIO_toggle_port+0x3e>
 54c:	81 34       	cpi	r24, 0x41	; 65
 54e:	e1 f4       	brne	.+56     	; 0x588 <DIO_toggle_port+0x4c>
 550:	0c c0       	rjmp	.+24     	; 0x56a <DIO_toggle_port+0x2e>
 552:	82 36       	cpi	r24, 0x62	; 98
 554:	71 f0       	breq	.+28     	; 0x572 <DIO_toggle_port+0x36>
 556:	83 36       	cpi	r24, 0x63	; 99
 558:	18 f4       	brcc	.+6      	; 0x560 <DIO_toggle_port+0x24>
 55a:	81 36       	cpi	r24, 0x61	; 97
 55c:	a9 f4       	brne	.+42     	; 0x588 <DIO_toggle_port+0x4c>
 55e:	05 c0       	rjmp	.+10     	; 0x56a <DIO_toggle_port+0x2e>
 560:	83 36       	cpi	r24, 0x63	; 99
 562:	59 f0       	breq	.+22     	; 0x57a <DIO_toggle_port+0x3e>
 564:	84 36       	cpi	r24, 0x64	; 100
 566:	81 f4       	brne	.+32     	; 0x588 <DIO_toggle_port+0x4c>
 568:	0c c0       	rjmp	.+24     	; 0x582 <DIO_toggle_port+0x46>
	{
		case'A':
		case'a':
		PORTA= ~PORTA;   //PORTA^=0xff;
 56a:	8b b3       	in	r24, 0x1b	; 27
 56c:	80 95       	com	r24
 56e:	8b bb       	out	0x1b, r24	; 27
		break;
 570:	08 95       	ret
		case'B':
		case'b':
		PORTB =~PORTB;   
 572:	88 b3       	in	r24, 0x18	; 24
 574:	80 95       	com	r24
 576:	88 bb       	out	0x18, r24	; 24
		break;
 578:	08 95       	ret
		case'C':
		case'c':
		PORTC= ~PORTC;   
 57a:	85 b3       	in	r24, 0x15	; 21
 57c:	80 95       	com	r24
 57e:	85 bb       	out	0x15, r24	; 21
		break;
 580:	08 95       	ret
		case'D':
		case'd':
		PORTD= ~PORTD;   
 582:	82 b3       	in	r24, 0x12	; 18
 584:	80 95       	com	r24
 586:	82 bb       	out	0x12, r24	; 18
 588:	08 95       	ret

0000058a <DIO_CONNECT_PULLUP>:
		break;	
	}
}
void DIO_CONNECT_PULLUP(unsigned char portname,unsigned char pinnumber,unsigned char connect_pullup)
{
		DIO_WRITE(portname,pinnumber,connect_pullup);
 58a:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
}
 58e:	08 95       	ret

00000590 <DIO_WRITE_LOW_NIBBLE>:

void DIO_WRITE_LOW_NIBBLE(unsigned char portname,unsigned char value)
{
 590:	cf 92       	push	r12
 592:	df 92       	push	r13
 594:	ff 92       	push	r15
 596:	0f 93       	push	r16
 598:	1f 93       	push	r17
 59a:	cf 93       	push	r28
 59c:	df 93       	push	r29
 59e:	f8 2e       	mov	r15, r24
 5a0:	c0 e0       	ldi	r28, 0x00	; 0
 5a2:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_WRITE(portname,i,READ_BIT(value,i));
 5a4:	01 e0       	ldi	r16, 0x01	; 1
 5a6:	10 e0       	ldi	r17, 0x00	; 0
 5a8:	c6 2e       	mov	r12, r22
 5aa:	dd 24       	eor	r13, r13
 5ac:	c8 01       	movw	r24, r16
 5ae:	0c 2e       	mov	r0, r28
 5b0:	02 c0       	rjmp	.+4      	; 0x5b6 <DIO_WRITE_LOW_NIBBLE+0x26>
 5b2:	88 0f       	add	r24, r24
 5b4:	99 1f       	adc	r25, r25
 5b6:	0a 94       	dec	r0
 5b8:	e2 f7       	brpl	.-8      	; 0x5b2 <DIO_WRITE_LOW_NIBBLE+0x22>
 5ba:	8c 21       	and	r24, r12
 5bc:	9d 21       	and	r25, r13
 5be:	9c 01       	movw	r18, r24
 5c0:	0c 2e       	mov	r0, r28
 5c2:	02 c0       	rjmp	.+4      	; 0x5c8 <DIO_WRITE_LOW_NIBBLE+0x38>
 5c4:	35 95       	asr	r19
 5c6:	27 95       	ror	r18
 5c8:	0a 94       	dec	r0
 5ca:	e2 f7       	brpl	.-8      	; 0x5c4 <DIO_WRITE_LOW_NIBBLE+0x34>
 5cc:	a9 01       	movw	r20, r18
 5ce:	8f 2d       	mov	r24, r15
 5d0:	6c 2f       	mov	r22, r28
 5d2:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
 5d6:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_WRITE_LOW_NIBBLE(unsigned char portname,unsigned char value)
{
	unsigned char i;
	for(i=0;i<=3;i++)
 5d8:	c4 30       	cpi	r28, 0x04	; 4
 5da:	d1 05       	cpc	r29, r1
 5dc:	39 f7       	brne	.-50     	; 0x5ac <DIO_WRITE_LOW_NIBBLE+0x1c>
	{
		DIO_WRITE(portname,i,READ_BIT(value,i));
	}
}
 5de:	df 91       	pop	r29
 5e0:	cf 91       	pop	r28
 5e2:	1f 91       	pop	r17
 5e4:	0f 91       	pop	r16
 5e6:	ff 90       	pop	r15
 5e8:	df 90       	pop	r13
 5ea:	cf 90       	pop	r12
 5ec:	08 95       	ret

000005ee <DIO_WRITE_HIGH_NIBBLE>:

void DIO_WRITE_HIGH_NIBBLE(unsigned char portname,unsigned char value)
{
 5ee:	cf 92       	push	r12
 5f0:	df 92       	push	r13
 5f2:	ff 92       	push	r15
 5f4:	0f 93       	push	r16
 5f6:	1f 93       	push	r17
 5f8:	cf 93       	push	r28
 5fa:	df 93       	push	r29
 5fc:	f8 2e       	mov	r15, r24
 5fe:	c0 e0       	ldi	r28, 0x00	; 0
 600:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=4;i<=7;i++)
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
 602:	01 e0       	ldi	r16, 0x01	; 1
 604:	10 e0       	ldi	r17, 0x00	; 0
 606:	c6 2e       	mov	r12, r22
 608:	dd 24       	eor	r13, r13
	{
		DIO_WRITE(portname,i,READ_BIT(value,i));
	}
}

void DIO_WRITE_HIGH_NIBBLE(unsigned char portname,unsigned char value)
 60a:	6c 2f       	mov	r22, r28
 60c:	6c 5f       	subi	r22, 0xFC	; 252
{
	unsigned char i;
	for(i=4;i<=7;i++)
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
 60e:	c8 01       	movw	r24, r16
 610:	0c 2e       	mov	r0, r28
 612:	02 c0       	rjmp	.+4      	; 0x618 <DIO_WRITE_HIGH_NIBBLE+0x2a>
 614:	88 0f       	add	r24, r24
 616:	99 1f       	adc	r25, r25
 618:	0a 94       	dec	r0
 61a:	e2 f7       	brpl	.-8      	; 0x614 <DIO_WRITE_HIGH_NIBBLE+0x26>
 61c:	8c 21       	and	r24, r12
 61e:	9d 21       	and	r25, r13
 620:	9c 01       	movw	r18, r24
 622:	0c 2e       	mov	r0, r28
 624:	02 c0       	rjmp	.+4      	; 0x62a <DIO_WRITE_HIGH_NIBBLE+0x3c>
 626:	35 95       	asr	r19
 628:	27 95       	ror	r18
 62a:	0a 94       	dec	r0
 62c:	e2 f7       	brpl	.-8      	; 0x626 <DIO_WRITE_HIGH_NIBBLE+0x38>
 62e:	a9 01       	movw	r20, r18
 630:	8f 2d       	mov	r24, r15
 632:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
 636:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_WRITE_HIGH_NIBBLE(unsigned char portname,unsigned char value)
{
	unsigned char i;
	for(i=4;i<=7;i++)
 638:	c4 30       	cpi	r28, 0x04	; 4
 63a:	d1 05       	cpc	r29, r1
 63c:	31 f7       	brne	.-52     	; 0x60a <DIO_WRITE_HIGH_NIBBLE+0x1c>
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
	}
}
 63e:	df 91       	pop	r29
 640:	cf 91       	pop	r28
 642:	1f 91       	pop	r17
 644:	0f 91       	pop	r16
 646:	ff 90       	pop	r15
 648:	df 90       	pop	r13
 64a:	cf 90       	pop	r12
 64c:	08 95       	ret

0000064e <DIO_WRITE_NIBBLE>:

void DIO_WRITE_NIBBLE(unsigned char portname,unsigned char startpin,unsigned char value)
{
 64e:	cf 92       	push	r12
 650:	df 92       	push	r13
 652:	ef 92       	push	r14
 654:	ff 92       	push	r15
 656:	0f 93       	push	r16
 658:	1f 93       	push	r17
 65a:	cf 93       	push	r28
 65c:	df 93       	push	r29
 65e:	08 2f       	mov	r16, r24
 660:	16 2f       	mov	r17, r22
 662:	c0 e0       	ldi	r28, 0x00	; 0
 664:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
 666:	ee 24       	eor	r14, r14
 668:	ff 24       	eor	r15, r15
 66a:	e3 94       	inc	r14
 66c:	c4 2e       	mov	r12, r20
 66e:	dd 24       	eor	r13, r13
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
	}
}

void DIO_WRITE_NIBBLE(unsigned char portname,unsigned char startpin,unsigned char value)
 670:	6c 2f       	mov	r22, r28
 672:	61 0f       	add	r22, r17
{
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
 674:	c7 01       	movw	r24, r14
 676:	0c 2e       	mov	r0, r28
 678:	02 c0       	rjmp	.+4      	; 0x67e <DIO_WRITE_NIBBLE+0x30>
 67a:	88 0f       	add	r24, r24
 67c:	99 1f       	adc	r25, r25
 67e:	0a 94       	dec	r0
 680:	e2 f7       	brpl	.-8      	; 0x67a <DIO_WRITE_NIBBLE+0x2c>
 682:	8c 21       	and	r24, r12
 684:	9d 21       	and	r25, r13
 686:	9c 01       	movw	r18, r24
 688:	0c 2e       	mov	r0, r28
 68a:	02 c0       	rjmp	.+4      	; 0x690 <DIO_WRITE_NIBBLE+0x42>
 68c:	35 95       	asr	r19
 68e:	27 95       	ror	r18
 690:	0a 94       	dec	r0
 692:	e2 f7       	brpl	.-8      	; 0x68c <DIO_WRITE_NIBBLE+0x3e>
 694:	a9 01       	movw	r20, r18
 696:	80 2f       	mov	r24, r16
 698:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
 69c:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_WRITE_NIBBLE(unsigned char portname,unsigned char startpin,unsigned char value)
{
	unsigned char i;
	for(i=0;i<=3;i++)
 69e:	c4 30       	cpi	r28, 0x04	; 4
 6a0:	d1 05       	cpc	r29, r1
 6a2:	31 f7       	brne	.-52     	; 0x670 <DIO_WRITE_NIBBLE+0x22>
	{
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
		startpin++;
	}
}
 6a4:	df 91       	pop	r29
 6a6:	cf 91       	pop	r28
 6a8:	1f 91       	pop	r17
 6aa:	0f 91       	pop	r16
 6ac:	ff 90       	pop	r15
 6ae:	ef 90       	pop	r14
 6b0:	df 90       	pop	r13
 6b2:	cf 90       	pop	r12
 6b4:	08 95       	ret

000006b6 <DIO_SET_DIR_NIPPLE>:

void DIO_SET_DIR_NIPPLE(unsigned char portname,unsigned char startpin,unsigned char direction)
{
 6b6:	cf 92       	push	r12
 6b8:	df 92       	push	r13
 6ba:	ef 92       	push	r14
 6bc:	ff 92       	push	r15
 6be:	0f 93       	push	r16
 6c0:	1f 93       	push	r17
 6c2:	cf 93       	push	r28
 6c4:	df 93       	push	r29
 6c6:	08 2f       	mov	r16, r24
 6c8:	16 2f       	mov	r17, r22
 6ca:	c0 e0       	ldi	r28, 0x00	; 0
 6cc:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_SETPINDIR(portname,startpin,READ_BIT(direction,i));
 6ce:	ee 24       	eor	r14, r14
 6d0:	ff 24       	eor	r15, r15
 6d2:	e3 94       	inc	r14
 6d4:	c4 2e       	mov	r12, r20
 6d6:	dd 24       	eor	r13, r13
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
		startpin++;
	}
}

void DIO_SET_DIR_NIPPLE(unsigned char portname,unsigned char startpin,unsigned char direction)
 6d8:	6c 2f       	mov	r22, r28
 6da:	61 0f       	add	r22, r17
{
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_SETPINDIR(portname,startpin,READ_BIT(direction,i));
 6dc:	c7 01       	movw	r24, r14
 6de:	0c 2e       	mov	r0, r28
 6e0:	02 c0       	rjmp	.+4      	; 0x6e6 <DIO_SET_DIR_NIPPLE+0x30>
 6e2:	88 0f       	add	r24, r24
 6e4:	99 1f       	adc	r25, r25
 6e6:	0a 94       	dec	r0
 6e8:	e2 f7       	brpl	.-8      	; 0x6e2 <DIO_SET_DIR_NIPPLE+0x2c>
 6ea:	8c 21       	and	r24, r12
 6ec:	9d 21       	and	r25, r13
 6ee:	9c 01       	movw	r18, r24
 6f0:	0c 2e       	mov	r0, r28
 6f2:	02 c0       	rjmp	.+4      	; 0x6f8 <DIO_SET_DIR_NIPPLE+0x42>
 6f4:	35 95       	asr	r19
 6f6:	27 95       	ror	r18
 6f8:	0a 94       	dec	r0
 6fa:	e2 f7       	brpl	.-8      	; 0x6f4 <DIO_SET_DIR_NIPPLE+0x3e>
 6fc:	a9 01       	movw	r20, r18
 6fe:	80 2f       	mov	r24, r16
 700:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
 704:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_SET_DIR_NIPPLE(unsigned char portname,unsigned char startpin,unsigned char direction)
{
	unsigned char i;
	for(i=0;i<=3;i++)
 706:	c4 30       	cpi	r28, 0x04	; 4
 708:	d1 05       	cpc	r29, r1
 70a:	31 f7       	brne	.-52     	; 0x6d8 <DIO_SET_DIR_NIPPLE+0x22>
	{
		DIO_SETPINDIR(portname,startpin,READ_BIT(direction,i));
		startpin++;
	}	
}
 70c:	df 91       	pop	r29
 70e:	cf 91       	pop	r28
 710:	1f 91       	pop	r17
 712:	0f 91       	pop	r16
 714:	ff 90       	pop	r15
 716:	ef 90       	pop	r14
 718:	df 90       	pop	r13
 71a:	cf 90       	pop	r12
 71c:	08 95       	ret

0000071e <EEPROM_WRITE>:


void EEPROM_WRITE (unsigned short address , unsigned char data)
{
	//SET UP address register
	EEARL=(char)address;
 71e:	8e bb       	out	0x1e, r24	; 30
	EEARH=(char)(address>>8);
 720:	9f bb       	out	0x1f, r25	; 31
	//SET UP data register
	EEDR=data;
 722:	6d bb       	out	0x1d, r22	; 29
	//write logical 1 to EEMWE	
	SET_BIT(EECR,EEMWE);
 724:	e2 9a       	sbi	0x1c, 2	; 28
	//START EEPROM to write by setting EEWE by logical 1
	SET_BIT(EECR,EEWE);
 726:	e1 9a       	sbi	0x1c, 1	; 28
	//WAIT for compilation of write process
	while(READ_BIT(EECR,EEWE) == 1);
 728:	e1 99       	sbic	0x1c, 1	; 28
 72a:	fe cf       	rjmp	.-4      	; 0x728 <EEPROM_WRITE+0xa>
}
 72c:	08 95       	ret

0000072e <EEPROM_READ>:

unsigned char EEPROM_READ (unsigned short address)
{
	//SET UP address register
	EEARL=(char)address;
 72e:	8e bb       	out	0x1e, r24	; 30
	EEARH=(char)(address>>8);
 730:	9f bb       	out	0x1f, r25	; 31
	//write logical 1 to EERE
	SET_BIT(EECR,EERE);
 732:	e0 9a       	sbi	0x1c, 0	; 28
	//return data from data register
	return EEDR;
 734:	8d b3       	in	r24, 0x1d	; 29
 736:	08 95       	ret

00000738 <keybad_init>:
		DIO_SETPINDIR(keypad_port,i,1);
		DIO_SETPINDIR(keypad_port,i+4,0);
		DIO_CONNECT_PULLUP(keypad_port,i+4,1);
	}*/
	
	DIO_SETPINDIR(keypad_port,0,1);
 738:	84 e6       	ldi	r24, 0x64	; 100
 73a:	60 e0       	ldi	r22, 0x00	; 0
 73c:	41 e0       	ldi	r20, 0x01	; 1
 73e:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(keypad_port,1,1);
 742:	84 e6       	ldi	r24, 0x64	; 100
 744:	61 e0       	ldi	r22, 0x01	; 1
 746:	41 e0       	ldi	r20, 0x01	; 1
 748:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(keypad_port,2,1);
 74c:	84 e6       	ldi	r24, 0x64	; 100
 74e:	62 e0       	ldi	r22, 0x02	; 2
 750:	41 e0       	ldi	r20, 0x01	; 1
 752:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(keypad_port,3,1);
 756:	84 e6       	ldi	r24, 0x64	; 100
 758:	63 e0       	ldi	r22, 0x03	; 3
 75a:	41 e0       	ldi	r20, 0x01	; 1
 75c:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(keypad_port,4,0);
 760:	84 e6       	ldi	r24, 0x64	; 100
 762:	64 e0       	ldi	r22, 0x04	; 4
 764:	40 e0       	ldi	r20, 0x00	; 0
 766:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(keypad_port,5,0);
 76a:	84 e6       	ldi	r24, 0x64	; 100
 76c:	65 e0       	ldi	r22, 0x05	; 5
 76e:	40 e0       	ldi	r20, 0x00	; 0
 770:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(keypad_port,6,0);
 774:	84 e6       	ldi	r24, 0x64	; 100
 776:	66 e0       	ldi	r22, 0x06	; 6
 778:	40 e0       	ldi	r20, 0x00	; 0
 77a:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(keypad_port,7,0);
 77e:	84 e6       	ldi	r24, 0x64	; 100
 780:	67 e0       	ldi	r22, 0x07	; 7
 782:	40 e0       	ldi	r20, 0x00	; 0
 784:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_CONNECT_PULLUP(keypad_port,4,1);
 788:	84 e6       	ldi	r24, 0x64	; 100
 78a:	64 e0       	ldi	r22, 0x04	; 4
 78c:	41 e0       	ldi	r20, 0x01	; 1
 78e:	0e 94 c5 02 	call	0x58a	; 0x58a <DIO_CONNECT_PULLUP>
	DIO_CONNECT_PULLUP(keypad_port,5,1);
 792:	84 e6       	ldi	r24, 0x64	; 100
 794:	65 e0       	ldi	r22, 0x05	; 5
 796:	41 e0       	ldi	r20, 0x01	; 1
 798:	0e 94 c5 02 	call	0x58a	; 0x58a <DIO_CONNECT_PULLUP>
	DIO_CONNECT_PULLUP(keypad_port,6,1);
 79c:	84 e6       	ldi	r24, 0x64	; 100
 79e:	66 e0       	ldi	r22, 0x06	; 6
 7a0:	41 e0       	ldi	r20, 0x01	; 1
 7a2:	0e 94 c5 02 	call	0x58a	; 0x58a <DIO_CONNECT_PULLUP>
	DIO_CONNECT_PULLUP(keypad_port,7,1);	
 7a6:	84 e6       	ldi	r24, 0x64	; 100
 7a8:	67 e0       	ldi	r22, 0x07	; 7
 7aa:	41 e0       	ldi	r20, 0x01	; 1
 7ac:	0e 94 c5 02 	call	0x58a	; 0x58a <DIO_CONNECT_PULLUP>
	
}
 7b0:	08 95       	ret

000007b2 <keybad_check_press>:

 char keybad_check_press()
{
 7b2:	0f 93       	push	r16
 7b4:	1f 93       	push	r17
 7b6:	cf 93       	push	r28
 7b8:	df 93       	push	r29
 7ba:	cd b7       	in	r28, 0x3d	; 61
 7bc:	de b7       	in	r29, 0x3e	; 62
 7be:	60 97       	sbiw	r28, 0x10	; 16
 7c0:	0f b6       	in	r0, 0x3f	; 63
 7c2:	f8 94       	cli
 7c4:	de bf       	out	0x3e, r29	; 62
 7c6:	0f be       	out	0x3f, r0	; 63
 7c8:	cd bf       	out	0x3d, r28	; 61
	//hardware
	//char arr[4][4]={{'1','2','3','+'},{'4','5','6','-'},{'7','8','9','/'},{'*','0','#','='}};
	//protus
	char arr[4][4]={{'7','8','9','/'},{'4','5','6','*'},{'1','2','3','-'},{'A','0','=','+'}};
 7ca:	de 01       	movw	r26, r28
 7cc:	11 96       	adiw	r26, 0x01	; 1
 7ce:	e0 e6       	ldi	r30, 0x60	; 96
 7d0:	f0 e0       	ldi	r31, 0x00	; 0
 7d2:	80 e1       	ldi	r24, 0x10	; 16
 7d4:	01 90       	ld	r0, Z+
 7d6:	0d 92       	st	X+, r0
 7d8:	81 50       	subi	r24, 0x01	; 1
 7da:	e1 f7       	brne	.-8      	; 0x7d4 <keybad_check_press+0x22>
	unsigned char row,coloumn,x;
	unsigned char return_val=unpressed;
	for(row=0;row<4;row++)
 7dc:	00 e0       	ldi	r16, 0x00	; 0
	{
		DIO_WRITE(keypad_port,0,1);
 7de:	84 e6       	ldi	r24, 0x64	; 100
 7e0:	60 e0       	ldi	r22, 0x00	; 0
 7e2:	41 e0       	ldi	r20, 0x01	; 1
 7e4:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
		DIO_WRITE(keypad_port,1,1);
 7e8:	84 e6       	ldi	r24, 0x64	; 100
 7ea:	61 e0       	ldi	r22, 0x01	; 1
 7ec:	41 e0       	ldi	r20, 0x01	; 1
 7ee:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
		DIO_WRITE(keypad_port,2,1);
 7f2:	84 e6       	ldi	r24, 0x64	; 100
 7f4:	62 e0       	ldi	r22, 0x02	; 2
 7f6:	41 e0       	ldi	r20, 0x01	; 1
 7f8:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
		DIO_WRITE(keypad_port,3,1);
 7fc:	84 e6       	ldi	r24, 0x64	; 100
 7fe:	63 e0       	ldi	r22, 0x03	; 3
 800:	41 e0       	ldi	r20, 0x01	; 1
 802:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
		DIO_WRITE(keypad_port,row,0);
 806:	84 e6       	ldi	r24, 0x64	; 100
 808:	60 2f       	mov	r22, r16
 80a:	40 e0       	ldi	r20, 0x00	; 0
 80c:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
		for(coloumn=0;coloumn<4;coloumn++)
 810:	10 e0       	ldi	r17, 0x00	; 0
		{
			x=DIO_readpin(keypad_port,(coloumn+4));
 812:	61 2f       	mov	r22, r17
 814:	6c 5f       	subi	r22, 0xFC	; 252
 816:	84 e6       	ldi	r24, 0x64	; 100
 818:	0e 94 da 01 	call	0x3b4	; 0x3b4 <DIO_readpin>
			if(x == 0)
 81c:	88 23       	and	r24, r24
 81e:	61 f4       	brne	.+24     	; 0x838 <keybad_check_press+0x86>
			{
				return_val=arr[row][coloumn];
 820:	e0 2f       	mov	r30, r16
 822:	f0 e0       	ldi	r31, 0x00	; 0
 824:	ee 0f       	add	r30, r30
 826:	ff 1f       	adc	r31, r31
 828:	ee 0f       	add	r30, r30
 82a:	ff 1f       	adc	r31, r31
 82c:	e1 0f       	add	r30, r17
 82e:	f1 1d       	adc	r31, r1
 830:	ec 0f       	add	r30, r28
 832:	fd 1f       	adc	r31, r29
 834:	81 81       	ldd	r24, Z+1	; 0x01
 836:	04 c0       	rjmp	.+8      	; 0x840 <keybad_check_press+0x8e>
		DIO_WRITE(keypad_port,0,1);
		DIO_WRITE(keypad_port,1,1);
		DIO_WRITE(keypad_port,2,1);
		DIO_WRITE(keypad_port,3,1);
		DIO_WRITE(keypad_port,row,0);
		for(coloumn=0;coloumn<4;coloumn++)
 838:	1f 5f       	subi	r17, 0xFF	; 255
 83a:	14 30       	cpi	r17, 0x04	; 4
 83c:	51 f7       	brne	.-44     	; 0x812 <keybad_check_press+0x60>
 83e:	0b c0       	rjmp	.+22     	; 0x856 <keybad_check_press+0xa4>
		{
			break;
		}
	}
	return return_val;	
 840:	60 96       	adiw	r28, 0x10	; 16
 842:	0f b6       	in	r0, 0x3f	; 63
 844:	f8 94       	cli
 846:	de bf       	out	0x3e, r29	; 62
 848:	0f be       	out	0x3f, r0	; 63
 84a:	cd bf       	out	0x3d, r28	; 61
 84c:	df 91       	pop	r29
 84e:	cf 91       	pop	r28
 850:	1f 91       	pop	r17
 852:	0f 91       	pop	r16
 854:	08 95       	ret
	//char arr[4][4]={{'1','2','3','+'},{'4','5','6','-'},{'7','8','9','/'},{'*','0','#','='}};
	//protus
	char arr[4][4]={{'7','8','9','/'},{'4','5','6','*'},{'1','2','3','-'},{'A','0','=','+'}};
	unsigned char row,coloumn,x;
	unsigned char return_val=unpressed;
	for(row=0;row<4;row++)
 856:	0f 5f       	subi	r16, 0xFF	; 255
 858:	04 30       	cpi	r16, 0x04	; 4
 85a:	09 f6       	brne	.-126    	; 0x7de <keybad_check_press+0x2c>
 85c:	8f ef       	ldi	r24, 0xFF	; 255
 85e:	f0 cf       	rjmp	.-32     	; 0x840 <keybad_check_press+0x8e>

00000860 <enable>:
		_delay_ms(1);
	}
}	
void enable()
{
	DIO_WRITE(port_control,EN,1);
 860:	81 e4       	ldi	r24, 0x41	; 65
 862:	64 e0       	ldi	r22, 0x04	; 4
 864:	41 e0       	ldi	r20, 0x01	; 1
 866:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 86a:	8f e9       	ldi	r24, 0x9F	; 159
 86c:	9f e0       	ldi	r25, 0x0F	; 15
 86e:	01 97       	sbiw	r24, 0x01	; 1
 870:	f1 f7       	brne	.-4      	; 0x86e <enable+0xe>
 872:	00 c0       	rjmp	.+0      	; 0x874 <enable+0x14>
 874:	00 00       	nop
	_delay_ms(2);
	DIO_WRITE(port_control,EN,0);
 876:	81 e4       	ldi	r24, 0x41	; 65
 878:	64 e0       	ldi	r22, 0x04	; 4
 87a:	40 e0       	ldi	r20, 0x00	; 0
 87c:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
 880:	8f e9       	ldi	r24, 0x9F	; 159
 882:	9f e0       	ldi	r25, 0x0F	; 15
 884:	01 97       	sbiw	r24, 0x01	; 1
 886:	f1 f7       	brne	.-4      	; 0x884 <enable+0x24>
 888:	00 c0       	rjmp	.+0      	; 0x88a <enable+0x2a>
 88a:	00 00       	nop
	_delay_ms(2);
 88c:	08 95       	ret

0000088e <LCD_SEND_CMD>:
		
	#endif
}

void LCD_SEND_CMD (unsigned char cmd)
{
 88e:	cf 93       	push	r28
 890:	c8 2f       	mov	r28, r24
	DIO_WRITE_HIGH_NIBBLE(port_data,cmd>>4);
	enable();
	DIO_WRITE_HIGH_NIBBLE(port_data,cmd);
	enable();
	#elif defined LOW_NIPPLE
	DIO_WRITE(port_control,RS,0);
 892:	81 e4       	ldi	r24, 0x41	; 65
 894:	66 e0       	ldi	r22, 0x06	; 6
 896:	40 e0       	ldi	r20, 0x00	; 0
 898:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
	DIO_WRITE_LOW_NIBBLE(port_data,cmd>>4);
 89c:	6c 2f       	mov	r22, r28
 89e:	62 95       	swap	r22
 8a0:	6f 70       	andi	r22, 0x0F	; 15
 8a2:	81 e4       	ldi	r24, 0x41	; 65
 8a4:	0e 94 c8 02 	call	0x590	; 0x590 <DIO_WRITE_LOW_NIBBLE>
	enable();
 8a8:	0e 94 30 04 	call	0x860	; 0x860 <enable>
	DIO_WRITE_LOW_NIBBLE(port_data,cmd);
 8ac:	81 e4       	ldi	r24, 0x41	; 65
 8ae:	6c 2f       	mov	r22, r28
 8b0:	0e 94 c8 02 	call	0x590	; 0x590 <DIO_WRITE_LOW_NIBBLE>
	enable();
 8b4:	0e 94 30 04 	call	0x860	; 0x860 <enable>
	enable();
	_delay_ms(1);  //write this and if the cmd is clear screen or return home write after it delay 10 ms or do not write it in the function and after calling this function in main make a delay
	#endif
	#endif

}
 8b8:	cf 91       	pop	r28
 8ba:	08 95       	ret

000008bc <lCD_MOVE_CURSOR>:
}

void lCD_MOVE_CURSOR (unsigned char row,unsigned char column)
{
	char cmd;
	if(row<1 || row>2 || column<1 || column>16)  // any invalid case
 8bc:	98 2f       	mov	r25, r24
 8be:	91 50       	subi	r25, 0x01	; 1
 8c0:	92 30       	cpi	r25, 0x02	; 2
 8c2:	60 f4       	brcc	.+24     	; 0x8dc <lCD_MOVE_CURSOR+0x20>
 8c4:	66 23       	and	r22, r22
 8c6:	61 f0       	breq	.+24     	; 0x8e0 <lCD_MOVE_CURSOR+0x24>
 8c8:	61 31       	cpi	r22, 0x11	; 17
 8ca:	60 f4       	brcc	.+24     	; 0x8e4 <lCD_MOVE_CURSOR+0x28>
	{
		cmd=0X80;
	}
	else if(row == 1)
 8cc:	81 30       	cpi	r24, 0x01	; 1
 8ce:	19 f4       	brne	.+6      	; 0x8d6 <lCD_MOVE_CURSOR+0x1a>
	{
		cmd=0X80+column-1;
 8d0:	86 2f       	mov	r24, r22
 8d2:	81 58       	subi	r24, 0x81	; 129
 8d4:	08 c0       	rjmp	.+16     	; 0x8e6 <lCD_MOVE_CURSOR+0x2a>
	}
	else
	{
		cmd=0XC0+column-1;
 8d6:	86 2f       	mov	r24, r22
 8d8:	81 54       	subi	r24, 0x41	; 65
 8da:	05 c0       	rjmp	.+10     	; 0x8e6 <lCD_MOVE_CURSOR+0x2a>
void lCD_MOVE_CURSOR (unsigned char row,unsigned char column)
{
	char cmd;
	if(row<1 || row>2 || column<1 || column>16)  // any invalid case
	{
		cmd=0X80;
 8dc:	80 e8       	ldi	r24, 0x80	; 128
 8de:	03 c0       	rjmp	.+6      	; 0x8e6 <lCD_MOVE_CURSOR+0x2a>
 8e0:	80 e8       	ldi	r24, 0x80	; 128
 8e2:	01 c0       	rjmp	.+2      	; 0x8e6 <lCD_MOVE_CURSOR+0x2a>
 8e4:	80 e8       	ldi	r24, 0x80	; 128
	}
	else
	{
		cmd=0XC0+column-1;
	}
	LCD_SEND_CMD(cmd);
 8e6:	0e 94 47 04 	call	0x88e	; 0x88e <LCD_SEND_CMD>
}
 8ea:	08 95       	ret

000008ec <LCD_Return_home>:
	_delay_ms(10);
}

void LCD_Return_home()
{
	LCD_SEND_CMD(Return_Home);
 8ec:	82 e0       	ldi	r24, 0x02	; 2
 8ee:	0e 94 47 04 	call	0x88e	; 0x88e <LCD_SEND_CMD>
 8f2:	8f e1       	ldi	r24, 0x1F	; 31
 8f4:	9e e4       	ldi	r25, 0x4E	; 78
 8f6:	01 97       	sbiw	r24, 0x01	; 1
 8f8:	f1 f7       	brne	.-4      	; 0x8f6 <LCD_Return_home+0xa>
 8fa:	00 c0       	rjmp	.+0      	; 0x8fc <LCD_Return_home+0x10>
 8fc:	00 00       	nop
	_delay_ms(10);
}
 8fe:	08 95       	ret

00000900 <LCD_CLEAR_SCREEN>:

}

void LCD_CLEAR_SCREEN()
{
	LCD_SEND_CMD(clear_screen);
 900:	81 e0       	ldi	r24, 0x01	; 1
 902:	0e 94 47 04 	call	0x88e	; 0x88e <LCD_SEND_CMD>
 906:	8f e1       	ldi	r24, 0x1F	; 31
 908:	9e e4       	ldi	r25, 0x4E	; 78
 90a:	01 97       	sbiw	r24, 0x01	; 1
 90c:	f1 f7       	brne	.-4      	; 0x90a <LCD_CLEAR_SCREEN+0xa>
 90e:	00 c0       	rjmp	.+0      	; 0x910 <LCD_CLEAR_SCREEN+0x10>
 910:	00 00       	nop
	_delay_ms(10);
}
 912:	08 95       	ret

00000914 <LCD_INIT>:
 914:	8f ef       	ldi	r24, 0xFF	; 255
 916:	91 ee       	ldi	r25, 0xE1	; 225
 918:	a4 e0       	ldi	r26, 0x04	; 4
 91a:	81 50       	subi	r24, 0x01	; 1
 91c:	90 40       	sbci	r25, 0x00	; 0
 91e:	a0 40       	sbci	r26, 0x00	; 0
 920:	e1 f7       	brne	.-8      	; 0x91a <LCD_INIT+0x6>
 922:	00 c0       	rjmp	.+0      	; 0x924 <LCD_INIT+0x10>
 924:	00 00       	nop
	DIO_SETPINDIR(port_data,4,1);
	DIO_SETPINDIR(port_data,5,1);
	DIO_SETPINDIR(port_data,6,1);
	DIO_SETPINDIR(port_data,7,1);
	#elif defined LOW_NIPPLE
	DIO_SETPINDIR(port_data,0,1);
 926:	81 e4       	ldi	r24, 0x41	; 65
 928:	60 e0       	ldi	r22, 0x00	; 0
 92a:	41 e0       	ldi	r20, 0x01	; 1
 92c:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_data,1,1);
 930:	81 e4       	ldi	r24, 0x41	; 65
 932:	61 e0       	ldi	r22, 0x01	; 1
 934:	41 e0       	ldi	r20, 0x01	; 1
 936:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_data,2,1);
 93a:	81 e4       	ldi	r24, 0x41	; 65
 93c:	62 e0       	ldi	r22, 0x02	; 2
 93e:	41 e0       	ldi	r20, 0x01	; 1
 940:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_data,3,1);
 944:	81 e4       	ldi	r24, 0x41	; 65
 946:	63 e0       	ldi	r22, 0x03	; 3
 948:	41 e0       	ldi	r20, 0x01	; 1
 94a:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	#else
	DIO_SET_DIR_NIPPLE(port_data,start_pin,0xFF);   //write 0 for low nipple ,write  4 for high nipple 
	#endif
	DIO_SETPINDIR(port_control,RS,1);
 94e:	81 e4       	ldi	r24, 0x41	; 65
 950:	66 e0       	ldi	r22, 0x06	; 6
 952:	41 e0       	ldi	r20, 0x01	; 1
 954:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_control,EN,1);
 958:	81 e4       	ldi	r24, 0x41	; 65
 95a:	64 e0       	ldi	r22, 0x04	; 4
 95c:	41 e0       	ldi	r20, 0x01	; 1
 95e:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_control,R_W,1);
 962:	81 e4       	ldi	r24, 0x41	; 65
 964:	65 e0       	ldi	r22, 0x05	; 5
 966:	41 e0       	ldi	r20, 0x01	; 1
 968:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
	DIO_WRITE(port_control,R_W,0);
 96c:	81 e4       	ldi	r24, 0x41	; 65
 96e:	65 e0       	ldi	r22, 0x05	; 5
 970:	40 e0       	ldi	r20, 0x00	; 0
 972:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
	LCD_Return_home();
 976:	0e 94 76 04 	call	0x8ec	; 0x8ec <LCD_Return_home>
	LCD_SEND_CMD(four_bit);
 97a:	88 e2       	ldi	r24, 0x28	; 40
 97c:	0e 94 47 04 	call	0x88e	; 0x88e <LCD_SEND_CMD>
	LCD_SEND_CMD(Display_on_Cursor_on);
 980:	8e e0       	ldi	r24, 0x0E	; 14
 982:	0e 94 47 04 	call	0x88e	; 0x88e <LCD_SEND_CMD>
	LCD_CLEAR_SCREEN();
 986:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
	LCD_SEND_CMD(Entry_Mode);
 98a:	86 e0       	ldi	r24, 0x06	; 6
 98c:	0e 94 47 04 	call	0x88e	; 0x88e <LCD_SEND_CMD>
	#endif	
}
 990:	08 95       	ret

00000992 <LCD_SEND_CHAR>:

void LCD_SEND_CHAR (unsigned char data)
{
 992:	cf 93       	push	r28
 994:	c8 2f       	mov	r28, r24
	DIO_WRITE_HIGH_NIBBLE(port_data,data>>4);
	enable();
	DIO_WRITE_HIGH_NIBBLE(port_data,data);
	enable();
	#elif defined LOW_NIPPLE
	DIO_WRITE(port_control,RS,1);
 996:	81 e4       	ldi	r24, 0x41	; 65
 998:	66 e0       	ldi	r22, 0x06	; 6
 99a:	41 e0       	ldi	r20, 0x01	; 1
 99c:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
	DIO_WRITE_LOW_NIBBLE(port_data,data>>4);
 9a0:	6c 2f       	mov	r22, r28
 9a2:	62 95       	swap	r22
 9a4:	6f 70       	andi	r22, 0x0F	; 15
 9a6:	81 e4       	ldi	r24, 0x41	; 65
 9a8:	0e 94 c8 02 	call	0x590	; 0x590 <DIO_WRITE_LOW_NIBBLE>
	enable();
 9ac:	0e 94 30 04 	call	0x860	; 0x860 <enable>
	DIO_WRITE_LOW_NIBBLE(port_data,data);
 9b0:	81 e4       	ldi	r24, 0x41	; 65
 9b2:	6c 2f       	mov	r22, r28
 9b4:	0e 94 c8 02 	call	0x590	; 0x590 <DIO_WRITE_LOW_NIBBLE>
	enable();
 9b8:	0e 94 30 04 	call	0x860	; 0x860 <enable>
	DIO_WRITE_NIBBLE(port_data,start_pin,data);
	enable();
	#endif
		
	#endif
}
 9bc:	cf 91       	pop	r28
 9be:	08 95       	ret

000009c0 <LCD_SEND_STRING>:
	}
	LCD_SEND_CMD(cmd);
}

void LCD_SEND_STRING (const char* ptr)
{
 9c0:	cf 93       	push	r28
 9c2:	df 93       	push	r29
 9c4:	ec 01       	movw	r28, r24
	while((*ptr) != '\0')
 9c6:	88 81       	ld	r24, Y
 9c8:	88 23       	and	r24, r24
 9ca:	61 f0       	breq	.+24     	; 0x9e4 <LCD_SEND_STRING+0x24>
		cmd=0XC0+column-1;
	}
	LCD_SEND_CMD(cmd);
}

void LCD_SEND_STRING (const char* ptr)
 9cc:	21 96       	adiw	r28, 0x01	; 1
{
	while((*ptr) != '\0')
	{
		LCD_SEND_CHAR(*ptr);
 9ce:	0e 94 c9 04 	call	0x992	; 0x992 <LCD_SEND_CHAR>
 9d2:	8f ec       	ldi	r24, 0xCF	; 207
 9d4:	97 e0       	ldi	r25, 0x07	; 7
 9d6:	01 97       	sbiw	r24, 0x01	; 1
 9d8:	f1 f7       	brne	.-4      	; 0x9d6 <LCD_SEND_STRING+0x16>
 9da:	00 c0       	rjmp	.+0      	; 0x9dc <LCD_SEND_STRING+0x1c>
 9dc:	00 00       	nop
	LCD_SEND_CMD(cmd);
}

void LCD_SEND_STRING (const char* ptr)
{
	while((*ptr) != '\0')
 9de:	89 91       	ld	r24, Y+
 9e0:	88 23       	and	r24, r24
 9e2:	a9 f7       	brne	.-22     	; 0x9ce <LCD_SEND_STRING+0xe>
	{
		LCD_SEND_CHAR(*ptr);
		ptr++;
		_delay_ms(1);
	}
}	
 9e4:	df 91       	pop	r29
 9e6:	cf 91       	pop	r28
 9e8:	08 95       	ret

000009ea <LED_INIT>:
 */ 
#include "DIO.h"
//make the led in this port output pin
void LED_INIT(unsigned char portname,unsigned char pinnumber)
{
	DIO_SETPINDIR(portname,pinnumber,1);
 9ea:	41 e0       	ldi	r20, 0x01	; 1
 9ec:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
}
 9f0:	08 95       	ret

000009f2 <LED_ON>:
//write on this on logic high
void LED_ON(unsigned char portname,unsigned char pinnumber)
{
	DIO_WRITE(portname,pinnumber,1);
 9f2:	41 e0       	ldi	r20, 0x01	; 1
 9f4:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
}
 9f8:	08 95       	ret

000009fa <LED_OFF>:
//write on this on logic low
void LED_OFF(unsigned char portname,unsigned char pinnumber)
{
	DIO_WRITE(portname,pinnumber,0);
 9fa:	40 e0       	ldi	r20, 0x00	; 0
 9fc:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DIO_WRITE>
}
 a00:	08 95       	ret

00000a02 <LED_TOGGLE>:
//TOGGLE the output of the led
void LED_TOGGLE(unsigned char portname,unsigned char pinnumber)
{
	DIO_togglepin(portname,pinnumber);
 a02:	0e 94 8d 01 	call	0x31a	; 0x31a <DIO_togglepin>
}
 a06:	08 95       	ret

00000a08 <LED_READ_STATUS>:
unsigned char LED_READ_STATUS(unsigned char portname,unsigned char pinnumber)
{
	return DIO_readpin(portname,pinnumber);
 a08:	0e 94 da 01 	call	0x3b4	; 0x3b4 <DIO_readpin>
}
 a0c:	08 95       	ret

00000a0e <LED_set_port_direction>:
void LED_set_port_direction(unsigned char portname,unsigned char direction)
{
	DIO_set_port_direction(portname,direction);
 a0e:	0e 94 3f 02 	call	0x47e	; 0x47e <DIO_set_port_direction>
}
 a12:	08 95       	ret

00000a14 <LED_toggle_port>:
void LED_toggle_port(unsigned char portname)
{
	DIO_toggle_port(portname);
 a14:	0e 94 9e 02 	call	0x53c	; 0x53c <DIO_toggle_port>
 a18:	08 95       	ret

00000a1a <main>:
#define EEPROM_PASSWORD_LOCATION2 0X21
#define EEPROM_PASSWORD_LOCATION3 0X22
#define EEPROM_PASSWORD_LOCATION4 0X23
unsigned char x,i,arr[4],max_trials=3,counter,flag=0;
int main(void)
{
 a1a:	4f 92       	push	r4
 a1c:	5f 92       	push	r5
 a1e:	6f 92       	push	r6
 a20:	7f 92       	push	r7
 a22:	8f 92       	push	r8
 a24:	9f 92       	push	r9
 a26:	af 92       	push	r10
 a28:	bf 92       	push	r11
 a2a:	cf 92       	push	r12
 a2c:	df 92       	push	r13
 a2e:	ef 92       	push	r14
 a30:	ff 92       	push	r15
 a32:	0f 93       	push	r16
 a34:	1f 93       	push	r17
 a36:	cf 93       	push	r28
 a38:	df 93       	push	r29
	
	LCD_INIT();
 a3a:	0e 94 8a 04 	call	0x914	; 0x914 <LCD_INIT>
	keybad_init();
 a3e:	0e 94 9c 03 	call	0x738	; 0x738 <keybad_init>
	LED_INIT('b',0);
 a42:	82 e6       	ldi	r24, 0x62	; 98
 a44:	60 e0       	ldi	r22, 0x00	; 0
 a46:	0e 94 f5 04 	call	0x9ea	; 0x9ea <LED_INIT>
	LED_INIT('b',1);
 a4a:	82 e6       	ldi	r24, 0x62	; 98
 a4c:	61 e0       	ldi	r22, 0x01	; 1
 a4e:	0e 94 f5 04 	call	0x9ea	; 0x9ea <LED_INIT>

	if(EEPROM_READ(EEPROM_STATUS) != 1)
 a52:	89 e1       	ldi	r24, 0x19	; 25
 a54:	90 e0       	ldi	r25, 0x00	; 0
 a56:	0e 94 97 03 	call	0x72e	; 0x72e <EEPROM_READ>
 a5a:	81 30       	cpi	r24, 0x01	; 1
 a5c:	09 f4       	brne	.+2      	; 0xa60 <main+0x46>
 a5e:	72 c0       	rjmp	.+228    	; 0xb44 <main+0x12a>
	{
	lCD_MOVE_CURSOR(1,3);
 a60:	81 e0       	ldi	r24, 0x01	; 1
 a62:	63 e0       	ldi	r22, 0x03	; 3
 a64:	0e 94 5e 04 	call	0x8bc	; 0x8bc <lCD_MOVE_CURSOR>
	LCD_SEND_STRING("SAFE PROJECT");
 a68:	80 e7       	ldi	r24, 0x70	; 112
 a6a:	90 e0       	ldi	r25, 0x00	; 0
 a6c:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
 a70:	8f ef       	ldi	r24, 0xFF	; 255
 a72:	99 e6       	ldi	r25, 0x69	; 105
 a74:	a8 e1       	ldi	r26, 0x18	; 24
 a76:	81 50       	subi	r24, 0x01	; 1
 a78:	90 40       	sbci	r25, 0x00	; 0
 a7a:	a0 40       	sbci	r26, 0x00	; 0
 a7c:	e1 f7       	brne	.-8      	; 0xa76 <main+0x5c>
 a7e:	00 c0       	rjmp	.+0      	; 0xa80 <main+0x66>
 a80:	00 00       	nop
	_delay_ms(1000);
	LCD_CLEAR_SCREEN();
 a82:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
	LCD_SEND_STRING("Set the password:");
 a86:	8d e7       	ldi	r24, 0x7D	; 125
 a88:	90 e0       	ldi	r25, 0x00	; 0
 a8a:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
	lCD_MOVE_CURSOR(2,1);
 a8e:	82 e0       	ldi	r24, 0x02	; 2
 a90:	61 e0       	ldi	r22, 0x01	; 1
 a92:	0e 94 5e 04 	call	0x8bc	; 0x8bc <lCD_MOVE_CURSOR>
	
	while(counter<4)
 a96:	80 91 85 01 	lds	r24, 0x0185
 a9a:	84 30       	cpi	r24, 0x04	; 4
 a9c:	e0 f5       	brcc	.+120    	; 0xb16 <main+0xfc>
	{
		x=keybad_check_press();
 a9e:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <keybad_check_press>
 aa2:	80 93 84 01 	sts	0x0184, r24
		if(x != 0xff )
 aa6:	8f 3f       	cpi	r24, 0xFF	; 255
 aa8:	49 f1       	breq	.+82     	; 0xafc <main+0xe2>
 aaa:	8f e7       	ldi	r24, 0x7F	; 127
 aac:	98 e3       	ldi	r25, 0x38	; 56
 aae:	a1 e0       	ldi	r26, 0x01	; 1
 ab0:	81 50       	subi	r24, 0x01	; 1
 ab2:	90 40       	sbci	r25, 0x00	; 0
 ab4:	a0 40       	sbci	r26, 0x00	; 0
 ab6:	e1 f7       	brne	.-8      	; 0xab0 <main+0x96>
 ab8:	00 c0       	rjmp	.+0      	; 0xaba <main+0xa0>
 aba:	00 00       	nop
		{
				_delay_ms(50);
				LCD_SEND_CHAR(x);
 abc:	80 91 84 01 	lds	r24, 0x0184
 ac0:	0e 94 c9 04 	call	0x992	; 0x992 <LCD_SEND_CHAR>
 ac4:	8f ef       	ldi	r24, 0xFF	; 255
 ac6:	91 ee       	ldi	r25, 0xE1	; 225
 ac8:	a4 e0       	ldi	r26, 0x04	; 4
 aca:	81 50       	subi	r24, 0x01	; 1
 acc:	90 40       	sbci	r25, 0x00	; 0
 ace:	a0 40       	sbci	r26, 0x00	; 0
 ad0:	e1 f7       	brne	.-8      	; 0xaca <main+0xb0>
 ad2:	00 c0       	rjmp	.+0      	; 0xad4 <main+0xba>
 ad4:	00 00       	nop
				_delay_ms(200);
				LCD_SEND_CMD(0X10);
 ad6:	80 e1       	ldi	r24, 0x10	; 16
 ad8:	0e 94 47 04 	call	0x88e	; 0x88e <LCD_SEND_CMD>
				LCD_SEND_CHAR(0X2A);
 adc:	8a e2       	ldi	r24, 0x2A	; 42
 ade:	0e 94 c9 04 	call	0x992	; 0x992 <LCD_SEND_CHAR>
				EEPROM_WRITE(EEPROM_PASSWORD_LOCATION1+counter,x);
 ae2:	80 91 85 01 	lds	r24, 0x0185
 ae6:	90 e0       	ldi	r25, 0x00	; 0
 ae8:	80 96       	adiw	r24, 0x20	; 32
 aea:	60 91 84 01 	lds	r22, 0x0184
 aee:	0e 94 8f 03 	call	0x71e	; 0x71e <EEPROM_WRITE>
				counter++;
 af2:	80 91 85 01 	lds	r24, 0x0185
 af6:	8f 5f       	subi	r24, 0xFF	; 255
 af8:	80 93 85 01 	sts	0x0185, r24
 afc:	8f e7       	ldi	r24, 0x7F	; 127
 afe:	99 ea       	ldi	r25, 0xA9	; 169
 b00:	a3 e0       	ldi	r26, 0x03	; 3
 b02:	81 50       	subi	r24, 0x01	; 1
 b04:	90 40       	sbci	r25, 0x00	; 0
 b06:	a0 40       	sbci	r26, 0x00	; 0
 b08:	e1 f7       	brne	.-8      	; 0xb02 <main+0xe8>
 b0a:	00 c0       	rjmp	.+0      	; 0xb0c <main+0xf2>
 b0c:	00 00       	nop
	_delay_ms(1000);
	LCD_CLEAR_SCREEN();
	LCD_SEND_STRING("Set the password:");
	lCD_MOVE_CURSOR(2,1);
	
	while(counter<4)
 b0e:	80 91 85 01 	lds	r24, 0x0185
 b12:	84 30       	cpi	r24, 0x04	; 4
 b14:	20 f2       	brcs	.-120    	; 0xa9e <main+0x84>
				EEPROM_WRITE(EEPROM_PASSWORD_LOCATION1+counter,x);
				counter++;
		}
		_delay_ms(150);	
	}
	EEPROM_WRITE(EEPROM_STATUS,1);
 b16:	89 e1       	ldi	r24, 0x19	; 25
 b18:	90 e0       	ldi	r25, 0x00	; 0
 b1a:	61 e0       	ldi	r22, 0x01	; 1
 b1c:	0e 94 8f 03 	call	0x71e	; 0x71e <EEPROM_WRITE>
	LCD_CLEAR_SCREEN();
 b20:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
	LCD_SEND_STRING("password saved!!");
 b24:	8f e8       	ldi	r24, 0x8F	; 143
 b26:	90 e0       	ldi	r25, 0x00	; 0
 b28:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
 b2c:	8f ef       	ldi	r24, 0xFF	; 255
 b2e:	99 e6       	ldi	r25, 0x69	; 105
 b30:	a8 e1       	ldi	r26, 0x18	; 24
 b32:	81 50       	subi	r24, 0x01	; 1
 b34:	90 40       	sbci	r25, 0x00	; 0
 b36:	a0 40       	sbci	r26, 0x00	; 0
 b38:	e1 f7       	brne	.-8      	; 0xb32 <main+0x118>
 b3a:	00 c0       	rjmp	.+0      	; 0xb3c <main+0x122>
 b3c:	00 00       	nop
	_delay_ms(1000);
	LCD_CLEAR_SCREEN();
 b3e:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
 b42:	12 c2       	rjmp	.+1060   	; 0xf68 <main+0x54e>
	}	
	else
	{
	LCD_CLEAR_SCREEN();
 b44:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
	LCD_SEND_STRING("1/check password");
 b48:	80 ea       	ldi	r24, 0xA0	; 160
 b4a:	90 e0       	ldi	r25, 0x00	; 0
 b4c:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
	lCD_MOVE_CURSOR(2,1);
 b50:	82 e0       	ldi	r24, 0x02	; 2
 b52:	61 e0       	ldi	r22, 0x01	; 1
 b54:	0e 94 5e 04 	call	0x8bc	; 0x8bc <lCD_MOVE_CURSOR>
	LCD_SEND_STRING("2/edit password");
 b58:	81 eb       	ldi	r24, 0xB1	; 177
 b5a:	90 e0       	ldi	r25, 0x00	; 0
 b5c:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
 b60:	8f ef       	ldi	r24, 0xFF	; 255
 b62:	93 ed       	ldi	r25, 0xD3	; 211
 b64:	a0 e3       	ldi	r26, 0x30	; 48
 b66:	81 50       	subi	r24, 0x01	; 1
 b68:	90 40       	sbci	r25, 0x00	; 0
 b6a:	a0 40       	sbci	r26, 0x00	; 0
 b6c:	e1 f7       	brne	.-8      	; 0xb66 <main+0x14c>
 b6e:	00 c0       	rjmp	.+0      	; 0xb70 <main+0x156>
 b70:	00 00       	nop
	_delay_ms(2000);
	LCD_CLEAR_SCREEN();
 b72:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
	LCD_SEND_STRING("1 or 2:");
 b76:	81 ec       	ldi	r24, 0xC1	; 193
 b78:	90 e0       	ldi	r25, 0x00	; 0
 b7a:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
	x=0xff;
 b7e:	8f ef       	ldi	r24, 0xFF	; 255
 b80:	80 93 84 01 	sts	0x0184, r24
	do 
	{
		x=keybad_check_press();
 b84:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <keybad_check_press>
 b88:	80 93 84 01 	sts	0x0184, r24
	} while (x == 0xff);
 b8c:	8f 3f       	cpi	r24, 0xFF	; 255
 b8e:	d1 f3       	breq	.-12     	; 0xb84 <main+0x16a>
	LCD_SEND_CHAR(x);
 b90:	0e 94 c9 04 	call	0x992	; 0x992 <LCD_SEND_CHAR>
 b94:	8f ef       	ldi	r24, 0xFF	; 255
 b96:	99 e6       	ldi	r25, 0x69	; 105
 b98:	a8 e1       	ldi	r26, 0x18	; 24
 b9a:	81 50       	subi	r24, 0x01	; 1
 b9c:	90 40       	sbci	r25, 0x00	; 0
 b9e:	a0 40       	sbci	r26, 0x00	; 0
 ba0:	e1 f7       	brne	.-8      	; 0xb9a <main+0x180>
 ba2:	00 c0       	rjmp	.+0      	; 0xba4 <main+0x18a>
 ba4:	00 00       	nop
	_delay_ms(1000);		
		switch(x)
 ba6:	80 91 84 01 	lds	r24, 0x0184
 baa:	81 33       	cpi	r24, 0x31	; 49
 bac:	09 f4       	brne	.+2      	; 0xbb0 <main+0x196>
 bae:	cc c0       	rjmp	.+408    	; 0xd48 <main+0x32e>
 bb0:	82 33       	cpi	r24, 0x32	; 50
 bb2:	09 f0       	breq	.+2      	; 0xbb6 <main+0x19c>
 bb4:	d9 c1       	rjmp	.+946    	; 0xf68 <main+0x54e>
 bb6:	f5 c0       	rjmp	.+490    	; 0xda2 <main+0x388>
		{
				case'1':
				while(flag == 0)
				{
				x=0xff;
 bb8:	d0 93 84 01 	sts	0x0184, r29
				LCD_CLEAR_SCREEN();
 bbc:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
				LCD_SEND_STRING("check password:");
 bc0:	c8 01       	movw	r24, r16
 bc2:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
				lCD_MOVE_CURSOR(2,1);
 bc6:	82 e0       	ldi	r24, 0x02	; 2
 bc8:	61 e0       	ldi	r22, 0x01	; 1
 bca:	0e 94 5e 04 	call	0x8bc	; 0x8bc <lCD_MOVE_CURSOR>
				for(i=0;i<=3;i++)
 bce:	10 92 7f 01 	sts	0x017F, r1
				{
					do
					{
						x=keybad_check_press();
 bd2:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <keybad_check_press>
 bd6:	28 2f       	mov	r18, r24
 bd8:	80 93 84 01 	sts	0x0184, r24
						
					} while (x == 0xff);
 bdc:	8f 3f       	cpi	r24, 0xFF	; 255
 bde:	c9 f3       	breq	.-14     	; 0xbd2 <main+0x1b8>
					arr[i]=x;
 be0:	80 91 7f 01 	lds	r24, 0x017F
 be4:	90 e0       	ldi	r25, 0x00	; 0
 be6:	80 58       	subi	r24, 0x80	; 128
 be8:	9e 4f       	sbci	r25, 0xFE	; 254
 bea:	dc 01       	movw	r26, r24
 bec:	2c 93       	st	X, r18
 bee:	8f e7       	ldi	r24, 0x7F	; 127
 bf0:	98 e3       	ldi	r25, 0x38	; 56
 bf2:	a1 e0       	ldi	r26, 0x01	; 1
 bf4:	81 50       	subi	r24, 0x01	; 1
 bf6:	90 40       	sbci	r25, 0x00	; 0
 bf8:	a0 40       	sbci	r26, 0x00	; 0
 bfa:	e1 f7       	brne	.-8      	; 0xbf4 <main+0x1da>
 bfc:	00 c0       	rjmp	.+0      	; 0xbfe <main+0x1e4>
 bfe:	00 00       	nop
					_delay_ms(50);
					LCD_SEND_CHAR(x);
 c00:	82 2f       	mov	r24, r18
 c02:	0e 94 c9 04 	call	0x992	; 0x992 <LCD_SEND_CHAR>
 c06:	8f ef       	ldi	r24, 0xFF	; 255
 c08:	94 e3       	ldi	r25, 0x34	; 52
 c0a:	ac e0       	ldi	r26, 0x0C	; 12
 c0c:	81 50       	subi	r24, 0x01	; 1
 c0e:	90 40       	sbci	r25, 0x00	; 0
 c10:	a0 40       	sbci	r26, 0x00	; 0
 c12:	e1 f7       	brne	.-8      	; 0xc0c <main+0x1f2>
 c14:	00 c0       	rjmp	.+0      	; 0xc16 <main+0x1fc>
 c16:	00 00       	nop
					_delay_ms(500);
					LCD_SEND_CMD(0X10);
 c18:	80 e1       	ldi	r24, 0x10	; 16
 c1a:	0e 94 47 04 	call	0x88e	; 0x88e <LCD_SEND_CMD>
					LCD_SEND_CHAR(0X2A);	
 c1e:	8a e2       	ldi	r24, 0x2A	; 42
 c20:	0e 94 c9 04 	call	0x992	; 0x992 <LCD_SEND_CHAR>
				{
				x=0xff;
				LCD_CLEAR_SCREEN();
				LCD_SEND_STRING("check password:");
				lCD_MOVE_CURSOR(2,1);
				for(i=0;i<=3;i++)
 c24:	80 91 7f 01 	lds	r24, 0x017F
 c28:	8f 5f       	subi	r24, 0xFF	; 255
 c2a:	80 93 7f 01 	sts	0x017F, r24
 c2e:	84 30       	cpi	r24, 0x04	; 4
 c30:	80 f2       	brcs	.-96     	; 0xbd2 <main+0x1b8>
					_delay_ms(500);
					LCD_SEND_CMD(0X10);
					LCD_SEND_CHAR(0X2A);	
				}
				
			if(arr[0]==EEPROM_READ(EEPROM_PASSWORD_LOCATION1) && arr[1]==EEPROM_READ(EEPROM_PASSWORD_LOCATION2) && arr[2]==EEPROM_READ(EEPROM_PASSWORD_LOCATION3) && arr[3]==EEPROM_READ(EEPROM_PASSWORD_LOCATION4))
 c32:	d7 01       	movw	r26, r14
 c34:	cc 91       	ld	r28, X
 c36:	80 e2       	ldi	r24, 0x20	; 32
 c38:	90 e0       	ldi	r25, 0x00	; 0
 c3a:	0e 94 97 03 	call	0x72e	; 0x72e <EEPROM_READ>
 c3e:	c8 17       	cp	r28, r24
 c40:	e9 f5       	brne	.+122    	; 0xcbc <main+0x2a2>
 c42:	f2 01       	movw	r30, r4
 c44:	c0 81       	ld	r28, Z
 c46:	81 e2       	ldi	r24, 0x21	; 33
 c48:	90 e0       	ldi	r25, 0x00	; 0
 c4a:	0e 94 97 03 	call	0x72e	; 0x72e <EEPROM_READ>
 c4e:	c8 17       	cp	r28, r24
 c50:	a9 f5       	brne	.+106    	; 0xcbc <main+0x2a2>
 c52:	a2 e8       	ldi	r26, 0x82	; 130
 c54:	b1 e0       	ldi	r27, 0x01	; 1
 c56:	cc 91       	ld	r28, X
 c58:	82 e2       	ldi	r24, 0x22	; 34
 c5a:	90 e0       	ldi	r25, 0x00	; 0
 c5c:	0e 94 97 03 	call	0x72e	; 0x72e <EEPROM_READ>
 c60:	c8 17       	cp	r28, r24
 c62:	61 f5       	brne	.+88     	; 0xcbc <main+0x2a2>
 c64:	e3 e8       	ldi	r30, 0x83	; 131
 c66:	f1 e0       	ldi	r31, 0x01	; 1
 c68:	c0 81       	ld	r28, Z
 c6a:	83 e2       	ldi	r24, 0x23	; 35
 c6c:	90 e0       	ldi	r25, 0x00	; 0
 c6e:	0e 94 97 03 	call	0x72e	; 0x72e <EEPROM_READ>
 c72:	c8 17       	cp	r28, r24
 c74:	19 f5       	brne	.+70     	; 0xcbc <main+0x2a2>
			{
				LCD_CLEAR_SCREEN();
 c76:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
				LCD_SEND_STRING("Right password");
 c7a:	89 ed       	ldi	r24, 0xD9	; 217
 c7c:	90 e0       	ldi	r25, 0x00	; 0
 c7e:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
				lCD_MOVE_CURSOR(2,1);
 c82:	82 e0       	ldi	r24, 0x02	; 2
 c84:	61 e0       	ldi	r22, 0x01	; 1
 c86:	0e 94 5e 04 	call	0x8bc	; 0x8bc <lCD_MOVE_CURSOR>
				LCD_SEND_STRING("Safe opened!!");
 c8a:	88 ee       	ldi	r24, 0xE8	; 232
 c8c:	90 e0       	ldi	r25, 0x00	; 0
 c8e:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
				LED_ON('b',0);
 c92:	82 e6       	ldi	r24, 0x62	; 98
 c94:	60 e0       	ldi	r22, 0x00	; 0
 c96:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <LED_ON>
 c9a:	8f ef       	ldi	r24, 0xFF	; 255
 c9c:	93 ed       	ldi	r25, 0xD3	; 211
 c9e:	a0 e3       	ldi	r26, 0x30	; 48
 ca0:	81 50       	subi	r24, 0x01	; 1
 ca2:	90 40       	sbci	r25, 0x00	; 0
 ca4:	a0 40       	sbci	r26, 0x00	; 0
 ca6:	e1 f7       	brne	.-8      	; 0xca0 <main+0x286>
 ca8:	00 c0       	rjmp	.+0      	; 0xcaa <main+0x290>
 caa:	00 00       	nop
				_delay_ms(2000);
				LED_OFF('b',0);
 cac:	82 e6       	ldi	r24, 0x62	; 98
 cae:	60 e0       	ldi	r22, 0x00	; 0
 cb0:	0e 94 fd 04 	call	0x9fa	; 0x9fa <LED_OFF>
				flag =1;
 cb4:	81 e0       	ldi	r24, 0x01	; 1
 cb6:	80 93 7e 01 	sts	0x017E, r24
 cba:	6d c0       	rjmp	.+218    	; 0xd96 <main+0x37c>
			}
			else
			{
				LCD_CLEAR_SCREEN();
 cbc:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
				max_trials--;
 cc0:	80 91 7c 01 	lds	r24, 0x017C
 cc4:	81 50       	subi	r24, 0x01	; 1
 cc6:	80 93 7c 01 	sts	0x017C, r24
				if(max_trials != 0)
 cca:	88 23       	and	r24, r24
 ccc:	f1 f0       	breq	.+60     	; 0xd0a <main+0x2f0>
				{
					
					LCD_SEND_STRING("wrong password");
 cce:	c6 01       	movw	r24, r12
 cd0:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
					lCD_MOVE_CURSOR(2,1);
 cd4:	82 e0       	ldi	r24, 0x02	; 2
 cd6:	61 e0       	ldi	r22, 0x01	; 1
 cd8:	0e 94 5e 04 	call	0x8bc	; 0x8bc <lCD_MOVE_CURSOR>
					LCD_SEND_STRING("you have ");
 cdc:	c4 01       	movw	r24, r8
 cde:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
					LCD_SEND_CHAR(max_trials+48);
 ce2:	80 91 7c 01 	lds	r24, 0x017C
 ce6:	80 5d       	subi	r24, 0xD0	; 208
 ce8:	0e 94 c9 04 	call	0x992	; 0x992 <LCD_SEND_CHAR>
					LCD_SEND_STRING("trials only");
 cec:	c3 01       	movw	r24, r6
 cee:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
 cf2:	8f ef       	ldi	r24, 0xFF	; 255
 cf4:	99 e6       	ldi	r25, 0x69	; 105
 cf6:	a8 e1       	ldi	r26, 0x18	; 24
 cf8:	81 50       	subi	r24, 0x01	; 1
 cfa:	90 40       	sbci	r25, 0x00	; 0
 cfc:	a0 40       	sbci	r26, 0x00	; 0
 cfe:	e1 f7       	brne	.-8      	; 0xcf8 <main+0x2de>
 d00:	00 c0       	rjmp	.+0      	; 0xd02 <main+0x2e8>
 d02:	00 00       	nop
					_delay_ms(1000);
					flag=0;
 d04:	10 92 7e 01 	sts	0x017E, r1
 d08:	46 c0       	rjmp	.+140    	; 0xd96 <main+0x37c>
				}
				else
				{
					LCD_SEND_STRING("wrong password");
 d0a:	c6 01       	movw	r24, r12
 d0c:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
					lCD_MOVE_CURSOR(2,1);
 d10:	82 e0       	ldi	r24, 0x02	; 2
 d12:	61 e0       	ldi	r22, 0x01	; 1
 d14:	0e 94 5e 04 	call	0x8bc	; 0x8bc <lCD_MOVE_CURSOR>
					LCD_SEND_STRING("Safe Closed");
 d18:	c5 01       	movw	r24, r10
 d1a:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
					flag=1;
 d1e:	81 e0       	ldi	r24, 0x01	; 1
 d20:	80 93 7e 01 	sts	0x017E, r24
					LED_ON('b',1);
 d24:	82 e6       	ldi	r24, 0x62	; 98
 d26:	61 e0       	ldi	r22, 0x01	; 1
 d28:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <LED_ON>
 d2c:	8f ef       	ldi	r24, 0xFF	; 255
 d2e:	99 e6       	ldi	r25, 0x69	; 105
 d30:	a8 e1       	ldi	r26, 0x18	; 24
 d32:	81 50       	subi	r24, 0x01	; 1
 d34:	90 40       	sbci	r25, 0x00	; 0
 d36:	a0 40       	sbci	r26, 0x00	; 0
 d38:	e1 f7       	brne	.-8      	; 0xd32 <main+0x318>
 d3a:	00 c0       	rjmp	.+0      	; 0xd3c <main+0x322>
 d3c:	00 00       	nop
					_delay_ms(1000);
					LED_OFF('b',1);
 d3e:	82 e6       	ldi	r24, 0x62	; 98
 d40:	61 e0       	ldi	r22, 0x01	; 1
 d42:	0e 94 fd 04 	call	0x9fa	; 0x9fa <LED_OFF>
 d46:	27 c0       	rjmp	.+78     	; 0xd96 <main+0x37c>
		switch(x)
		{
				case'1':
				while(flag == 0)
				{
				x=0xff;
 d48:	df ef       	ldi	r29, 0xFF	; 255
				LCD_CLEAR_SCREEN();
				LCD_SEND_STRING("check password:");
 d4a:	09 ec       	ldi	r16, 0xC9	; 201
 d4c:	10 e0       	ldi	r17, 0x00	; 0
					_delay_ms(500);
					LCD_SEND_CMD(0X10);
					LCD_SEND_CHAR(0X2A);	
				}
				
			if(arr[0]==EEPROM_READ(EEPROM_PASSWORD_LOCATION1) && arr[1]==EEPROM_READ(EEPROM_PASSWORD_LOCATION2) && arr[2]==EEPROM_READ(EEPROM_PASSWORD_LOCATION3) && arr[3]==EEPROM_READ(EEPROM_PASSWORD_LOCATION4))
 d4e:	0f 2e       	mov	r0, r31
 d50:	f0 e8       	ldi	r31, 0x80	; 128
 d52:	ef 2e       	mov	r14, r31
 d54:	f1 e0       	ldi	r31, 0x01	; 1
 d56:	ff 2e       	mov	r15, r31
 d58:	f0 2d       	mov	r31, r0
					_delay_ms(1000);
					flag=0;
				}
				else
				{
					LCD_SEND_STRING("wrong password");
 d5a:	0f 2e       	mov	r0, r31
 d5c:	f6 ef       	ldi	r31, 0xF6	; 246
 d5e:	cf 2e       	mov	r12, r31
 d60:	f0 e0       	ldi	r31, 0x00	; 0
 d62:	df 2e       	mov	r13, r31
 d64:	f0 2d       	mov	r31, r0
					lCD_MOVE_CURSOR(2,1);
					LCD_SEND_STRING("Safe Closed");
 d66:	0f 2e       	mov	r0, r31
 d68:	fb e1       	ldi	r31, 0x1B	; 27
 d6a:	af 2e       	mov	r10, r31
 d6c:	f1 e0       	ldi	r31, 0x01	; 1
 d6e:	bf 2e       	mov	r11, r31
 d70:	f0 2d       	mov	r31, r0
				if(max_trials != 0)
				{
					
					LCD_SEND_STRING("wrong password");
					lCD_MOVE_CURSOR(2,1);
					LCD_SEND_STRING("you have ");
 d72:	0f 2e       	mov	r0, r31
 d74:	f5 e0       	ldi	r31, 0x05	; 5
 d76:	8f 2e       	mov	r8, r31
 d78:	f1 e0       	ldi	r31, 0x01	; 1
 d7a:	9f 2e       	mov	r9, r31
 d7c:	f0 2d       	mov	r31, r0
					LCD_SEND_CHAR(max_trials+48);
					LCD_SEND_STRING("trials only");
 d7e:	0f 2e       	mov	r0, r31
 d80:	ff e0       	ldi	r31, 0x0F	; 15
 d82:	6f 2e       	mov	r6, r31
 d84:	f1 e0       	ldi	r31, 0x01	; 1
 d86:	7f 2e       	mov	r7, r31
 d88:	f0 2d       	mov	r31, r0
					_delay_ms(500);
					LCD_SEND_CMD(0X10);
					LCD_SEND_CHAR(0X2A);	
				}
				
			if(arr[0]==EEPROM_READ(EEPROM_PASSWORD_LOCATION1) && arr[1]==EEPROM_READ(EEPROM_PASSWORD_LOCATION2) && arr[2]==EEPROM_READ(EEPROM_PASSWORD_LOCATION3) && arr[3]==EEPROM_READ(EEPROM_PASSWORD_LOCATION4))
 d8a:	0f 2e       	mov	r0, r31
 d8c:	f1 e8       	ldi	r31, 0x81	; 129
 d8e:	4f 2e       	mov	r4, r31
 d90:	f1 e0       	ldi	r31, 0x01	; 1
 d92:	5f 2e       	mov	r5, r31
 d94:	f0 2d       	mov	r31, r0
	LCD_SEND_CHAR(x);
	_delay_ms(1000);		
		switch(x)
		{
				case'1':
				while(flag == 0)
 d96:	80 91 7e 01 	lds	r24, 0x017E
 d9a:	88 23       	and	r24, r24
 d9c:	09 f4       	brne	.+2      	; 0xda0 <main+0x386>
 d9e:	0c cf       	rjmp	.-488    	; 0xbb8 <main+0x19e>
 da0:	e3 c0       	rjmp	.+454    	; 0xf68 <main+0x54e>
				}
			}
				}	
				break;		
			case'2':
				LCD_CLEAR_SCREEN();
 da2:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
				LCD_SEND_STRING("Enter Password:");
 da6:	87 e2       	ldi	r24, 0x27	; 39
 da8:	91 e0       	ldi	r25, 0x01	; 1
 daa:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
				lCD_MOVE_CURSOR(2,1);
 dae:	82 e0       	ldi	r24, 0x02	; 2
 db0:	61 e0       	ldi	r22, 0x01	; 1
 db2:	0e 94 5e 04 	call	0x8bc	; 0x8bc <lCD_MOVE_CURSOR>
				for(i=0;i<=3;i++)
 db6:	10 92 7f 01 	sts	0x017F, r1
				{
					do
					{
						x=keybad_check_press();
 dba:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <keybad_check_press>
 dbe:	80 93 84 01 	sts	0x0184, r24
						
					} while (x == 0xff);
 dc2:	8f 3f       	cpi	r24, 0xFF	; 255
 dc4:	d1 f3       	breq	.-12     	; 0xdba <main+0x3a0>
					arr[i]=x;
 dc6:	e0 91 7f 01 	lds	r30, 0x017F
 dca:	f0 e0       	ldi	r31, 0x00	; 0
 dcc:	e0 58       	subi	r30, 0x80	; 128
 dce:	fe 4f       	sbci	r31, 0xFE	; 254
 dd0:	80 83       	st	Z, r24
 dd2:	8f e7       	ldi	r24, 0x7F	; 127
 dd4:	98 e3       	ldi	r25, 0x38	; 56
 dd6:	a1 e0       	ldi	r26, 0x01	; 1
 dd8:	81 50       	subi	r24, 0x01	; 1
 dda:	90 40       	sbci	r25, 0x00	; 0
 ddc:	a0 40       	sbci	r26, 0x00	; 0
 dde:	e1 f7       	brne	.-8      	; 0xdd8 <main+0x3be>
 de0:	00 c0       	rjmp	.+0      	; 0xde2 <main+0x3c8>
 de2:	00 00       	nop
					_delay_ms(50);
					LCD_SEND_CHAR(x);
 de4:	80 91 84 01 	lds	r24, 0x0184
 de8:	0e 94 c9 04 	call	0x992	; 0x992 <LCD_SEND_CHAR>
 dec:	8f ef       	ldi	r24, 0xFF	; 255
 dee:	94 e3       	ldi	r25, 0x34	; 52
 df0:	ac e0       	ldi	r26, 0x0C	; 12
 df2:	81 50       	subi	r24, 0x01	; 1
 df4:	90 40       	sbci	r25, 0x00	; 0
 df6:	a0 40       	sbci	r26, 0x00	; 0
 df8:	e1 f7       	brne	.-8      	; 0xdf2 <main+0x3d8>
 dfa:	00 c0       	rjmp	.+0      	; 0xdfc <main+0x3e2>
 dfc:	00 00       	nop
					_delay_ms(500);
					LCD_SEND_CMD(0X10);
 dfe:	80 e1       	ldi	r24, 0x10	; 16
 e00:	0e 94 47 04 	call	0x88e	; 0x88e <LCD_SEND_CMD>
					LCD_SEND_CHAR(0X2A);
 e04:	8a e2       	ldi	r24, 0x2A	; 42
 e06:	0e 94 c9 04 	call	0x992	; 0x992 <LCD_SEND_CHAR>
				break;		
			case'2':
				LCD_CLEAR_SCREEN();
				LCD_SEND_STRING("Enter Password:");
				lCD_MOVE_CURSOR(2,1);
				for(i=0;i<=3;i++)
 e0a:	80 91 7f 01 	lds	r24, 0x017F
 e0e:	8f 5f       	subi	r24, 0xFF	; 255
 e10:	80 93 7f 01 	sts	0x017F, r24
 e14:	84 30       	cpi	r24, 0x04	; 4
 e16:	88 f2       	brcs	.-94     	; 0xdba <main+0x3a0>
					_delay_ms(500);
					LCD_SEND_CMD(0X10);
					LCD_SEND_CHAR(0X2A);
				}
				
				if(arr[0]==EEPROM_READ(EEPROM_PASSWORD_LOCATION1) && arr[1]==EEPROM_READ(EEPROM_PASSWORD_LOCATION2) && arr[2]==EEPROM_READ(EEPROM_PASSWORD_LOCATION3) && arr[3]==EEPROM_READ(EEPROM_PASSWORD_LOCATION4))
 e18:	c0 91 80 01 	lds	r28, 0x0180
 e1c:	80 e2       	ldi	r24, 0x20	; 32
 e1e:	90 e0       	ldi	r25, 0x00	; 0
 e20:	0e 94 97 03 	call	0x72e	; 0x72e <EEPROM_READ>
 e24:	c8 17       	cp	r28, r24
 e26:	09 f0       	breq	.+2      	; 0xe2a <main+0x410>
 e28:	77 c0       	rjmp	.+238    	; 0xf18 <main+0x4fe>
 e2a:	c0 91 81 01 	lds	r28, 0x0181
 e2e:	81 e2       	ldi	r24, 0x21	; 33
 e30:	90 e0       	ldi	r25, 0x00	; 0
 e32:	0e 94 97 03 	call	0x72e	; 0x72e <EEPROM_READ>
 e36:	c8 17       	cp	r28, r24
 e38:	09 f0       	breq	.+2      	; 0xe3c <main+0x422>
 e3a:	6e c0       	rjmp	.+220    	; 0xf18 <main+0x4fe>
 e3c:	c0 91 82 01 	lds	r28, 0x0182
 e40:	82 e2       	ldi	r24, 0x22	; 34
 e42:	90 e0       	ldi	r25, 0x00	; 0
 e44:	0e 94 97 03 	call	0x72e	; 0x72e <EEPROM_READ>
 e48:	c8 17       	cp	r28, r24
 e4a:	09 f0       	breq	.+2      	; 0xe4e <main+0x434>
 e4c:	65 c0       	rjmp	.+202    	; 0xf18 <main+0x4fe>
 e4e:	c0 91 83 01 	lds	r28, 0x0183
 e52:	83 e2       	ldi	r24, 0x23	; 35
 e54:	90 e0       	ldi	r25, 0x00	; 0
 e56:	0e 94 97 03 	call	0x72e	; 0x72e <EEPROM_READ>
 e5a:	c8 17       	cp	r28, r24
 e5c:	09 f0       	breq	.+2      	; 0xe60 <main+0x446>
 e5e:	5c c0       	rjmp	.+184    	; 0xf18 <main+0x4fe>
				{
					LCD_CLEAR_SCREEN();
 e60:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
					LCD_SEND_STRING("Right password");
 e64:	89 ed       	ldi	r24, 0xD9	; 217
 e66:	90 e0       	ldi	r25, 0x00	; 0
 e68:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
 e6c:	8f ef       	ldi	r24, 0xFF	; 255
 e6e:	99 e6       	ldi	r25, 0x69	; 105
 e70:	a8 e1       	ldi	r26, 0x18	; 24
 e72:	81 50       	subi	r24, 0x01	; 1
 e74:	90 40       	sbci	r25, 0x00	; 0
 e76:	a0 40       	sbci	r26, 0x00	; 0
 e78:	e1 f7       	brne	.-8      	; 0xe72 <main+0x458>
 e7a:	00 c0       	rjmp	.+0      	; 0xe7c <main+0x462>
 e7c:	00 00       	nop
					_delay_ms(1000);
					LCD_CLEAR_SCREEN();
 e7e:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
					LCD_SEND_STRING("EnterNewPassword:");
 e82:	87 e3       	ldi	r24, 0x37	; 55
 e84:	91 e0       	ldi	r25, 0x01	; 1
 e86:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
					lCD_MOVE_CURSOR(2,1);
 e8a:	82 e0       	ldi	r24, 0x02	; 2
 e8c:	61 e0       	ldi	r22, 0x01	; 1
 e8e:	0e 94 5e 04 	call	0x8bc	; 0x8bc <lCD_MOVE_CURSOR>
					for(i=0;i<=3;i++)
 e92:	10 92 7f 01 	sts	0x017F, r1
					{
						do 
						{
							x=keybad_check_press();
 e96:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <keybad_check_press>
 e9a:	80 93 84 01 	sts	0x0184, r24
						} while (x == 0xff);
 e9e:	8f 3f       	cpi	r24, 0xFF	; 255
 ea0:	d1 f3       	breq	.-12     	; 0xe96 <main+0x47c>
 ea2:	8f e7       	ldi	r24, 0x7F	; 127
 ea4:	98 e3       	ldi	r25, 0x38	; 56
 ea6:	a1 e0       	ldi	r26, 0x01	; 1
 ea8:	81 50       	subi	r24, 0x01	; 1
 eaa:	90 40       	sbci	r25, 0x00	; 0
 eac:	a0 40       	sbci	r26, 0x00	; 0
 eae:	e1 f7       	brne	.-8      	; 0xea8 <main+0x48e>
 eb0:	00 c0       	rjmp	.+0      	; 0xeb2 <main+0x498>
 eb2:	00 00       	nop
						_delay_ms(50);
						LCD_SEND_CHAR(x);
 eb4:	80 91 84 01 	lds	r24, 0x0184
 eb8:	0e 94 c9 04 	call	0x992	; 0x992 <LCD_SEND_CHAR>
 ebc:	8f ef       	ldi	r24, 0xFF	; 255
 ebe:	94 e3       	ldi	r25, 0x34	; 52
 ec0:	ac e0       	ldi	r26, 0x0C	; 12
 ec2:	81 50       	subi	r24, 0x01	; 1
 ec4:	90 40       	sbci	r25, 0x00	; 0
 ec6:	a0 40       	sbci	r26, 0x00	; 0
 ec8:	e1 f7       	brne	.-8      	; 0xec2 <main+0x4a8>
 eca:	00 c0       	rjmp	.+0      	; 0xecc <main+0x4b2>
 ecc:	00 00       	nop
						_delay_ms(500);
						LCD_SEND_CMD(0X10);
 ece:	80 e1       	ldi	r24, 0x10	; 16
 ed0:	0e 94 47 04 	call	0x88e	; 0x88e <LCD_SEND_CMD>
						LCD_SEND_CHAR(0X2A);
 ed4:	8a e2       	ldi	r24, 0x2A	; 42
 ed6:	0e 94 c9 04 	call	0x992	; 0x992 <LCD_SEND_CHAR>
						EEPROM_WRITE(EEPROM_PASSWORD_LOCATION1+i,x);	   
 eda:	80 91 7f 01 	lds	r24, 0x017F
 ede:	90 e0       	ldi	r25, 0x00	; 0
 ee0:	80 96       	adiw	r24, 0x20	; 32
 ee2:	60 91 84 01 	lds	r22, 0x0184
 ee6:	0e 94 8f 03 	call	0x71e	; 0x71e <EEPROM_WRITE>
					LCD_SEND_STRING("Right password");
					_delay_ms(1000);
					LCD_CLEAR_SCREEN();
					LCD_SEND_STRING("EnterNewPassword:");
					lCD_MOVE_CURSOR(2,1);
					for(i=0;i<=3;i++)
 eea:	80 91 7f 01 	lds	r24, 0x017F
 eee:	8f 5f       	subi	r24, 0xFF	; 255
 ef0:	80 93 7f 01 	sts	0x017F, r24
 ef4:	84 30       	cpi	r24, 0x04	; 4
 ef6:	78 f2       	brcs	.-98     	; 0xe96 <main+0x47c>
 ef8:	8f ef       	ldi	r24, 0xFF	; 255
 efa:	99 e6       	ldi	r25, 0x69	; 105
 efc:	a8 e1       	ldi	r26, 0x18	; 24
 efe:	81 50       	subi	r24, 0x01	; 1
 f00:	90 40       	sbci	r25, 0x00	; 0
 f02:	a0 40       	sbci	r26, 0x00	; 0
 f04:	e1 f7       	brne	.-8      	; 0xefe <main+0x4e4>
 f06:	00 c0       	rjmp	.+0      	; 0xf08 <main+0x4ee>
 f08:	00 00       	nop
						LCD_SEND_CMD(0X10);
						LCD_SEND_CHAR(0X2A);
						EEPROM_WRITE(EEPROM_PASSWORD_LOCATION1+i,x);	   
					}
					_delay_ms(1000);
					LCD_CLEAR_SCREEN();
 f0a:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
					LCD_SEND_STRING("Password saved!!");
 f0e:	89 e4       	ldi	r24, 0x49	; 73
 f10:	91 e0       	ldi	r25, 0x01	; 1
 f12:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
 f16:	28 c0       	rjmp	.+80     	; 0xf68 <main+0x54e>
 f18:	8f ef       	ldi	r24, 0xFF	; 255
 f1a:	99 e6       	ldi	r25, 0x69	; 105
 f1c:	a8 e1       	ldi	r26, 0x18	; 24
 f1e:	81 50       	subi	r24, 0x01	; 1
 f20:	90 40       	sbci	r25, 0x00	; 0
 f22:	a0 40       	sbci	r26, 0x00	; 0
 f24:	e1 f7       	brne	.-8      	; 0xf1e <main+0x504>
 f26:	00 c0       	rjmp	.+0      	; 0xf28 <main+0x50e>
 f28:	00 00       	nop
				}				
				else
				{
					_delay_ms(1000);
					LCD_CLEAR_SCREEN();
 f2a:	0e 94 80 04 	call	0x900	; 0x900 <LCD_CLEAR_SCREEN>
					LCD_SEND_STRING("Wrong password!!");
 f2e:	8a e5       	ldi	r24, 0x5A	; 90
 f30:	91 e0       	ldi	r25, 0x01	; 1
 f32:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
					lCD_MOVE_CURSOR(2,1);
 f36:	82 e0       	ldi	r24, 0x02	; 2
 f38:	61 e0       	ldi	r22, 0x01	; 1
 f3a:	0e 94 5e 04 	call	0x8bc	; 0x8bc <lCD_MOVE_CURSOR>
					LCD_SEND_STRING("Cant change it..");
 f3e:	8b e6       	ldi	r24, 0x6B	; 107
 f40:	91 e0       	ldi	r25, 0x01	; 1
 f42:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <LCD_SEND_STRING>
					LED_ON('b',1);
 f46:	82 e6       	ldi	r24, 0x62	; 98
 f48:	61 e0       	ldi	r22, 0x01	; 1
 f4a:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <LED_ON>
 f4e:	8f ef       	ldi	r24, 0xFF	; 255
 f50:	99 e6       	ldi	r25, 0x69	; 105
 f52:	a8 e1       	ldi	r26, 0x18	; 24
 f54:	81 50       	subi	r24, 0x01	; 1
 f56:	90 40       	sbci	r25, 0x00	; 0
 f58:	a0 40       	sbci	r26, 0x00	; 0
 f5a:	e1 f7       	brne	.-8      	; 0xf54 <main+0x53a>
 f5c:	00 c0       	rjmp	.+0      	; 0xf5e <main+0x544>
 f5e:	00 00       	nop
					_delay_ms(1000);
					LED_OFF('b',1);
 f60:	82 e6       	ldi	r24, 0x62	; 98
 f62:	61 e0       	ldi	r22, 0x01	; 1
 f64:	0e 94 fd 04 	call	0x9fa	; 0x9fa <LED_OFF>
			
			break;
			
		}	
				} 
}
 f68:	80 e0       	ldi	r24, 0x00	; 0
 f6a:	90 e0       	ldi	r25, 0x00	; 0
 f6c:	df 91       	pop	r29
 f6e:	cf 91       	pop	r28
 f70:	1f 91       	pop	r17
 f72:	0f 91       	pop	r16
 f74:	ff 90       	pop	r15
 f76:	ef 90       	pop	r14
 f78:	df 90       	pop	r13
 f7a:	cf 90       	pop	r12
 f7c:	bf 90       	pop	r11
 f7e:	af 90       	pop	r10
 f80:	9f 90       	pop	r9
 f82:	8f 90       	pop	r8
 f84:	7f 90       	pop	r7
 f86:	6f 90       	pop	r6
 f88:	5f 90       	pop	r5
 f8a:	4f 90       	pop	r4
 f8c:	08 95       	ret

00000f8e <_exit>:
 f8e:	f8 94       	cli

00000f90 <__stop_program>:
 f90:	ff cf       	rjmp	.-2      	; 0xf90 <__stop_program>
