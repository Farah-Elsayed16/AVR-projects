
traffic light.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000ac2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000034  00800060  00000ac2  00000b56  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000003  00800094  00800094  00000b8a  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000b8c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00001258  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000120  00000000  00000000  000012e0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000efd  00000000  00000000  00001400  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000508  00000000  00000000  000022fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000008c0  00000000  00000000  00002805  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000384  00000000  00000000  000030c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000415  00000000  00000000  0000344c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000ba7  00000000  00000000  00003861  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 48 05 	jmp	0xa90	; 0xa90 <__vector_10>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 ec       	ldi	r30, 0xC2	; 194
  68:	fa e0       	ldi	r31, 0x0A	; 10
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 39       	cpi	r26, 0x94	; 148
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a4 e9       	ldi	r26, 0x94	; 148
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a7 39       	cpi	r26, 0x97	; 151
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 c5 04 	call	0x98a	; 0x98a <main>
  8a:	0c 94 5f 05 	jmp	0xabe	; 0xabe <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <count_down>:
 *  Author: abdullah
 */ 


void count_down(char* counter1 , char* counter)
{
  92:	0f 93       	push	r16
  94:	1f 93       	push	r17
  96:	cf 93       	push	r28
  98:	df 93       	push	r29
  9a:	8c 01       	movw	r16, r24
  9c:	eb 01       	movw	r28, r22
	while(*counter1 > 0)
  9e:	18 c0       	rjmp	.+48     	; 0xd0 <count_down+0x3e>
	{
		if(*counter >= 100)
  a0:	88 81       	ld	r24, Y
  a2:	84 36       	cpi	r24, 0x64	; 100
  a4:	e8 f3       	brcs	.-6      	; 0xa0 <count_down+0xe>
		{
			*counter=0;
  a6:	18 82       	st	Y, r1
			(*counter1)--;
  a8:	f8 01       	movw	r30, r16
  aa:	80 81       	ld	r24, Z
  ac:	81 50       	subi	r24, 0x01	; 1
  ae:	80 83       	st	Z, r24
			lCD_MOVE_CURSOR(1,11);
  b0:	81 e0       	ldi	r24, 0x01	; 1
  b2:	90 e0       	ldi	r25, 0x00	; 0
  b4:	6b e0       	ldi	r22, 0x0B	; 11
  b6:	70 e0       	ldi	r23, 0x00	; 0
  b8:	0e 94 cd 03 	call	0x79a	; 0x79a <lCD_MOVE_CURSOR>
			LCD_SEND_CHAR(*counter1+48);
  bc:	f8 01       	movw	r30, r16
  be:	80 81       	ld	r24, Z
  c0:	90 e0       	ldi	r25, 0x00	; 0
  c2:	c0 96       	adiw	r24, 0x30	; 48
  c4:	0e 94 38 04 	call	0x870	; 0x870 <LCD_SEND_CHAR>
			LCD_SEND_CHAR(0X20);
  c8:	80 e2       	ldi	r24, 0x20	; 32
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	0e 94 38 04 	call	0x870	; 0x870 <LCD_SEND_CHAR>
 */ 


void count_down(char* counter1 , char* counter)
{
	while(*counter1 > 0)
  d0:	f8 01       	movw	r30, r16
  d2:	80 81       	ld	r24, Z
  d4:	88 23       	and	r24, r24
  d6:	21 f7       	brne	.-56     	; 0xa0 <count_down+0xe>
			lCD_MOVE_CURSOR(1,11);
			LCD_SEND_CHAR(*counter1+48);
			LCD_SEND_CHAR(0X20);
		}
	}
  d8:	df 91       	pop	r29
  da:	cf 91       	pop	r28
  dc:	1f 91       	pop	r17
  de:	0f 91       	pop	r16
  e0:	08 95       	ret

000000e2 <DIO_SETPINDIR>:
#include <avr/io.h>
//access DDR register to make the pins input or output
// Function Description:Set the direction of the given pin in the given port (direction 0 = input : 1 = output)
void DIO_SETPINDIR (unsigned char portname,unsigned char pinnumber,unsigned char direction)
{
	switch(portname)
  e2:	84 34       	cpi	r24, 0x44	; 68
  e4:	09 f4       	brne	.+2      	; 0xe8 <DIO_SETPINDIR+0x6>
  e6:	79 c0       	rjmp	.+242    	; 0x1da <DIO_SETPINDIR+0xf8>
  e8:	85 34       	cpi	r24, 0x45	; 69
  ea:	48 f4       	brcc	.+18     	; 0xfe <DIO_SETPINDIR+0x1c>
  ec:	82 34       	cpi	r24, 0x42	; 66
  ee:	b1 f1       	breq	.+108    	; 0x15c <DIO_SETPINDIR+0x7a>
  f0:	83 34       	cpi	r24, 0x43	; 67
  f2:	08 f0       	brcs	.+2      	; 0xf6 <DIO_SETPINDIR+0x14>
  f4:	53 c0       	rjmp	.+166    	; 0x19c <DIO_SETPINDIR+0xba>
  f6:	81 34       	cpi	r24, 0x41	; 65
  f8:	09 f0       	breq	.+2      	; 0xfc <DIO_SETPINDIR+0x1a>
  fa:	8d c0       	rjmp	.+282    	; 0x216 <DIO_SETPINDIR+0x134>
  fc:	0f c0       	rjmp	.+30     	; 0x11c <DIO_SETPINDIR+0x3a>
  fe:	82 36       	cpi	r24, 0x62	; 98
 100:	69 f1       	breq	.+90     	; 0x15c <DIO_SETPINDIR+0x7a>
 102:	83 36       	cpi	r24, 0x63	; 99
 104:	20 f4       	brcc	.+8      	; 0x10e <DIO_SETPINDIR+0x2c>
 106:	81 36       	cpi	r24, 0x61	; 97
 108:	09 f0       	breq	.+2      	; 0x10c <DIO_SETPINDIR+0x2a>
 10a:	85 c0       	rjmp	.+266    	; 0x216 <DIO_SETPINDIR+0x134>
 10c:	07 c0       	rjmp	.+14     	; 0x11c <DIO_SETPINDIR+0x3a>
 10e:	83 36       	cpi	r24, 0x63	; 99
 110:	09 f4       	brne	.+2      	; 0x114 <DIO_SETPINDIR+0x32>
 112:	44 c0       	rjmp	.+136    	; 0x19c <DIO_SETPINDIR+0xba>
 114:	84 36       	cpi	r24, 0x64	; 100
 116:	09 f0       	breq	.+2      	; 0x11a <DIO_SETPINDIR+0x38>
 118:	7e c0       	rjmp	.+252    	; 0x216 <DIO_SETPINDIR+0x134>
 11a:	5f c0       	rjmp	.+190    	; 0x1da <DIO_SETPINDIR+0xf8>
	{
		case'A':
		case'a':
		if(direction==1)
 11c:	41 30       	cpi	r20, 0x01	; 1
 11e:	69 f4       	brne	.+26     	; 0x13a <DIO_SETPINDIR+0x58>
		{
			SET_BIT(DDRA,pinnumber);   //set the pin whose its number given by (pinnumber) in DDR register as output
 120:	2a b3       	in	r18, 0x1a	; 26
 122:	81 e0       	ldi	r24, 0x01	; 1
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	ac 01       	movw	r20, r24
 128:	02 c0       	rjmp	.+4      	; 0x12e <DIO_SETPINDIR+0x4c>
 12a:	44 0f       	add	r20, r20
 12c:	55 1f       	adc	r21, r21
 12e:	6a 95       	dec	r22
 130:	e2 f7       	brpl	.-8      	; 0x12a <DIO_SETPINDIR+0x48>
 132:	ba 01       	movw	r22, r20
 134:	62 2b       	or	r22, r18
 136:	6a bb       	out	0x1a, r22	; 26
 138:	08 95       	ret
		}
		if(direction==0)
 13a:	44 23       	and	r20, r20
 13c:	09 f0       	breq	.+2      	; 0x140 <DIO_SETPINDIR+0x5e>
 13e:	6b c0       	rjmp	.+214    	; 0x216 <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRA,pinnumber);  //set the pin whose its number given by (pinnumber) in DDR register as input
 140:	2a b3       	in	r18, 0x1a	; 26
 142:	81 e0       	ldi	r24, 0x01	; 1
 144:	90 e0       	ldi	r25, 0x00	; 0
 146:	ac 01       	movw	r20, r24
 148:	02 c0       	rjmp	.+4      	; 0x14e <DIO_SETPINDIR+0x6c>
 14a:	44 0f       	add	r20, r20
 14c:	55 1f       	adc	r21, r21
 14e:	6a 95       	dec	r22
 150:	e2 f7       	brpl	.-8      	; 0x14a <DIO_SETPINDIR+0x68>
 152:	ba 01       	movw	r22, r20
 154:	60 95       	com	r22
 156:	62 23       	and	r22, r18
 158:	6a bb       	out	0x1a, r22	; 26
 15a:	08 95       	ret
		}
		break;
		case'B':
		case'b':
		if(direction==1)
 15c:	41 30       	cpi	r20, 0x01	; 1
 15e:	69 f4       	brne	.+26     	; 0x17a <DIO_SETPINDIR+0x98>
		{
			SET_BIT(DDRB,pinnumber);  
 160:	27 b3       	in	r18, 0x17	; 23
 162:	81 e0       	ldi	r24, 0x01	; 1
 164:	90 e0       	ldi	r25, 0x00	; 0
 166:	ac 01       	movw	r20, r24
 168:	02 c0       	rjmp	.+4      	; 0x16e <DIO_SETPINDIR+0x8c>
 16a:	44 0f       	add	r20, r20
 16c:	55 1f       	adc	r21, r21
 16e:	6a 95       	dec	r22
 170:	e2 f7       	brpl	.-8      	; 0x16a <DIO_SETPINDIR+0x88>
 172:	ba 01       	movw	r22, r20
 174:	62 2b       	or	r22, r18
 176:	67 bb       	out	0x17, r22	; 23
 178:	08 95       	ret
		}
		if(direction==0)
 17a:	44 23       	and	r20, r20
 17c:	09 f0       	breq	.+2      	; 0x180 <DIO_SETPINDIR+0x9e>
 17e:	4b c0       	rjmp	.+150    	; 0x216 <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRB,pinnumber);
 180:	27 b3       	in	r18, 0x17	; 23
 182:	81 e0       	ldi	r24, 0x01	; 1
 184:	90 e0       	ldi	r25, 0x00	; 0
 186:	ac 01       	movw	r20, r24
 188:	02 c0       	rjmp	.+4      	; 0x18e <DIO_SETPINDIR+0xac>
 18a:	44 0f       	add	r20, r20
 18c:	55 1f       	adc	r21, r21
 18e:	6a 95       	dec	r22
 190:	e2 f7       	brpl	.-8      	; 0x18a <DIO_SETPINDIR+0xa8>
 192:	ba 01       	movw	r22, r20
 194:	60 95       	com	r22
 196:	62 23       	and	r22, r18
 198:	67 bb       	out	0x17, r22	; 23
 19a:	08 95       	ret
		}
		break;
		case'C':
		case'c':
		if(direction==1)
 19c:	41 30       	cpi	r20, 0x01	; 1
 19e:	69 f4       	brne	.+26     	; 0x1ba <DIO_SETPINDIR+0xd8>
		{
			SET_BIT(DDRC,pinnumber);   
 1a0:	24 b3       	in	r18, 0x14	; 20
 1a2:	81 e0       	ldi	r24, 0x01	; 1
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	ac 01       	movw	r20, r24
 1a8:	02 c0       	rjmp	.+4      	; 0x1ae <DIO_SETPINDIR+0xcc>
 1aa:	44 0f       	add	r20, r20
 1ac:	55 1f       	adc	r21, r21
 1ae:	6a 95       	dec	r22
 1b0:	e2 f7       	brpl	.-8      	; 0x1aa <DIO_SETPINDIR+0xc8>
 1b2:	ba 01       	movw	r22, r20
 1b4:	62 2b       	or	r22, r18
 1b6:	64 bb       	out	0x14, r22	; 20
 1b8:	08 95       	ret
		}
		if(direction==0)
 1ba:	44 23       	and	r20, r20
 1bc:	61 f5       	brne	.+88     	; 0x216 <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRC,pinnumber);
 1be:	24 b3       	in	r18, 0x14	; 20
 1c0:	81 e0       	ldi	r24, 0x01	; 1
 1c2:	90 e0       	ldi	r25, 0x00	; 0
 1c4:	ac 01       	movw	r20, r24
 1c6:	02 c0       	rjmp	.+4      	; 0x1cc <DIO_SETPINDIR+0xea>
 1c8:	44 0f       	add	r20, r20
 1ca:	55 1f       	adc	r21, r21
 1cc:	6a 95       	dec	r22
 1ce:	e2 f7       	brpl	.-8      	; 0x1c8 <DIO_SETPINDIR+0xe6>
 1d0:	ba 01       	movw	r22, r20
 1d2:	60 95       	com	r22
 1d4:	62 23       	and	r22, r18
 1d6:	64 bb       	out	0x14, r22	; 20
 1d8:	08 95       	ret
		}
		break;
		case'D':
		case'd':
		if(direction==1)
 1da:	41 30       	cpi	r20, 0x01	; 1
 1dc:	69 f4       	brne	.+26     	; 0x1f8 <DIO_SETPINDIR+0x116>
		{
			SET_BIT(DDRD,pinnumber);   
 1de:	21 b3       	in	r18, 0x11	; 17
 1e0:	81 e0       	ldi	r24, 0x01	; 1
 1e2:	90 e0       	ldi	r25, 0x00	; 0
 1e4:	ac 01       	movw	r20, r24
 1e6:	02 c0       	rjmp	.+4      	; 0x1ec <DIO_SETPINDIR+0x10a>
 1e8:	44 0f       	add	r20, r20
 1ea:	55 1f       	adc	r21, r21
 1ec:	6a 95       	dec	r22
 1ee:	e2 f7       	brpl	.-8      	; 0x1e8 <DIO_SETPINDIR+0x106>
 1f0:	ba 01       	movw	r22, r20
 1f2:	62 2b       	or	r22, r18
 1f4:	61 bb       	out	0x11, r22	; 17
 1f6:	08 95       	ret
		}
		if(direction==0)
 1f8:	44 23       	and	r20, r20
 1fa:	69 f4       	brne	.+26     	; 0x216 <DIO_SETPINDIR+0x134>
		{
			CLEAR_BIT(DDRD,pinnumber);
 1fc:	21 b3       	in	r18, 0x11	; 17
 1fe:	81 e0       	ldi	r24, 0x01	; 1
 200:	90 e0       	ldi	r25, 0x00	; 0
 202:	ac 01       	movw	r20, r24
 204:	02 c0       	rjmp	.+4      	; 0x20a <DIO_SETPINDIR+0x128>
 206:	44 0f       	add	r20, r20
 208:	55 1f       	adc	r21, r21
 20a:	6a 95       	dec	r22
 20c:	e2 f7       	brpl	.-8      	; 0x206 <DIO_SETPINDIR+0x124>
 20e:	ba 01       	movw	r22, r20
 210:	60 95       	com	r22
 212:	62 23       	and	r22, r18
 214:	61 bb       	out	0x11, r22	; 17
 216:	08 95       	ret

00000218 <DIO_WRITE>:
}
// access PORT register to write the output value that will be on the output pin 
//Function Description : Set the value of the given pin in the given port (outputvalue 0 = low : 1 = high) 
void DIO_WRITE (unsigned char portname,unsigned char pinnumber, unsigned char outputvalue)
{
	switch(portname)
 218:	84 34       	cpi	r24, 0x44	; 68
 21a:	09 f4       	brne	.+2      	; 0x21e <DIO_WRITE+0x6>
 21c:	71 c0       	rjmp	.+226    	; 0x300 <DIO_WRITE+0xe8>
 21e:	85 34       	cpi	r24, 0x45	; 69
 220:	48 f4       	brcc	.+18     	; 0x234 <DIO_WRITE+0x1c>
 222:	82 34       	cpi	r24, 0x42	; 66
 224:	99 f1       	breq	.+102    	; 0x28c <DIO_WRITE+0x74>
 226:	83 34       	cpi	r24, 0x43	; 67
 228:	08 f0       	brcs	.+2      	; 0x22c <DIO_WRITE+0x14>
 22a:	4d c0       	rjmp	.+154    	; 0x2c6 <DIO_WRITE+0xae>
 22c:	81 34       	cpi	r24, 0x41	; 65
 22e:	09 f0       	breq	.+2      	; 0x232 <DIO_WRITE+0x1a>
 230:	83 c0       	rjmp	.+262    	; 0x338 <DIO_WRITE+0x120>
 232:	0f c0       	rjmp	.+30     	; 0x252 <DIO_WRITE+0x3a>
 234:	82 36       	cpi	r24, 0x62	; 98
 236:	51 f1       	breq	.+84     	; 0x28c <DIO_WRITE+0x74>
 238:	83 36       	cpi	r24, 0x63	; 99
 23a:	20 f4       	brcc	.+8      	; 0x244 <DIO_WRITE+0x2c>
 23c:	81 36       	cpi	r24, 0x61	; 97
 23e:	09 f0       	breq	.+2      	; 0x242 <DIO_WRITE+0x2a>
 240:	7b c0       	rjmp	.+246    	; 0x338 <DIO_WRITE+0x120>
 242:	07 c0       	rjmp	.+14     	; 0x252 <DIO_WRITE+0x3a>
 244:	83 36       	cpi	r24, 0x63	; 99
 246:	09 f4       	brne	.+2      	; 0x24a <DIO_WRITE+0x32>
 248:	3e c0       	rjmp	.+124    	; 0x2c6 <DIO_WRITE+0xae>
 24a:	84 36       	cpi	r24, 0x64	; 100
 24c:	09 f0       	breq	.+2      	; 0x250 <DIO_WRITE+0x38>
 24e:	74 c0       	rjmp	.+232    	; 0x338 <DIO_WRITE+0x120>
 250:	57 c0       	rjmp	.+174    	; 0x300 <DIO_WRITE+0xe8>
	{
		case 'A':
		case'a':
		if(outputvalue == 1)
 252:	41 30       	cpi	r20, 0x01	; 1
 254:	69 f4       	brne	.+26     	; 0x270 <DIO_WRITE+0x58>
		{
			SET_BIT(PORTA,pinnumber);
 256:	2b b3       	in	r18, 0x1b	; 27
 258:	81 e0       	ldi	r24, 0x01	; 1
 25a:	90 e0       	ldi	r25, 0x00	; 0
 25c:	ac 01       	movw	r20, r24
 25e:	02 c0       	rjmp	.+4      	; 0x264 <DIO_WRITE+0x4c>
 260:	44 0f       	add	r20, r20
 262:	55 1f       	adc	r21, r21
 264:	6a 95       	dec	r22
 266:	e2 f7       	brpl	.-8      	; 0x260 <DIO_WRITE+0x48>
 268:	ba 01       	movw	r22, r20
 26a:	62 2b       	or	r22, r18
 26c:	6b bb       	out	0x1b, r22	; 27
 26e:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTA,pinnumber);
 270:	2b b3       	in	r18, 0x1b	; 27
 272:	81 e0       	ldi	r24, 0x01	; 1
 274:	90 e0       	ldi	r25, 0x00	; 0
 276:	ac 01       	movw	r20, r24
 278:	02 c0       	rjmp	.+4      	; 0x27e <DIO_WRITE+0x66>
 27a:	44 0f       	add	r20, r20
 27c:	55 1f       	adc	r21, r21
 27e:	6a 95       	dec	r22
 280:	e2 f7       	brpl	.-8      	; 0x27a <DIO_WRITE+0x62>
 282:	ba 01       	movw	r22, r20
 284:	60 95       	com	r22
 286:	62 23       	and	r22, r18
 288:	6b bb       	out	0x1b, r22	; 27
 28a:	08 95       	ret
		}
		break;
		case 'B':
		case'b':
		if(outputvalue == 1)
 28c:	41 30       	cpi	r20, 0x01	; 1
 28e:	69 f4       	brne	.+26     	; 0x2aa <DIO_WRITE+0x92>
		{
			SET_BIT(PORTB,pinnumber);
 290:	28 b3       	in	r18, 0x18	; 24
 292:	81 e0       	ldi	r24, 0x01	; 1
 294:	90 e0       	ldi	r25, 0x00	; 0
 296:	ac 01       	movw	r20, r24
 298:	02 c0       	rjmp	.+4      	; 0x29e <DIO_WRITE+0x86>
 29a:	44 0f       	add	r20, r20
 29c:	55 1f       	adc	r21, r21
 29e:	6a 95       	dec	r22
 2a0:	e2 f7       	brpl	.-8      	; 0x29a <DIO_WRITE+0x82>
 2a2:	ba 01       	movw	r22, r20
 2a4:	62 2b       	or	r22, r18
 2a6:	68 bb       	out	0x18, r22	; 24
 2a8:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTB,pinnumber);
 2aa:	28 b3       	in	r18, 0x18	; 24
 2ac:	81 e0       	ldi	r24, 0x01	; 1
 2ae:	90 e0       	ldi	r25, 0x00	; 0
 2b0:	ac 01       	movw	r20, r24
 2b2:	02 c0       	rjmp	.+4      	; 0x2b8 <DIO_WRITE+0xa0>
 2b4:	44 0f       	add	r20, r20
 2b6:	55 1f       	adc	r21, r21
 2b8:	6a 95       	dec	r22
 2ba:	e2 f7       	brpl	.-8      	; 0x2b4 <DIO_WRITE+0x9c>
 2bc:	ba 01       	movw	r22, r20
 2be:	60 95       	com	r22
 2c0:	62 23       	and	r22, r18
 2c2:	68 bb       	out	0x18, r22	; 24
 2c4:	08 95       	ret
		}
		break;
		case 'C':
		case'c':
		if(outputvalue == 1)
 2c6:	41 30       	cpi	r20, 0x01	; 1
 2c8:	69 f4       	brne	.+26     	; 0x2e4 <DIO_WRITE+0xcc>
		{
			SET_BIT(PORTC,pinnumber);
 2ca:	25 b3       	in	r18, 0x15	; 21
 2cc:	81 e0       	ldi	r24, 0x01	; 1
 2ce:	90 e0       	ldi	r25, 0x00	; 0
 2d0:	ac 01       	movw	r20, r24
 2d2:	02 c0       	rjmp	.+4      	; 0x2d8 <DIO_WRITE+0xc0>
 2d4:	44 0f       	add	r20, r20
 2d6:	55 1f       	adc	r21, r21
 2d8:	6a 95       	dec	r22
 2da:	e2 f7       	brpl	.-8      	; 0x2d4 <DIO_WRITE+0xbc>
 2dc:	ba 01       	movw	r22, r20
 2de:	62 2b       	or	r22, r18
 2e0:	65 bb       	out	0x15, r22	; 21
 2e2:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTC,pinnumber);
 2e4:	25 b3       	in	r18, 0x15	; 21
 2e6:	81 e0       	ldi	r24, 0x01	; 1
 2e8:	90 e0       	ldi	r25, 0x00	; 0
 2ea:	ac 01       	movw	r20, r24
 2ec:	02 c0       	rjmp	.+4      	; 0x2f2 <DIO_WRITE+0xda>
 2ee:	44 0f       	add	r20, r20
 2f0:	55 1f       	adc	r21, r21
 2f2:	6a 95       	dec	r22
 2f4:	e2 f7       	brpl	.-8      	; 0x2ee <DIO_WRITE+0xd6>
 2f6:	ba 01       	movw	r22, r20
 2f8:	60 95       	com	r22
 2fa:	62 23       	and	r22, r18
 2fc:	65 bb       	out	0x15, r22	; 21
 2fe:	08 95       	ret
		}
		break;
		case 'D':
		case'd':
		if(outputvalue == 1)
 300:	41 30       	cpi	r20, 0x01	; 1
 302:	69 f4       	brne	.+26     	; 0x31e <DIO_WRITE+0x106>
		{
			SET_BIT(PORTD,pinnumber);
 304:	22 b3       	in	r18, 0x12	; 18
 306:	81 e0       	ldi	r24, 0x01	; 1
 308:	90 e0       	ldi	r25, 0x00	; 0
 30a:	ac 01       	movw	r20, r24
 30c:	02 c0       	rjmp	.+4      	; 0x312 <DIO_WRITE+0xfa>
 30e:	44 0f       	add	r20, r20
 310:	55 1f       	adc	r21, r21
 312:	6a 95       	dec	r22
 314:	e2 f7       	brpl	.-8      	; 0x30e <DIO_WRITE+0xf6>
 316:	ba 01       	movw	r22, r20
 318:	62 2b       	or	r22, r18
 31a:	62 bb       	out	0x12, r22	; 18
 31c:	08 95       	ret
		}
		else
		{
			CLEAR_BIT(PORTD,pinnumber);
 31e:	22 b3       	in	r18, 0x12	; 18
 320:	81 e0       	ldi	r24, 0x01	; 1
 322:	90 e0       	ldi	r25, 0x00	; 0
 324:	ac 01       	movw	r20, r24
 326:	02 c0       	rjmp	.+4      	; 0x32c <DIO_WRITE+0x114>
 328:	44 0f       	add	r20, r20
 32a:	55 1f       	adc	r21, r21
 32c:	6a 95       	dec	r22
 32e:	e2 f7       	brpl	.-8      	; 0x328 <DIO_WRITE+0x110>
 330:	ba 01       	movw	r22, r20
 332:	60 95       	com	r22
 334:	62 23       	and	r22, r18
 336:	62 bb       	out	0x12, r22	; 18
 338:	08 95       	ret

0000033a <DIO_togglepin>:
}		
// access PORT register to toggle the output value that appear in the output pin
//	Function Description : Reverse the value of the given pin in the given port.
void DIO_togglepin(unsigned char portname,unsigned char pinnumber)
{
			switch(portname)
 33a:	84 34       	cpi	r24, 0x44	; 68
 33c:	09 f4       	brne	.+2      	; 0x340 <DIO_togglepin+0x6>
 33e:	3d c0       	rjmp	.+122    	; 0x3ba <DIO_togglepin+0x80>
 340:	85 34       	cpi	r24, 0x45	; 69
 342:	40 f4       	brcc	.+16     	; 0x354 <DIO_togglepin+0x1a>
 344:	82 34       	cpi	r24, 0x42	; 66
 346:	f9 f0       	breq	.+62     	; 0x386 <DIO_togglepin+0x4c>
 348:	83 34       	cpi	r24, 0x43	; 67
 34a:	50 f5       	brcc	.+84     	; 0x3a0 <DIO_togglepin+0x66>
 34c:	81 34       	cpi	r24, 0x41	; 65
 34e:	09 f0       	breq	.+2      	; 0x352 <DIO_togglepin+0x18>
 350:	40 c0       	rjmp	.+128    	; 0x3d2 <DIO_togglepin+0x98>
 352:	0c c0       	rjmp	.+24     	; 0x36c <DIO_togglepin+0x32>
 354:	82 36       	cpi	r24, 0x62	; 98
 356:	b9 f0       	breq	.+46     	; 0x386 <DIO_togglepin+0x4c>
 358:	83 36       	cpi	r24, 0x63	; 99
 35a:	18 f4       	brcc	.+6      	; 0x362 <DIO_togglepin+0x28>
 35c:	81 36       	cpi	r24, 0x61	; 97
 35e:	c9 f5       	brne	.+114    	; 0x3d2 <DIO_togglepin+0x98>
 360:	05 c0       	rjmp	.+10     	; 0x36c <DIO_togglepin+0x32>
 362:	83 36       	cpi	r24, 0x63	; 99
 364:	e9 f0       	breq	.+58     	; 0x3a0 <DIO_togglepin+0x66>
 366:	84 36       	cpi	r24, 0x64	; 100
 368:	a1 f5       	brne	.+104    	; 0x3d2 <DIO_togglepin+0x98>
 36a:	27 c0       	rjmp	.+78     	; 0x3ba <DIO_togglepin+0x80>
			{
				case 'A':
				case 'a':
				TOGGLE_BIT(PORTA,pinnumber);
 36c:	2b b3       	in	r18, 0x1b	; 27
 36e:	81 e0       	ldi	r24, 0x01	; 1
 370:	90 e0       	ldi	r25, 0x00	; 0
 372:	ac 01       	movw	r20, r24
 374:	02 c0       	rjmp	.+4      	; 0x37a <DIO_togglepin+0x40>
 376:	44 0f       	add	r20, r20
 378:	55 1f       	adc	r21, r21
 37a:	6a 95       	dec	r22
 37c:	e2 f7       	brpl	.-8      	; 0x376 <DIO_togglepin+0x3c>
 37e:	ba 01       	movw	r22, r20
 380:	62 27       	eor	r22, r18
 382:	6b bb       	out	0x1b, r22	; 27
				break;
 384:	08 95       	ret
				
				case 'B':
				case 'b':
				TOGGLE_BIT(PORTB,pinnumber);
 386:	28 b3       	in	r18, 0x18	; 24
 388:	81 e0       	ldi	r24, 0x01	; 1
 38a:	90 e0       	ldi	r25, 0x00	; 0
 38c:	ac 01       	movw	r20, r24
 38e:	02 c0       	rjmp	.+4      	; 0x394 <DIO_togglepin+0x5a>
 390:	44 0f       	add	r20, r20
 392:	55 1f       	adc	r21, r21
 394:	6a 95       	dec	r22
 396:	e2 f7       	brpl	.-8      	; 0x390 <DIO_togglepin+0x56>
 398:	ba 01       	movw	r22, r20
 39a:	62 27       	eor	r22, r18
 39c:	68 bb       	out	0x18, r22	; 24
				break;
 39e:	08 95       	ret
				
				case 'C':
				case 'c':
				TOGGLE_BIT(PORTC,pinnumber);
 3a0:	25 b3       	in	r18, 0x15	; 21
 3a2:	81 e0       	ldi	r24, 0x01	; 1
 3a4:	90 e0       	ldi	r25, 0x00	; 0
 3a6:	ac 01       	movw	r20, r24
 3a8:	02 c0       	rjmp	.+4      	; 0x3ae <DIO_togglepin+0x74>
 3aa:	44 0f       	add	r20, r20
 3ac:	55 1f       	adc	r21, r21
 3ae:	6a 95       	dec	r22
 3b0:	e2 f7       	brpl	.-8      	; 0x3aa <DIO_togglepin+0x70>
 3b2:	ba 01       	movw	r22, r20
 3b4:	62 27       	eor	r22, r18
 3b6:	65 bb       	out	0x15, r22	; 21
				break;
 3b8:	08 95       	ret
				
				case 'D':
				case 'd':
				TOGGLE_BIT(PORTD,pinnumber);
 3ba:	22 b3       	in	r18, 0x12	; 18
 3bc:	81 e0       	ldi	r24, 0x01	; 1
 3be:	90 e0       	ldi	r25, 0x00	; 0
 3c0:	ac 01       	movw	r20, r24
 3c2:	02 c0       	rjmp	.+4      	; 0x3c8 <DIO_togglepin+0x8e>
 3c4:	44 0f       	add	r20, r20
 3c6:	55 1f       	adc	r21, r21
 3c8:	6a 95       	dec	r22
 3ca:	e2 f7       	brpl	.-8      	; 0x3c4 <DIO_togglepin+0x8a>
 3cc:	ba 01       	movw	r22, r20
 3ce:	62 27       	eor	r22, r18
 3d0:	62 bb       	out	0x12, r22	; 18
 3d2:	08 95       	ret

000003d4 <DIO_readpin>:
//Function Description : Returns 1 if the value of the given pin is high and zero if the value is low
//access pin register to know the reading of pin reg in case it is input pin to know the value of the voltage that it received from the input device connected to it
unsigned char DIO_readpin(unsigned char portname,unsigned char bitnumber)
{
	unsigned char reading=0;
	switch(portname)
 3d4:	84 34       	cpi	r24, 0x44	; 68
 3d6:	09 f4       	brne	.+2      	; 0x3da <DIO_readpin+0x6>
 3d8:	4e c0       	rjmp	.+156    	; 0x476 <DIO_readpin+0xa2>
 3da:	85 34       	cpi	r24, 0x45	; 69
 3dc:	40 f4       	brcc	.+16     	; 0x3ee <DIO_readpin+0x1a>
 3de:	82 34       	cpi	r24, 0x42	; 66
 3e0:	31 f1       	breq	.+76     	; 0x42e <DIO_readpin+0x5a>
 3e2:	83 34       	cpi	r24, 0x43	; 67
 3e4:	b0 f5       	brcc	.+108    	; 0x452 <DIO_readpin+0x7e>
 3e6:	81 34       	cpi	r24, 0x41	; 65
 3e8:	09 f0       	breq	.+2      	; 0x3ec <DIO_readpin+0x18>
 3ea:	57 c0       	rjmp	.+174    	; 0x49a <DIO_readpin+0xc6>
 3ec:	0e c0       	rjmp	.+28     	; 0x40a <DIO_readpin+0x36>
 3ee:	82 36       	cpi	r24, 0x62	; 98
 3f0:	f1 f0       	breq	.+60     	; 0x42e <DIO_readpin+0x5a>
 3f2:	83 36       	cpi	r24, 0x63	; 99
 3f4:	20 f4       	brcc	.+8      	; 0x3fe <DIO_readpin+0x2a>
 3f6:	81 36       	cpi	r24, 0x61	; 97
 3f8:	09 f0       	breq	.+2      	; 0x3fc <DIO_readpin+0x28>
 3fa:	4f c0       	rjmp	.+158    	; 0x49a <DIO_readpin+0xc6>
 3fc:	06 c0       	rjmp	.+12     	; 0x40a <DIO_readpin+0x36>
 3fe:	83 36       	cpi	r24, 0x63	; 99
 400:	41 f1       	breq	.+80     	; 0x452 <DIO_readpin+0x7e>
 402:	84 36       	cpi	r24, 0x64	; 100
 404:	09 f0       	breq	.+2      	; 0x408 <DIO_readpin+0x34>
 406:	49 c0       	rjmp	.+146    	; 0x49a <DIO_readpin+0xc6>
 408:	36 c0       	rjmp	.+108    	; 0x476 <DIO_readpin+0xa2>
	{
		case'A':
		case'a':
		reading= READ_BIT(PINA,bitnumber);
 40a:	29 b3       	in	r18, 0x19	; 25
 40c:	81 e0       	ldi	r24, 0x01	; 1
 40e:	90 e0       	ldi	r25, 0x00	; 0
 410:	06 2e       	mov	r0, r22
 412:	02 c0       	rjmp	.+4      	; 0x418 <DIO_readpin+0x44>
 414:	88 0f       	add	r24, r24
 416:	99 1f       	adc	r25, r25
 418:	0a 94       	dec	r0
 41a:	e2 f7       	brpl	.-8      	; 0x414 <DIO_readpin+0x40>
 41c:	30 e0       	ldi	r19, 0x00	; 0
 41e:	82 23       	and	r24, r18
 420:	93 23       	and	r25, r19
 422:	02 c0       	rjmp	.+4      	; 0x428 <DIO_readpin+0x54>
 424:	95 95       	asr	r25
 426:	87 95       	ror	r24
 428:	6a 95       	dec	r22
 42a:	e2 f7       	brpl	.-8      	; 0x424 <DIO_readpin+0x50>
		break;
 42c:	08 95       	ret
		
		case'B':
		case'b':
		reading= READ_BIT(PINB,bitnumber);
 42e:	26 b3       	in	r18, 0x16	; 22
 430:	81 e0       	ldi	r24, 0x01	; 1
 432:	90 e0       	ldi	r25, 0x00	; 0
 434:	06 2e       	mov	r0, r22
 436:	02 c0       	rjmp	.+4      	; 0x43c <DIO_readpin+0x68>
 438:	88 0f       	add	r24, r24
 43a:	99 1f       	adc	r25, r25
 43c:	0a 94       	dec	r0
 43e:	e2 f7       	brpl	.-8      	; 0x438 <DIO_readpin+0x64>
 440:	30 e0       	ldi	r19, 0x00	; 0
 442:	82 23       	and	r24, r18
 444:	93 23       	and	r25, r19
 446:	02 c0       	rjmp	.+4      	; 0x44c <DIO_readpin+0x78>
 448:	95 95       	asr	r25
 44a:	87 95       	ror	r24
 44c:	6a 95       	dec	r22
 44e:	e2 f7       	brpl	.-8      	; 0x448 <DIO_readpin+0x74>
		break;
 450:	08 95       	ret
		
		case'C':
		case'c':
		reading= READ_BIT(PINC,bitnumber);
 452:	23 b3       	in	r18, 0x13	; 19
 454:	81 e0       	ldi	r24, 0x01	; 1
 456:	90 e0       	ldi	r25, 0x00	; 0
 458:	06 2e       	mov	r0, r22
 45a:	02 c0       	rjmp	.+4      	; 0x460 <DIO_readpin+0x8c>
 45c:	88 0f       	add	r24, r24
 45e:	99 1f       	adc	r25, r25
 460:	0a 94       	dec	r0
 462:	e2 f7       	brpl	.-8      	; 0x45c <DIO_readpin+0x88>
 464:	30 e0       	ldi	r19, 0x00	; 0
 466:	82 23       	and	r24, r18
 468:	93 23       	and	r25, r19
 46a:	02 c0       	rjmp	.+4      	; 0x470 <DIO_readpin+0x9c>
 46c:	95 95       	asr	r25
 46e:	87 95       	ror	r24
 470:	6a 95       	dec	r22
 472:	e2 f7       	brpl	.-8      	; 0x46c <DIO_readpin+0x98>
		break;
 474:	08 95       	ret
		
		case'D':
		case'd':
		reading= READ_BIT(PIND,bitnumber);
 476:	20 b3       	in	r18, 0x10	; 16
 478:	81 e0       	ldi	r24, 0x01	; 1
 47a:	90 e0       	ldi	r25, 0x00	; 0
 47c:	06 2e       	mov	r0, r22
 47e:	02 c0       	rjmp	.+4      	; 0x484 <DIO_readpin+0xb0>
 480:	88 0f       	add	r24, r24
 482:	99 1f       	adc	r25, r25
 484:	0a 94       	dec	r0
 486:	e2 f7       	brpl	.-8      	; 0x480 <DIO_readpin+0xac>
 488:	30 e0       	ldi	r19, 0x00	; 0
 48a:	82 23       	and	r24, r18
 48c:	93 23       	and	r25, r19
 48e:	02 c0       	rjmp	.+4      	; 0x494 <DIO_readpin+0xc0>
 490:	95 95       	asr	r25
 492:	87 95       	ror	r24
 494:	6a 95       	dec	r22
 496:	e2 f7       	brpl	.-8      	; 0x490 <DIO_readpin+0xbc>
		break;	
 498:	08 95       	ret
}
//Function Description : Returns 1 if the value of the given pin is high and zero if the value is low
//access pin register to know the reading of pin reg in case it is input pin to know the value of the voltage that it received from the input device connected to it
unsigned char DIO_readpin(unsigned char portname,unsigned char bitnumber)
{
	unsigned char reading=0;
 49a:	80 e0       	ldi	r24, 0x00	; 0
		case'd':
		reading= READ_BIT(PIND,bitnumber);
		break;	
	}
	return reading;	
}
 49c:	08 95       	ret

0000049e <DIO_set_port_direction>:
//	Function Description : set the direction of whole port .
//to set the direction of the whole port (all pins of the port will be input or output )
void DIO_set_port_direction(unsigned char portname,unsigned char direction)
{
	switch(portname)
 49e:	84 34       	cpi	r24, 0x44	; 68
 4a0:	d9 f0       	breq	.+54     	; 0x4d8 <DIO_set_port_direction+0x3a>
 4a2:	85 34       	cpi	r24, 0x45	; 69
 4a4:	38 f4       	brcc	.+14     	; 0x4b4 <DIO_set_port_direction+0x16>
 4a6:	82 34       	cpi	r24, 0x42	; 66
 4a8:	99 f0       	breq	.+38     	; 0x4d0 <DIO_set_port_direction+0x32>
 4aa:	83 34       	cpi	r24, 0x43	; 67
 4ac:	98 f4       	brcc	.+38     	; 0x4d4 <DIO_set_port_direction+0x36>
 4ae:	81 34       	cpi	r24, 0x41	; 65
 4b0:	a1 f4       	brne	.+40     	; 0x4da <DIO_set_port_direction+0x3c>
 4b2:	0c c0       	rjmp	.+24     	; 0x4cc <DIO_set_port_direction+0x2e>
 4b4:	82 36       	cpi	r24, 0x62	; 98
 4b6:	61 f0       	breq	.+24     	; 0x4d0 <DIO_set_port_direction+0x32>
 4b8:	83 36       	cpi	r24, 0x63	; 99
 4ba:	18 f4       	brcc	.+6      	; 0x4c2 <DIO_set_port_direction+0x24>
 4bc:	81 36       	cpi	r24, 0x61	; 97
 4be:	69 f4       	brne	.+26     	; 0x4da <DIO_set_port_direction+0x3c>
 4c0:	05 c0       	rjmp	.+10     	; 0x4cc <DIO_set_port_direction+0x2e>
 4c2:	83 36       	cpi	r24, 0x63	; 99
 4c4:	39 f0       	breq	.+14     	; 0x4d4 <DIO_set_port_direction+0x36>
 4c6:	84 36       	cpi	r24, 0x64	; 100
 4c8:	41 f4       	brne	.+16     	; 0x4da <DIO_set_port_direction+0x3c>
 4ca:	06 c0       	rjmp	.+12     	; 0x4d8 <DIO_set_port_direction+0x3a>
	{
		case'A':
		case'a':
		DDRA=direction;
 4cc:	6a bb       	out	0x1a, r22	; 26
		break;
 4ce:	08 95       	ret
		case'B':
		case'b':
		DDRB=direction;
 4d0:	67 bb       	out	0x17, r22	; 23
		break;
 4d2:	08 95       	ret
		case'C':
		case'c':
		DDRC=direction;
 4d4:	64 bb       	out	0x14, r22	; 20
		break;
 4d6:	08 95       	ret
		case'D':
		case'd':
		DDRD=direction;
 4d8:	61 bb       	out	0x11, r22	; 17
 4da:	08 95       	ret

000004dc <DIO_write_port>:
	}
}
//	Function Description : Write the value to all port pins.
void DIO_write_port(unsigned char portname,unsigned char portvalue)
{
	switch(portname)
 4dc:	84 34       	cpi	r24, 0x44	; 68
 4de:	d9 f0       	breq	.+54     	; 0x516 <DIO_write_port+0x3a>
 4e0:	85 34       	cpi	r24, 0x45	; 69
 4e2:	38 f4       	brcc	.+14     	; 0x4f2 <DIO_write_port+0x16>
 4e4:	82 34       	cpi	r24, 0x42	; 66
 4e6:	99 f0       	breq	.+38     	; 0x50e <DIO_write_port+0x32>
 4e8:	83 34       	cpi	r24, 0x43	; 67
 4ea:	98 f4       	brcc	.+38     	; 0x512 <DIO_write_port+0x36>
 4ec:	81 34       	cpi	r24, 0x41	; 65
 4ee:	a1 f4       	brne	.+40     	; 0x518 <DIO_write_port+0x3c>
 4f0:	0c c0       	rjmp	.+24     	; 0x50a <DIO_write_port+0x2e>
 4f2:	82 36       	cpi	r24, 0x62	; 98
 4f4:	61 f0       	breq	.+24     	; 0x50e <DIO_write_port+0x32>
 4f6:	83 36       	cpi	r24, 0x63	; 99
 4f8:	18 f4       	brcc	.+6      	; 0x500 <DIO_write_port+0x24>
 4fa:	81 36       	cpi	r24, 0x61	; 97
 4fc:	69 f4       	brne	.+26     	; 0x518 <DIO_write_port+0x3c>
 4fe:	05 c0       	rjmp	.+10     	; 0x50a <DIO_write_port+0x2e>
 500:	83 36       	cpi	r24, 0x63	; 99
 502:	39 f0       	breq	.+14     	; 0x512 <DIO_write_port+0x36>
 504:	84 36       	cpi	r24, 0x64	; 100
 506:	41 f4       	brne	.+16     	; 0x518 <DIO_write_port+0x3c>
 508:	06 c0       	rjmp	.+12     	; 0x516 <DIO_write_port+0x3a>
	{
		case'A':
		case'a':
		PORTA=portvalue;
 50a:	6b bb       	out	0x1b, r22	; 27
		break;
 50c:	08 95       	ret
		case'B':
		case'b':
		PORTB=portvalue;
 50e:	68 bb       	out	0x18, r22	; 24
		break;
 510:	08 95       	ret
		case'C':
		case'c':
		PORTC=portvalue;
 512:	65 bb       	out	0x15, r22	; 21
		break;
 514:	08 95       	ret
		case'D':
		case'd':
		PORTD=portvalue;
 516:	62 bb       	out	0x12, r22	; 18
 518:	08 95       	ret

0000051a <DIO_read_port>:
}
//	Function Description : read the value of the port .
unsigned char DIO_read_port(unsigned char portname)
{
	unsigned char reading_port=0;
	switch(portname)
 51a:	84 34       	cpi	r24, 0x44	; 68
 51c:	d9 f0       	breq	.+54     	; 0x554 <DIO_read_port+0x3a>
 51e:	85 34       	cpi	r24, 0x45	; 69
 520:	38 f4       	brcc	.+14     	; 0x530 <DIO_read_port+0x16>
 522:	82 34       	cpi	r24, 0x42	; 66
 524:	99 f0       	breq	.+38     	; 0x54c <DIO_read_port+0x32>
 526:	83 34       	cpi	r24, 0x43	; 67
 528:	98 f4       	brcc	.+38     	; 0x550 <DIO_read_port+0x36>
 52a:	81 34       	cpi	r24, 0x41	; 65
 52c:	a9 f4       	brne	.+42     	; 0x558 <DIO_read_port+0x3e>
 52e:	0c c0       	rjmp	.+24     	; 0x548 <DIO_read_port+0x2e>
 530:	82 36       	cpi	r24, 0x62	; 98
 532:	61 f0       	breq	.+24     	; 0x54c <DIO_read_port+0x32>
 534:	83 36       	cpi	r24, 0x63	; 99
 536:	18 f4       	brcc	.+6      	; 0x53e <DIO_read_port+0x24>
 538:	81 36       	cpi	r24, 0x61	; 97
 53a:	71 f4       	brne	.+28     	; 0x558 <DIO_read_port+0x3e>
 53c:	05 c0       	rjmp	.+10     	; 0x548 <DIO_read_port+0x2e>
 53e:	83 36       	cpi	r24, 0x63	; 99
 540:	39 f0       	breq	.+14     	; 0x550 <DIO_read_port+0x36>
 542:	84 36       	cpi	r24, 0x64	; 100
 544:	49 f4       	brne	.+18     	; 0x558 <DIO_read_port+0x3e>
 546:	06 c0       	rjmp	.+12     	; 0x554 <DIO_read_port+0x3a>
	{
		case'A':
		case'a':
		reading_port=PINA;
 548:	89 b3       	in	r24, 0x19	; 25
		break;
 54a:	08 95       	ret
		case'B':
		case'b':
		reading_port=PINB;
 54c:	86 b3       	in	r24, 0x16	; 22
		break;
 54e:	08 95       	ret
		case'C':
		case'c':
		reading_port=PINC;
 550:	83 b3       	in	r24, 0x13	; 19
		break;
 552:	08 95       	ret
		case'D':
		case'd':
		reading_port=PIND;
 554:	80 b3       	in	r24, 0x10	; 16
		break;
 556:	08 95       	ret
	}	
}
//	Function Description : read the value of the port .
unsigned char DIO_read_port(unsigned char portname)
{
	unsigned char reading_port=0;
 558:	80 e0       	ldi	r24, 0x00	; 0
		reading_port=PIND;
		break;
		
	}
	return reading_port;
}
 55a:	08 95       	ret

0000055c <DIO_toggle_port>:
//	Function Description : toggle the value of the port that stored in PORT reg if the led connected to output pin will exit to it logic 0 instead of logic 1 .
void DIO_toggle_port(unsigned char portname)
{
	switch(portname)
 55c:	84 34       	cpi	r24, 0x44	; 68
 55e:	09 f1       	breq	.+66     	; 0x5a2 <DIO_toggle_port+0x46>
 560:	85 34       	cpi	r24, 0x45	; 69
 562:	38 f4       	brcc	.+14     	; 0x572 <DIO_toggle_port+0x16>
 564:	82 34       	cpi	r24, 0x42	; 66
 566:	a9 f0       	breq	.+42     	; 0x592 <DIO_toggle_port+0x36>
 568:	83 34       	cpi	r24, 0x43	; 67
 56a:	b8 f4       	brcc	.+46     	; 0x59a <DIO_toggle_port+0x3e>
 56c:	81 34       	cpi	r24, 0x41	; 65
 56e:	e1 f4       	brne	.+56     	; 0x5a8 <DIO_toggle_port+0x4c>
 570:	0c c0       	rjmp	.+24     	; 0x58a <DIO_toggle_port+0x2e>
 572:	82 36       	cpi	r24, 0x62	; 98
 574:	71 f0       	breq	.+28     	; 0x592 <DIO_toggle_port+0x36>
 576:	83 36       	cpi	r24, 0x63	; 99
 578:	18 f4       	brcc	.+6      	; 0x580 <DIO_toggle_port+0x24>
 57a:	81 36       	cpi	r24, 0x61	; 97
 57c:	a9 f4       	brne	.+42     	; 0x5a8 <DIO_toggle_port+0x4c>
 57e:	05 c0       	rjmp	.+10     	; 0x58a <DIO_toggle_port+0x2e>
 580:	83 36       	cpi	r24, 0x63	; 99
 582:	59 f0       	breq	.+22     	; 0x59a <DIO_toggle_port+0x3e>
 584:	84 36       	cpi	r24, 0x64	; 100
 586:	81 f4       	brne	.+32     	; 0x5a8 <DIO_toggle_port+0x4c>
 588:	0c c0       	rjmp	.+24     	; 0x5a2 <DIO_toggle_port+0x46>
	{
		case'A':
		case'a':
		PORTA= ~PORTA;   //PORTA^=0xff;
 58a:	8b b3       	in	r24, 0x1b	; 27
 58c:	80 95       	com	r24
 58e:	8b bb       	out	0x1b, r24	; 27
		break;
 590:	08 95       	ret
		case'B':
		case'b':
		PORTB =~PORTB;   
 592:	88 b3       	in	r24, 0x18	; 24
 594:	80 95       	com	r24
 596:	88 bb       	out	0x18, r24	; 24
		break;
 598:	08 95       	ret
		case'C':
		case'c':
		PORTC= ~PORTC;   
 59a:	85 b3       	in	r24, 0x15	; 21
 59c:	80 95       	com	r24
 59e:	85 bb       	out	0x15, r24	; 21
		break;
 5a0:	08 95       	ret
		case'D':
		case'd':
		PORTD= ~PORTD;   
 5a2:	82 b3       	in	r24, 0x12	; 18
 5a4:	80 95       	com	r24
 5a6:	82 bb       	out	0x12, r24	; 18
 5a8:	08 95       	ret

000005aa <DIO_CONNECT_PULLUP>:
		break;	
	}
}
void DIO_CONNECT_PULLUP(unsigned char portname,unsigned char pinnumber,unsigned char connect_pullup)
{
		DIO_WRITE(portname,pinnumber,connect_pullup);
 5aa:	0e 94 0c 01 	call	0x218	; 0x218 <DIO_WRITE>
}
 5ae:	08 95       	ret

000005b0 <DIO_WRITE_LOW_NIBBLE>:

void DIO_WRITE_LOW_NIBBLE(unsigned char portname,unsigned char value)
{
 5b0:	cf 92       	push	r12
 5b2:	df 92       	push	r13
 5b4:	ff 92       	push	r15
 5b6:	0f 93       	push	r16
 5b8:	1f 93       	push	r17
 5ba:	cf 93       	push	r28
 5bc:	df 93       	push	r29
 5be:	f8 2e       	mov	r15, r24
 5c0:	c0 e0       	ldi	r28, 0x00	; 0
 5c2:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_WRITE(portname,i,READ_BIT(value,i));
 5c4:	01 e0       	ldi	r16, 0x01	; 1
 5c6:	10 e0       	ldi	r17, 0x00	; 0
 5c8:	c6 2e       	mov	r12, r22
 5ca:	dd 24       	eor	r13, r13
 5cc:	c8 01       	movw	r24, r16
 5ce:	0c 2e       	mov	r0, r28
 5d0:	02 c0       	rjmp	.+4      	; 0x5d6 <DIO_WRITE_LOW_NIBBLE+0x26>
 5d2:	88 0f       	add	r24, r24
 5d4:	99 1f       	adc	r25, r25
 5d6:	0a 94       	dec	r0
 5d8:	e2 f7       	brpl	.-8      	; 0x5d2 <DIO_WRITE_LOW_NIBBLE+0x22>
 5da:	8c 21       	and	r24, r12
 5dc:	9d 21       	and	r25, r13
 5de:	9c 01       	movw	r18, r24
 5e0:	0c 2e       	mov	r0, r28
 5e2:	02 c0       	rjmp	.+4      	; 0x5e8 <DIO_WRITE_LOW_NIBBLE+0x38>
 5e4:	35 95       	asr	r19
 5e6:	27 95       	ror	r18
 5e8:	0a 94       	dec	r0
 5ea:	e2 f7       	brpl	.-8      	; 0x5e4 <DIO_WRITE_LOW_NIBBLE+0x34>
 5ec:	a9 01       	movw	r20, r18
 5ee:	8f 2d       	mov	r24, r15
 5f0:	6c 2f       	mov	r22, r28
 5f2:	0e 94 0c 01 	call	0x218	; 0x218 <DIO_WRITE>
 5f6:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_WRITE_LOW_NIBBLE(unsigned char portname,unsigned char value)
{
	unsigned char i;
	for(i=0;i<=3;i++)
 5f8:	c4 30       	cpi	r28, 0x04	; 4
 5fa:	d1 05       	cpc	r29, r1
 5fc:	39 f7       	brne	.-50     	; 0x5cc <DIO_WRITE_LOW_NIBBLE+0x1c>
	{
		DIO_WRITE(portname,i,READ_BIT(value,i));
	}
}
 5fe:	df 91       	pop	r29
 600:	cf 91       	pop	r28
 602:	1f 91       	pop	r17
 604:	0f 91       	pop	r16
 606:	ff 90       	pop	r15
 608:	df 90       	pop	r13
 60a:	cf 90       	pop	r12
 60c:	08 95       	ret

0000060e <DIO_WRITE_HIGH_NIBBLE>:

void DIO_WRITE_HIGH_NIBBLE(unsigned char portname,unsigned char value)
{
 60e:	cf 92       	push	r12
 610:	df 92       	push	r13
 612:	ff 92       	push	r15
 614:	0f 93       	push	r16
 616:	1f 93       	push	r17
 618:	cf 93       	push	r28
 61a:	df 93       	push	r29
 61c:	f8 2e       	mov	r15, r24
 61e:	c0 e0       	ldi	r28, 0x00	; 0
 620:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=4;i<=7;i++)
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
 622:	01 e0       	ldi	r16, 0x01	; 1
 624:	10 e0       	ldi	r17, 0x00	; 0
 626:	c6 2e       	mov	r12, r22
 628:	dd 24       	eor	r13, r13
	{
		DIO_WRITE(portname,i,READ_BIT(value,i));
	}
}

void DIO_WRITE_HIGH_NIBBLE(unsigned char portname,unsigned char value)
 62a:	6c 2f       	mov	r22, r28
 62c:	6c 5f       	subi	r22, 0xFC	; 252
{
	unsigned char i;
	for(i=4;i<=7;i++)
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
 62e:	c8 01       	movw	r24, r16
 630:	0c 2e       	mov	r0, r28
 632:	02 c0       	rjmp	.+4      	; 0x638 <DIO_WRITE_HIGH_NIBBLE+0x2a>
 634:	88 0f       	add	r24, r24
 636:	99 1f       	adc	r25, r25
 638:	0a 94       	dec	r0
 63a:	e2 f7       	brpl	.-8      	; 0x634 <DIO_WRITE_HIGH_NIBBLE+0x26>
 63c:	8c 21       	and	r24, r12
 63e:	9d 21       	and	r25, r13
 640:	9c 01       	movw	r18, r24
 642:	0c 2e       	mov	r0, r28
 644:	02 c0       	rjmp	.+4      	; 0x64a <DIO_WRITE_HIGH_NIBBLE+0x3c>
 646:	35 95       	asr	r19
 648:	27 95       	ror	r18
 64a:	0a 94       	dec	r0
 64c:	e2 f7       	brpl	.-8      	; 0x646 <DIO_WRITE_HIGH_NIBBLE+0x38>
 64e:	a9 01       	movw	r20, r18
 650:	8f 2d       	mov	r24, r15
 652:	0e 94 0c 01 	call	0x218	; 0x218 <DIO_WRITE>
 656:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_WRITE_HIGH_NIBBLE(unsigned char portname,unsigned char value)
{
	unsigned char i;
	for(i=4;i<=7;i++)
 658:	c4 30       	cpi	r28, 0x04	; 4
 65a:	d1 05       	cpc	r29, r1
 65c:	31 f7       	brne	.-52     	; 0x62a <DIO_WRITE_HIGH_NIBBLE+0x1c>
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
	}
}
 65e:	df 91       	pop	r29
 660:	cf 91       	pop	r28
 662:	1f 91       	pop	r17
 664:	0f 91       	pop	r16
 666:	ff 90       	pop	r15
 668:	df 90       	pop	r13
 66a:	cf 90       	pop	r12
 66c:	08 95       	ret

0000066e <DIO_WRITE_NIBBLE>:

void DIO_WRITE_NIBBLE(unsigned char portname,unsigned char startpin,unsigned char value)
{
 66e:	cf 92       	push	r12
 670:	df 92       	push	r13
 672:	ef 92       	push	r14
 674:	ff 92       	push	r15
 676:	0f 93       	push	r16
 678:	1f 93       	push	r17
 67a:	cf 93       	push	r28
 67c:	df 93       	push	r29
 67e:	08 2f       	mov	r16, r24
 680:	16 2f       	mov	r17, r22
 682:	c0 e0       	ldi	r28, 0x00	; 0
 684:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
 686:	ee 24       	eor	r14, r14
 688:	ff 24       	eor	r15, r15
 68a:	e3 94       	inc	r14
 68c:	c4 2e       	mov	r12, r20
 68e:	dd 24       	eor	r13, r13
	{
		DIO_WRITE(portname,i,READ_BIT(value,i-4));
	}
}

void DIO_WRITE_NIBBLE(unsigned char portname,unsigned char startpin,unsigned char value)
 690:	6c 2f       	mov	r22, r28
 692:	61 0f       	add	r22, r17
{
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
 694:	c7 01       	movw	r24, r14
 696:	0c 2e       	mov	r0, r28
 698:	02 c0       	rjmp	.+4      	; 0x69e <DIO_WRITE_NIBBLE+0x30>
 69a:	88 0f       	add	r24, r24
 69c:	99 1f       	adc	r25, r25
 69e:	0a 94       	dec	r0
 6a0:	e2 f7       	brpl	.-8      	; 0x69a <DIO_WRITE_NIBBLE+0x2c>
 6a2:	8c 21       	and	r24, r12
 6a4:	9d 21       	and	r25, r13
 6a6:	9c 01       	movw	r18, r24
 6a8:	0c 2e       	mov	r0, r28
 6aa:	02 c0       	rjmp	.+4      	; 0x6b0 <DIO_WRITE_NIBBLE+0x42>
 6ac:	35 95       	asr	r19
 6ae:	27 95       	ror	r18
 6b0:	0a 94       	dec	r0
 6b2:	e2 f7       	brpl	.-8      	; 0x6ac <DIO_WRITE_NIBBLE+0x3e>
 6b4:	a9 01       	movw	r20, r18
 6b6:	80 2f       	mov	r24, r16
 6b8:	0e 94 0c 01 	call	0x218	; 0x218 <DIO_WRITE>
 6bc:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_WRITE_NIBBLE(unsigned char portname,unsigned char startpin,unsigned char value)
{
	unsigned char i;
	for(i=0;i<=3;i++)
 6be:	c4 30       	cpi	r28, 0x04	; 4
 6c0:	d1 05       	cpc	r29, r1
 6c2:	31 f7       	brne	.-52     	; 0x690 <DIO_WRITE_NIBBLE+0x22>
	{
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
		startpin++;
	}
}
 6c4:	df 91       	pop	r29
 6c6:	cf 91       	pop	r28
 6c8:	1f 91       	pop	r17
 6ca:	0f 91       	pop	r16
 6cc:	ff 90       	pop	r15
 6ce:	ef 90       	pop	r14
 6d0:	df 90       	pop	r13
 6d2:	cf 90       	pop	r12
 6d4:	08 95       	ret

000006d6 <DIO_SET_DIR_NIPPLE>:

void DIO_SET_DIR_NIPPLE(unsigned char portname,unsigned char startpin,unsigned char direction)
{
 6d6:	cf 92       	push	r12
 6d8:	df 92       	push	r13
 6da:	ef 92       	push	r14
 6dc:	ff 92       	push	r15
 6de:	0f 93       	push	r16
 6e0:	1f 93       	push	r17
 6e2:	cf 93       	push	r28
 6e4:	df 93       	push	r29
 6e6:	08 2f       	mov	r16, r24
 6e8:	16 2f       	mov	r17, r22
 6ea:	c0 e0       	ldi	r28, 0x00	; 0
 6ec:	d0 e0       	ldi	r29, 0x00	; 0
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_SETPINDIR(portname,startpin,READ_BIT(direction,i));
 6ee:	ee 24       	eor	r14, r14
 6f0:	ff 24       	eor	r15, r15
 6f2:	e3 94       	inc	r14
 6f4:	c4 2e       	mov	r12, r20
 6f6:	dd 24       	eor	r13, r13
		DIO_WRITE(portname,startpin,READ_BIT(value,i));
		startpin++;
	}
}

void DIO_SET_DIR_NIPPLE(unsigned char portname,unsigned char startpin,unsigned char direction)
 6f8:	6c 2f       	mov	r22, r28
 6fa:	61 0f       	add	r22, r17
{
	unsigned char i;
	for(i=0;i<=3;i++)
	{
		DIO_SETPINDIR(portname,startpin,READ_BIT(direction,i));
 6fc:	c7 01       	movw	r24, r14
 6fe:	0c 2e       	mov	r0, r28
 700:	02 c0       	rjmp	.+4      	; 0x706 <DIO_SET_DIR_NIPPLE+0x30>
 702:	88 0f       	add	r24, r24
 704:	99 1f       	adc	r25, r25
 706:	0a 94       	dec	r0
 708:	e2 f7       	brpl	.-8      	; 0x702 <DIO_SET_DIR_NIPPLE+0x2c>
 70a:	8c 21       	and	r24, r12
 70c:	9d 21       	and	r25, r13
 70e:	9c 01       	movw	r18, r24
 710:	0c 2e       	mov	r0, r28
 712:	02 c0       	rjmp	.+4      	; 0x718 <DIO_SET_DIR_NIPPLE+0x42>
 714:	35 95       	asr	r19
 716:	27 95       	ror	r18
 718:	0a 94       	dec	r0
 71a:	e2 f7       	brpl	.-8      	; 0x714 <DIO_SET_DIR_NIPPLE+0x3e>
 71c:	a9 01       	movw	r20, r18
 71e:	80 2f       	mov	r24, r16
 720:	0e 94 71 00 	call	0xe2	; 0xe2 <DIO_SETPINDIR>
 724:	21 96       	adiw	r28, 0x01	; 1
}

void DIO_SET_DIR_NIPPLE(unsigned char portname,unsigned char startpin,unsigned char direction)
{
	unsigned char i;
	for(i=0;i<=3;i++)
 726:	c4 30       	cpi	r28, 0x04	; 4
 728:	d1 05       	cpc	r29, r1
 72a:	31 f7       	brne	.-52     	; 0x6f8 <DIO_SET_DIR_NIPPLE+0x22>
	{
		DIO_SETPINDIR(portname,startpin,READ_BIT(direction,i));
		startpin++;
	}	
}
 72c:	df 91       	pop	r29
 72e:	cf 91       	pop	r28
 730:	1f 91       	pop	r17
 732:	0f 91       	pop	r16
 734:	ff 90       	pop	r15
 736:	ef 90       	pop	r14
 738:	df 90       	pop	r13
 73a:	cf 90       	pop	r12
 73c:	08 95       	ret

0000073e <enable>:
		_delay_ms(1);
	}
}	
void enable()
{
	DIO_WRITE(port_control,EN,1);
 73e:	82 e4       	ldi	r24, 0x42	; 66
 740:	62 e0       	ldi	r22, 0x02	; 2
 742:	41 e0       	ldi	r20, 0x01	; 1
 744:	0e 94 0c 01 	call	0x218	; 0x218 <DIO_WRITE>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 748:	8f e9       	ldi	r24, 0x9F	; 159
 74a:	9f e0       	ldi	r25, 0x0F	; 15
 74c:	01 97       	sbiw	r24, 0x01	; 1
 74e:	f1 f7       	brne	.-4      	; 0x74c <enable+0xe>
 750:	00 c0       	rjmp	.+0      	; 0x752 <enable+0x14>
 752:	00 00       	nop
	_delay_ms(2);
	DIO_WRITE(port_control,EN,0);
 754:	82 e4       	ldi	r24, 0x42	; 66
 756:	62 e0       	ldi	r22, 0x02	; 2
 758:	40 e0       	ldi	r20, 0x00	; 0
 75a:	0e 94 0c 01 	call	0x218	; 0x218 <DIO_WRITE>
 75e:	8f e9       	ldi	r24, 0x9F	; 159
 760:	9f e0       	ldi	r25, 0x0F	; 15
 762:	01 97       	sbiw	r24, 0x01	; 1
 764:	f1 f7       	brne	.-4      	; 0x762 <enable+0x24>
 766:	00 c0       	rjmp	.+0      	; 0x768 <enable+0x2a>
 768:	00 00       	nop
	_delay_ms(2);
 76a:	08 95       	ret

0000076c <LCD_SEND_CMD>:
		
	#endif
}

void LCD_SEND_CMD (unsigned char cmd)
{
 76c:	cf 93       	push	r28
 76e:	c8 2f       	mov	r28, r24
	DIO_WRITE(port_control,RS,0);
	enable();
	_delay_ms(1);   // time that the lcd execute the cmd ,all cmds take 1ms expect clear screen and return home so i made them in separated functions
	#else 
	#if defined HIGH_NIPPLE
	DIO_WRITE(port_control,RS,0);
 770:	82 e4       	ldi	r24, 0x42	; 66
 772:	60 e0       	ldi	r22, 0x00	; 0
 774:	40 e0       	ldi	r20, 0x00	; 0
 776:	0e 94 0c 01 	call	0x218	; 0x218 <DIO_WRITE>
	DIO_WRITE_HIGH_NIBBLE(port_data,cmd>>4);
 77a:	6c 2f       	mov	r22, r28
 77c:	62 95       	swap	r22
 77e:	6f 70       	andi	r22, 0x0F	; 15
 780:	81 e4       	ldi	r24, 0x41	; 65
 782:	0e 94 07 03 	call	0x60e	; 0x60e <DIO_WRITE_HIGH_NIBBLE>
	enable();
 786:	0e 94 9f 03 	call	0x73e	; 0x73e <enable>
	DIO_WRITE_HIGH_NIBBLE(port_data,cmd);
 78a:	81 e4       	ldi	r24, 0x41	; 65
 78c:	6c 2f       	mov	r22, r28
 78e:	0e 94 07 03 	call	0x60e	; 0x60e <DIO_WRITE_HIGH_NIBBLE>
	enable();
 792:	0e 94 9f 03 	call	0x73e	; 0x73e <enable>
	enable();
	_delay_ms(1);  //write this and if the cmd is clear screen or return home write after it delay 10 ms or do not write it in the function and after calling this function in main make a delay
	#endif
	#endif

}
 796:	cf 91       	pop	r28
 798:	08 95       	ret

0000079a <lCD_MOVE_CURSOR>:
}

void lCD_MOVE_CURSOR (unsigned char row,unsigned char column)
{
	char cmd;
	if(row<1 || row>2 || column<1 || column>16)  // any invalid case
 79a:	98 2f       	mov	r25, r24
 79c:	91 50       	subi	r25, 0x01	; 1
 79e:	92 30       	cpi	r25, 0x02	; 2
 7a0:	60 f4       	brcc	.+24     	; 0x7ba <lCD_MOVE_CURSOR+0x20>
 7a2:	66 23       	and	r22, r22
 7a4:	61 f0       	breq	.+24     	; 0x7be <lCD_MOVE_CURSOR+0x24>
 7a6:	61 31       	cpi	r22, 0x11	; 17
 7a8:	60 f4       	brcc	.+24     	; 0x7c2 <lCD_MOVE_CURSOR+0x28>
	{
		cmd=0X80;
	}
	else if(row == 1)
 7aa:	81 30       	cpi	r24, 0x01	; 1
 7ac:	19 f4       	brne	.+6      	; 0x7b4 <lCD_MOVE_CURSOR+0x1a>
	{
		cmd=0X80+column-1;
 7ae:	86 2f       	mov	r24, r22
 7b0:	81 58       	subi	r24, 0x81	; 129
 7b2:	08 c0       	rjmp	.+16     	; 0x7c4 <lCD_MOVE_CURSOR+0x2a>
	}
	else
	{
		cmd=0XC0+column-1;
 7b4:	86 2f       	mov	r24, r22
 7b6:	81 54       	subi	r24, 0x41	; 65
 7b8:	05 c0       	rjmp	.+10     	; 0x7c4 <lCD_MOVE_CURSOR+0x2a>
void lCD_MOVE_CURSOR (unsigned char row,unsigned char column)
{
	char cmd;
	if(row<1 || row>2 || column<1 || column>16)  // any invalid case
	{
		cmd=0X80;
 7ba:	80 e8       	ldi	r24, 0x80	; 128
 7bc:	03 c0       	rjmp	.+6      	; 0x7c4 <lCD_MOVE_CURSOR+0x2a>
 7be:	80 e8       	ldi	r24, 0x80	; 128
 7c0:	01 c0       	rjmp	.+2      	; 0x7c4 <lCD_MOVE_CURSOR+0x2a>
 7c2:	80 e8       	ldi	r24, 0x80	; 128
	}
	else
	{
		cmd=0XC0+column-1;
	}
	LCD_SEND_CMD(cmd);
 7c4:	0e 94 b6 03 	call	0x76c	; 0x76c <LCD_SEND_CMD>
}
 7c8:	08 95       	ret

000007ca <LCD_Return_home>:
	_delay_ms(10);
}

void LCD_Return_home()
{
	LCD_SEND_CMD(Return_Home);
 7ca:	82 e0       	ldi	r24, 0x02	; 2
 7cc:	0e 94 b6 03 	call	0x76c	; 0x76c <LCD_SEND_CMD>
 7d0:	8f e1       	ldi	r24, 0x1F	; 31
 7d2:	9e e4       	ldi	r25, 0x4E	; 78
 7d4:	01 97       	sbiw	r24, 0x01	; 1
 7d6:	f1 f7       	brne	.-4      	; 0x7d4 <LCD_Return_home+0xa>
 7d8:	00 c0       	rjmp	.+0      	; 0x7da <LCD_Return_home+0x10>
 7da:	00 00       	nop
	_delay_ms(10);
}
 7dc:	08 95       	ret

000007de <LCD_CLEAR_SCREEN>:

}

void LCD_CLEAR_SCREEN()
{
	LCD_SEND_CMD(clear_screen);
 7de:	81 e0       	ldi	r24, 0x01	; 1
 7e0:	0e 94 b6 03 	call	0x76c	; 0x76c <LCD_SEND_CMD>
 7e4:	8f e1       	ldi	r24, 0x1F	; 31
 7e6:	9e e4       	ldi	r25, 0x4E	; 78
 7e8:	01 97       	sbiw	r24, 0x01	; 1
 7ea:	f1 f7       	brne	.-4      	; 0x7e8 <LCD_CLEAR_SCREEN+0xa>
 7ec:	00 c0       	rjmp	.+0      	; 0x7ee <LCD_CLEAR_SCREEN+0x10>
 7ee:	00 00       	nop
	_delay_ms(10);
}
 7f0:	08 95       	ret

000007f2 <LCD_INIT>:
 7f2:	8f ef       	ldi	r24, 0xFF	; 255
 7f4:	91 ee       	ldi	r25, 0xE1	; 225
 7f6:	a4 e0       	ldi	r26, 0x04	; 4
 7f8:	81 50       	subi	r24, 0x01	; 1
 7fa:	90 40       	sbci	r25, 0x00	; 0
 7fc:	a0 40       	sbci	r26, 0x00	; 0
 7fe:	e1 f7       	brne	.-8      	; 0x7f8 <LCD_INIT+0x6>
 800:	00 c0       	rjmp	.+0      	; 0x802 <LCD_INIT+0x10>
 802:	00 00       	nop
	LCD_SEND_CMD(Display_on_Cursor_off);  //display on/off control
	LCD_CLEAR_SCREEN();
	LCD_SEND_CMD(Entry_Mode);
	#else
	#if defined HIGH_NIPPLE
	DIO_SETPINDIR(port_data,4,1);
 804:	81 e4       	ldi	r24, 0x41	; 65
 806:	64 e0       	ldi	r22, 0x04	; 4
 808:	41 e0       	ldi	r20, 0x01	; 1
 80a:	0e 94 71 00 	call	0xe2	; 0xe2 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_data,5,1);
 80e:	81 e4       	ldi	r24, 0x41	; 65
 810:	65 e0       	ldi	r22, 0x05	; 5
 812:	41 e0       	ldi	r20, 0x01	; 1
 814:	0e 94 71 00 	call	0xe2	; 0xe2 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_data,6,1);
 818:	81 e4       	ldi	r24, 0x41	; 65
 81a:	66 e0       	ldi	r22, 0x06	; 6
 81c:	41 e0       	ldi	r20, 0x01	; 1
 81e:	0e 94 71 00 	call	0xe2	; 0xe2 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_data,7,1);
 822:	81 e4       	ldi	r24, 0x41	; 65
 824:	67 e0       	ldi	r22, 0x07	; 7
 826:	41 e0       	ldi	r20, 0x01	; 1
 828:	0e 94 71 00 	call	0xe2	; 0xe2 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_data,2,1);
	DIO_SETPINDIR(port_data,3,1);
	#else
	DIO_SET_DIR_NIPPLE(port_data,start_pin,0xFF);   //write 0 for low nipple ,write  4 for high nipple 
	#endif
	DIO_SETPINDIR(port_control,RS,1);
 82c:	82 e4       	ldi	r24, 0x42	; 66
 82e:	60 e0       	ldi	r22, 0x00	; 0
 830:	41 e0       	ldi	r20, 0x01	; 1
 832:	0e 94 71 00 	call	0xe2	; 0xe2 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_control,EN,1);
 836:	82 e4       	ldi	r24, 0x42	; 66
 838:	62 e0       	ldi	r22, 0x02	; 2
 83a:	41 e0       	ldi	r20, 0x01	; 1
 83c:	0e 94 71 00 	call	0xe2	; 0xe2 <DIO_SETPINDIR>
	DIO_SETPINDIR(port_control,R_W,1);
 840:	82 e4       	ldi	r24, 0x42	; 66
 842:	61 e0       	ldi	r22, 0x01	; 1
 844:	41 e0       	ldi	r20, 0x01	; 1
 846:	0e 94 71 00 	call	0xe2	; 0xe2 <DIO_SETPINDIR>
	DIO_WRITE(port_control,R_W,0);
 84a:	82 e4       	ldi	r24, 0x42	; 66
 84c:	61 e0       	ldi	r22, 0x01	; 1
 84e:	40 e0       	ldi	r20, 0x00	; 0
 850:	0e 94 0c 01 	call	0x218	; 0x218 <DIO_WRITE>
	LCD_Return_home();
 854:	0e 94 e5 03 	call	0x7ca	; 0x7ca <LCD_Return_home>
	LCD_SEND_CMD(four_bit);
 858:	88 e2       	ldi	r24, 0x28	; 40
 85a:	0e 94 b6 03 	call	0x76c	; 0x76c <LCD_SEND_CMD>
	LCD_SEND_CMD(Display_on_Cursor_off);
 85e:	8c e0       	ldi	r24, 0x0C	; 12
 860:	0e 94 b6 03 	call	0x76c	; 0x76c <LCD_SEND_CMD>
	LCD_CLEAR_SCREEN();
 864:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_CLEAR_SCREEN>
	LCD_SEND_CMD(Entry_Mode);
 868:	86 e0       	ldi	r24, 0x06	; 6
 86a:	0e 94 b6 03 	call	0x76c	; 0x76c <LCD_SEND_CMD>
	#endif	
}
 86e:	08 95       	ret

00000870 <LCD_SEND_CHAR>:

void LCD_SEND_CHAR (unsigned char data)
{
 870:	cf 93       	push	r28
 872:	c8 2f       	mov	r28, r24
	DIO_write_port(port_data,data);
	DIO_WRITE(port_control,RS,1);
	enable();
	#else 
	#ifdef HIGH_NIPPLE
	DIO_WRITE(port_control,RS,1);
 874:	82 e4       	ldi	r24, 0x42	; 66
 876:	60 e0       	ldi	r22, 0x00	; 0
 878:	41 e0       	ldi	r20, 0x01	; 1
 87a:	0e 94 0c 01 	call	0x218	; 0x218 <DIO_WRITE>
	DIO_WRITE_HIGH_NIBBLE(port_data,data>>4);
 87e:	6c 2f       	mov	r22, r28
 880:	62 95       	swap	r22
 882:	6f 70       	andi	r22, 0x0F	; 15
 884:	81 e4       	ldi	r24, 0x41	; 65
 886:	0e 94 07 03 	call	0x60e	; 0x60e <DIO_WRITE_HIGH_NIBBLE>
	enable();
 88a:	0e 94 9f 03 	call	0x73e	; 0x73e <enable>
	DIO_WRITE_HIGH_NIBBLE(port_data,data);
 88e:	81 e4       	ldi	r24, 0x41	; 65
 890:	6c 2f       	mov	r22, r28
 892:	0e 94 07 03 	call	0x60e	; 0x60e <DIO_WRITE_HIGH_NIBBLE>
	enable();
 896:	0e 94 9f 03 	call	0x73e	; 0x73e <enable>
	DIO_WRITE_NIBBLE(port_data,start_pin,data);
	enable();
	#endif
		
	#endif
}
 89a:	cf 91       	pop	r28
 89c:	08 95       	ret

0000089e <LCD_SEND_STRING>:
	}
	LCD_SEND_CMD(cmd);
}

void LCD_SEND_STRING (const char* ptr)
{
 89e:	cf 93       	push	r28
 8a0:	df 93       	push	r29
 8a2:	ec 01       	movw	r28, r24
	while((*ptr) != '\0')
 8a4:	88 81       	ld	r24, Y
 8a6:	88 23       	and	r24, r24
 8a8:	61 f0       	breq	.+24     	; 0x8c2 <LCD_SEND_STRING+0x24>
		cmd=0XC0+column-1;
	}
	LCD_SEND_CMD(cmd);
}

void LCD_SEND_STRING (const char* ptr)
 8aa:	21 96       	adiw	r28, 0x01	; 1
{
	while((*ptr) != '\0')
	{
		LCD_SEND_CHAR(*ptr);
 8ac:	0e 94 38 04 	call	0x870	; 0x870 <LCD_SEND_CHAR>
 8b0:	8f ec       	ldi	r24, 0xCF	; 207
 8b2:	97 e0       	ldi	r25, 0x07	; 7
 8b4:	01 97       	sbiw	r24, 0x01	; 1
 8b6:	f1 f7       	brne	.-4      	; 0x8b4 <LCD_SEND_STRING+0x16>
 8b8:	00 c0       	rjmp	.+0      	; 0x8ba <LCD_SEND_STRING+0x1c>
 8ba:	00 00       	nop
	LCD_SEND_CMD(cmd);
}

void LCD_SEND_STRING (const char* ptr)
{
	while((*ptr) != '\0')
 8bc:	89 91       	ld	r24, Y+
 8be:	88 23       	and	r24, r24
 8c0:	a9 f7       	brne	.-22     	; 0x8ac <LCD_SEND_STRING+0xe>
	{
		LCD_SEND_CHAR(*ptr);
		ptr++;
		_delay_ms(1);
	}
}	
 8c2:	df 91       	pop	r29
 8c4:	cf 91       	pop	r28
 8c6:	08 95       	ret

000008c8 <LED_INIT>:
 */ 
#include "DIO.h"
//make the led in this port output pin
void LED_INIT(unsigned char portname,unsigned char pinnumber)
{
	DIO_SETPINDIR(portname,pinnumber,1);
 8c8:	41 e0       	ldi	r20, 0x01	; 1
 8ca:	0e 94 71 00 	call	0xe2	; 0xe2 <DIO_SETPINDIR>
}
 8ce:	08 95       	ret

000008d0 <LED_ON>:
//write on this on logic high
void LED_ON(unsigned char portname,unsigned char pinnumber)
{
	DIO_WRITE(portname,pinnumber,1);
 8d0:	41 e0       	ldi	r20, 0x01	; 1
 8d2:	0e 94 0c 01 	call	0x218	; 0x218 <DIO_WRITE>
}
 8d6:	08 95       	ret

000008d8 <LED_OFF>:
//write on this on logic low
void LED_OFF(unsigned char portname,unsigned char pinnumber)
{
	DIO_WRITE(portname,pinnumber,0);
 8d8:	40 e0       	ldi	r20, 0x00	; 0
 8da:	0e 94 0c 01 	call	0x218	; 0x218 <DIO_WRITE>
}
 8de:	08 95       	ret

000008e0 <LED_TOGGLE>:
//TOGGLE the output of the led
void LED_TOGGLE(unsigned char portname,unsigned char pinnumber)
{
	DIO_togglepin(portname,pinnumber);
 8e0:	0e 94 9d 01 	call	0x33a	; 0x33a <DIO_togglepin>
}
 8e4:	08 95       	ret

000008e6 <LED_READ_STATUS>:
unsigned char LED_READ_STATUS(unsigned char portname,unsigned char pinnumber)
{
	return DIO_readpin(portname,pinnumber);
 8e6:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <DIO_readpin>
}
 8ea:	08 95       	ret

000008ec <LED_set_port_direction>:
void LED_set_port_direction(unsigned char portname,unsigned char direction)
{
	DIO_set_port_direction(portname,direction);
 8ec:	0e 94 4f 02 	call	0x49e	; 0x49e <DIO_set_port_direction>
}
 8f0:	08 95       	ret

000008f2 <LED_toggle_port>:
void LED_toggle_port(unsigned char portname)
{
	DIO_toggle_port(portname);
 8f2:	0e 94 ae 02 	call	0x55c	; 0x55c <DIO_toggle_port>
 8f6:	08 95       	ret

000008f8 <timer_CTC_init_interrupt>:
#include "STD_MACROS.h"

void timer_CTC_init_interrupt()
{
	//Select ctc mode
	SET_BIT(TCCR0,WGM01);
 8f8:	83 b7       	in	r24, 0x33	; 51
 8fa:	88 60       	ori	r24, 0x08	; 8
 8fc:	83 bf       	out	0x33, r24	; 51
	//select timer clk
	SET_BIT(TCCR0,CS00);
 8fe:	83 b7       	in	r24, 0x33	; 51
 900:	81 60       	ori	r24, 0x01	; 1
 902:	83 bf       	out	0x33, r24	; 51
	SET_BIT(TCCR0,CS02);
 904:	83 b7       	in	r24, 0x33	; 51
 906:	84 60       	ori	r24, 0x04	; 4
 908:	83 bf       	out	0x33, r24	; 51
	// load a value in ocr0
	OCR0=80;
 90a:	80 e5       	ldi	r24, 0x50	; 80
 90c:	8c bf       	out	0x3c, r24	; 60
	//enable interrupt
	sei();
 90e:	78 94       	sei
	SET_BIT(TIMSK,OCIE0);
 910:	89 b7       	in	r24, 0x39	; 57
 912:	82 60       	ori	r24, 0x02	; 2
 914:	89 bf       	out	0x39, r24	; 57
}
 916:	08 95       	ret

00000918 <timer_wave_NPWM>:

//generating signal in oc0 (PB3) pin in CTC mode 
void timer_wave_NPWM (void)
{
	// set OC0 as output pin
	SET_BIT(DDRB,3);
 918:	bb 9a       	sbi	0x17, 3	; 23
	// choose CTC mode
	SET_BIT(TCCR0,WGM01);
 91a:	83 b7       	in	r24, 0x33	; 51
 91c:	88 60       	ori	r24, 0x08	; 8
 91e:	83 bf       	out	0x33, r24	; 51
	//Load value in OCR0
	OCR0=64;
 920:	80 e4       	ldi	r24, 0x40	; 64
 922:	8c bf       	out	0x3c, r24	; 60
	// select timer clock
	SET_BIT(TCCR0,CS00);
 924:	83 b7       	in	r24, 0x33	; 51
 926:	81 60       	ori	r24, 0x01	; 1
 928:	83 bf       	out	0x33, r24	; 51
	SET_BIT(TCCR0,CS02);
 92a:	83 b7       	in	r24, 0x33	; 51
 92c:	84 60       	ori	r24, 0x04	; 4
 92e:	83 bf       	out	0x33, r24	; 51
	//toggle OC0 on compare match
	SET_BIT(TCCR0,COM00);
 930:	83 b7       	in	r24, 0x33	; 51
 932:	80 61       	ori	r24, 0x10	; 16
 934:	83 bf       	out	0x33, r24	; 51
}
 936:	08 95       	ret

00000938 <timer_wave_FASTPWM>:
// generate PWM signal with specific duty cycle
void timer_wave_FASTPWM (void)
{
	// set OC0 as output pin
	SET_BIT(DDRB,3);
 938:	bb 9a       	sbi	0x17, 3	; 23
	// choose fast PWM mode
	SET_BIT(TCCR0,WGM00);
 93a:	83 b7       	in	r24, 0x33	; 51
 93c:	80 64       	ori	r24, 0x40	; 64
 93e:	83 bf       	out	0x33, r24	; 51
	SET_BIT(TCCR0,WGM01);
 940:	83 b7       	in	r24, 0x33	; 51
 942:	88 60       	ori	r24, 0x08	; 8
 944:	83 bf       	out	0x33, r24	; 51
	//Load value in OCR0
	OCR0=64;		 //duty cycle=25%
 946:	80 e4       	ldi	r24, 0x40	; 64
 948:	8c bf       	out	0x3c, r24	; 60
	// select timer clock, prescalar=1024
	SET_BIT(TCCR0,CS00);
 94a:	83 b7       	in	r24, 0x33	; 51
 94c:	81 60       	ori	r24, 0x01	; 1
 94e:	83 bf       	out	0x33, r24	; 51
	SET_BIT(TCCR0,CS02);
 950:	83 b7       	in	r24, 0x33	; 51
 952:	84 60       	ori	r24, 0x04	; 4
 954:	83 bf       	out	0x33, r24	; 51
	//choose inverting mode
	SET_BIT(TCCR0,COM00);
 956:	83 b7       	in	r24, 0x33	; 51
 958:	80 61       	ori	r24, 0x10	; 16
 95a:	83 bf       	out	0x33, r24	; 51
	SET_BIT(TCCR0,COM01);
 95c:	83 b7       	in	r24, 0x33	; 51
 95e:	80 62       	ori	r24, 0x20	; 32
 960:	83 bf       	out	0x33, r24	; 51
}
 962:	08 95       	ret

00000964 <timer_wave_phasecorrect_PWM>:

void timer_wave_phasecorrect_PWM (void)
{
	// set OC0 as output pin
	SET_BIT(DDRB,3);
 964:	bb 9a       	sbi	0x17, 3	; 23
	// choose fast PWM mode
	SET_BIT(TCCR0,WGM00); 
 966:	83 b7       	in	r24, 0x33	; 51
 968:	80 64       	ori	r24, 0x40	; 64
 96a:	83 bf       	out	0x33, r24	; 51
	//Load value in OCR0
	OCR0=64;		 //duty cycle=25%
 96c:	80 e4       	ldi	r24, 0x40	; 64
 96e:	8c bf       	out	0x3c, r24	; 60
	//select timer clock, prescalar=1024
	SET_BIT(TCCR0,CS00);
 970:	83 b7       	in	r24, 0x33	; 51
 972:	81 60       	ori	r24, 0x01	; 1
 974:	83 bf       	out	0x33, r24	; 51
	SET_BIT(TCCR0,CS02);
 976:	83 b7       	in	r24, 0x33	; 51
 978:	84 60       	ori	r24, 0x04	; 4
 97a:	83 bf       	out	0x33, r24	; 51
	//choose mode
	SET_BIT(TCCR0,COM00);
 97c:	83 b7       	in	r24, 0x33	; 51
 97e:	80 61       	ori	r24, 0x10	; 16
 980:	83 bf       	out	0x33, r24	; 51
	SET_BIT(TCCR0,COM01);	
 982:	83 b7       	in	r24, 0x33	; 51
 984:	80 62       	ori	r24, 0x20	; 32
 986:	83 bf       	out	0x33, r24	; 51
 988:	08 95       	ret

0000098a <main>:
    }
}
*/
int main()
{
	LCD_INIT();
 98a:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LCD_INIT>
	timer_CTC_init_interrupt();
 98e:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <timer_CTC_init_interrupt>
	LED_INIT('d',0);
 992:	84 e6       	ldi	r24, 0x64	; 100
 994:	60 e0       	ldi	r22, 0x00	; 0
 996:	0e 94 64 04 	call	0x8c8	; 0x8c8 <LED_INIT>
	LED_INIT('d',1);
 99a:	84 e6       	ldi	r24, 0x64	; 100
 99c:	61 e0       	ldi	r22, 0x01	; 1
 99e:	0e 94 64 04 	call	0x8c8	; 0x8c8 <LED_INIT>
	LED_INIT('d',2);
 9a2:	84 e6       	ldi	r24, 0x64	; 100
 9a4:	62 e0       	ldi	r22, 0x02	; 2
 9a6:	0e 94 64 04 	call	0x8c8	; 0x8c8 <LED_INIT>
	while(1)
	{
		
		LCD_SEND_STRING("remaining 10 sec");
 9aa:	0f 2e       	mov	r0, r31
 9ac:	f0 e6       	ldi	r31, 0x60	; 96
 9ae:	af 2e       	mov	r10, r31
 9b0:	f0 e0       	ldi	r31, 0x00	; 0
 9b2:	bf 2e       	mov	r11, r31
 9b4:	f0 2d       	mov	r31, r0
		LED_ON('d',0);
		counter1=10;
 9b6:	0f 2e       	mov	r0, r31
 9b8:	fa e0       	ldi	r31, 0x0A	; 10
 9ba:	ff 2e       	mov	r15, r31
 9bc:	f0 2d       	mov	r31, r0
			count_down(&counter1,&counter);
 9be:	c4 e9       	ldi	r28, 0x94	; 148
 9c0:	d0 e0       	ldi	r29, 0x00	; 0
 9c2:	05 e9       	ldi	r16, 0x95	; 149
 9c4:	10 e0       	ldi	r17, 0x00	; 0
		counter1=5;
 9c6:	0f 2e       	mov	r0, r31
 9c8:	f5 e0       	ldi	r31, 0x05	; 5
 9ca:	ef 2e       	mov	r14, r31
 9cc:	f0 2d       	mov	r31, r0
		_delay_ms(500);
		LCD_CLEAR_SCREEN();
		LCD_SEND_STRING("remaining 5 sec");
 9ce:	0f 2e       	mov	r0, r31
 9d0:	f1 e7       	ldi	r31, 0x71	; 113
 9d2:	8f 2e       	mov	r8, r31
 9d4:	f0 e0       	ldi	r31, 0x00	; 0
 9d6:	9f 2e       	mov	r9, r31
 9d8:	f0 2d       	mov	r31, r0
		LED_OFF('d',0);
		LED_ON('d',1);
			count_down(&counter1,&counter);
		counter1=7;
 9da:	0f 2e       	mov	r0, r31
 9dc:	f7 e0       	ldi	r31, 0x07	; 7
 9de:	df 2e       	mov	r13, r31
 9e0:	f0 2d       	mov	r31, r0
		_delay_ms(500);
		LCD_CLEAR_SCREEN();
		LCD_SEND_STRING("remaining 7 sec");
 9e2:	0f 2e       	mov	r0, r31
 9e4:	f1 e8       	ldi	r31, 0x81	; 129
 9e6:	6f 2e       	mov	r6, r31
 9e8:	f0 e0       	ldi	r31, 0x00	; 0
 9ea:	7f 2e       	mov	r7, r31
 9ec:	f0 2d       	mov	r31, r0
	LED_INIT('d',1);
	LED_INIT('d',2);
	while(1)
	{
		
		LCD_SEND_STRING("remaining 10 sec");
 9ee:	c5 01       	movw	r24, r10
 9f0:	0e 94 4f 04 	call	0x89e	; 0x89e <LCD_SEND_STRING>
		LED_ON('d',0);
 9f4:	84 e6       	ldi	r24, 0x64	; 100
 9f6:	60 e0       	ldi	r22, 0x00	; 0
 9f8:	0e 94 68 04 	call	0x8d0	; 0x8d0 <LED_ON>
		counter1=10;
 9fc:	f0 92 94 00 	sts	0x0094, r15
			count_down(&counter1,&counter);
 a00:	ce 01       	movw	r24, r28
 a02:	b8 01       	movw	r22, r16
 a04:	0e 94 49 00 	call	0x92	; 0x92 <count_down>
		counter1=5;
 a08:	e0 92 94 00 	sts	0x0094, r14
 a0c:	8f ef       	ldi	r24, 0xFF	; 255
 a0e:	94 e3       	ldi	r25, 0x34	; 52
 a10:	ac e0       	ldi	r26, 0x0C	; 12
 a12:	81 50       	subi	r24, 0x01	; 1
 a14:	90 40       	sbci	r25, 0x00	; 0
 a16:	a0 40       	sbci	r26, 0x00	; 0
 a18:	e1 f7       	brne	.-8      	; 0xa12 <main+0x88>
 a1a:	00 c0       	rjmp	.+0      	; 0xa1c <main+0x92>
 a1c:	00 00       	nop
		_delay_ms(500);
		LCD_CLEAR_SCREEN();
 a1e:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_CLEAR_SCREEN>
		LCD_SEND_STRING("remaining 5 sec");
 a22:	c4 01       	movw	r24, r8
 a24:	0e 94 4f 04 	call	0x89e	; 0x89e <LCD_SEND_STRING>
		LED_OFF('d',0);
 a28:	84 e6       	ldi	r24, 0x64	; 100
 a2a:	60 e0       	ldi	r22, 0x00	; 0
 a2c:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <LED_OFF>
		LED_ON('d',1);
 a30:	84 e6       	ldi	r24, 0x64	; 100
 a32:	61 e0       	ldi	r22, 0x01	; 1
 a34:	0e 94 68 04 	call	0x8d0	; 0x8d0 <LED_ON>
			count_down(&counter1,&counter);
 a38:	ce 01       	movw	r24, r28
 a3a:	b8 01       	movw	r22, r16
 a3c:	0e 94 49 00 	call	0x92	; 0x92 <count_down>
		counter1=7;
 a40:	d0 92 94 00 	sts	0x0094, r13
 a44:	8f ef       	ldi	r24, 0xFF	; 255
 a46:	94 e3       	ldi	r25, 0x34	; 52
 a48:	ac e0       	ldi	r26, 0x0C	; 12
 a4a:	81 50       	subi	r24, 0x01	; 1
 a4c:	90 40       	sbci	r25, 0x00	; 0
 a4e:	a0 40       	sbci	r26, 0x00	; 0
 a50:	e1 f7       	brne	.-8      	; 0xa4a <main+0xc0>
 a52:	00 c0       	rjmp	.+0      	; 0xa54 <main+0xca>
 a54:	00 00       	nop
		_delay_ms(500);
		LCD_CLEAR_SCREEN();
 a56:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_CLEAR_SCREEN>
		LCD_SEND_STRING("remaining 7 sec");
 a5a:	c3 01       	movw	r24, r6
 a5c:	0e 94 4f 04 	call	0x89e	; 0x89e <LCD_SEND_STRING>
		LED_OFF('d',1);
 a60:	84 e6       	ldi	r24, 0x64	; 100
 a62:	61 e0       	ldi	r22, 0x01	; 1
 a64:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <LED_OFF>
		LED_ON('d',2);
 a68:	84 e6       	ldi	r24, 0x64	; 100
 a6a:	62 e0       	ldi	r22, 0x02	; 2
 a6c:	0e 94 68 04 	call	0x8d0	; 0x8d0 <LED_ON>
			count_down(&counter1,&counter);	
 a70:	ce 01       	movw	r24, r28
 a72:	b8 01       	movw	r22, r16
 a74:	0e 94 49 00 	call	0x92	; 0x92 <count_down>
 a78:	8f ef       	ldi	r24, 0xFF	; 255
 a7a:	94 e3       	ldi	r25, 0x34	; 52
 a7c:	ac e0       	ldi	r26, 0x0C	; 12
 a7e:	81 50       	subi	r24, 0x01	; 1
 a80:	90 40       	sbci	r25, 0x00	; 0
 a82:	a0 40       	sbci	r26, 0x00	; 0
 a84:	e1 f7       	brne	.-8      	; 0xa7e <main+0xf4>
 a86:	00 c0       	rjmp	.+0      	; 0xa88 <main+0xfe>
 a88:	00 00       	nop
		_delay_ms(500);
		LCD_CLEAR_SCREEN();
 a8a:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_CLEAR_SCREEN>
 a8e:	af cf       	rjmp	.-162    	; 0x9ee <main+0x64>

00000a90 <__vector_10>:
	
}


ISR(TIMER0_COMP_vect)
{
 a90:	1f 92       	push	r1
 a92:	0f 92       	push	r0
 a94:	0f b6       	in	r0, 0x3f	; 63
 a96:	0f 92       	push	r0
 a98:	11 24       	eor	r1, r1
 a9a:	8f 93       	push	r24
 a9c:	9f 93       	push	r25
	counter++;
 a9e:	80 91 95 00 	lds	r24, 0x0095
 aa2:	90 91 96 00 	lds	r25, 0x0096
 aa6:	01 96       	adiw	r24, 0x01	; 1
 aa8:	90 93 96 00 	sts	0x0096, r25
 aac:	80 93 95 00 	sts	0x0095, r24
}
 ab0:	9f 91       	pop	r25
 ab2:	8f 91       	pop	r24
 ab4:	0f 90       	pop	r0
 ab6:	0f be       	out	0x3f, r0	; 63
 ab8:	0f 90       	pop	r0
 aba:	1f 90       	pop	r1
 abc:	18 95       	reti

00000abe <_exit>:
 abe:	f8 94       	cli

00000ac0 <__stop_program>:
 ac0:	ff cf       	rjmp	.-2      	; 0xac0 <__stop_program>
